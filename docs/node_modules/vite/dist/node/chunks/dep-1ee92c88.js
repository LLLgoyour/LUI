'use strict';

var fs = require('fs');
var path = require('path');
var chalk = require('chalk');
var connect = require('connect');
var corsMiddleware = require('cors');
var chokidar = require('chokidar');
var debug$9 = require('debug');
var os = require('os');
var url = require('url');
var resolve$1 = require('resolve');
var builtins = require('builtin-modules');
var remapping = require('@ampproject/remapping');
var acorn = require('acorn');
var acornClassFields = require('acorn-class-fields');
var acornStaticClassFeatures = require('acorn-static-class-features');
var MagicString = require('magic-string');
var strip = require('strip-ansi');
var http = require('http');
var https = require('https');
var WebSocket = require('ws');
var httpProxy = require('http-proxy');
var history = require('connect-history-api-fallback');
var getEtag = require('etag');
var convertSourceMap = require('convert-source-map');
var crypto = require('crypto');
var periscopic = require('periscopic');
var estreeWalker = require('estree-walker');
var sirv = require('sirv');
var glob = require('fast-glob');
var postcssrc = require('postcss-load-config');
var pluginutils = require('@rollup/pluginutils');
var esbuild = require('esbuild');
var tsconfck = require('tsconfck');
var resolve_exports = require('resolve.exports');
var esModuleLexer = require('es-module-lexer');
var match = require('minimatch');
var sourceMap = require('source-map');
var open = require('open');
var execa = require('execa');
var child_process = require('child_process');
var launchEditorMiddleware = require('launch-editor-middleware');
var readline = require('readline');
var aliasPlugin = require('@rollup/plugin-alias');
var dotenv = require('dotenv');
var dotenvExpand = require('dotenv-expand');
var zlib = require('zlib');
var util = require('util');
var okie = require('okie');
var commonjsPlugin = require('@rollup/plugin-commonjs');
var dynamicImportVars = require('@rollup/plugin-dynamic-import-vars');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        for (var k in e) {
            n[k] = e[k];
        }
    }
    n["default"] = e;
    return n;
}

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var connect__default = /*#__PURE__*/_interopDefaultLegacy(connect);
var corsMiddleware__default = /*#__PURE__*/_interopDefaultLegacy(corsMiddleware);
var chokidar__default = /*#__PURE__*/_interopDefaultLegacy(chokidar);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug$9);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var resolve__default = /*#__PURE__*/_interopDefaultLegacy(resolve$1);
var builtins__default = /*#__PURE__*/_interopDefaultLegacy(builtins);
var remapping__default = /*#__PURE__*/_interopDefaultLegacy(remapping);
var acorn__namespace = /*#__PURE__*/_interopNamespace(acorn);
var acornClassFields__default = /*#__PURE__*/_interopDefaultLegacy(acornClassFields);
var acornStaticClassFeatures__default = /*#__PURE__*/_interopDefaultLegacy(acornStaticClassFeatures);
var MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);
var strip__default = /*#__PURE__*/_interopDefaultLegacy(strip);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);
var httpProxy__default = /*#__PURE__*/_interopDefaultLegacy(httpProxy);
var history__default = /*#__PURE__*/_interopDefaultLegacy(history);
var getEtag__default = /*#__PURE__*/_interopDefaultLegacy(getEtag);
var convertSourceMap__namespace = /*#__PURE__*/_interopNamespace(convertSourceMap);
var sirv__default = /*#__PURE__*/_interopDefaultLegacy(sirv);
var glob__default = /*#__PURE__*/_interopDefaultLegacy(glob);
var postcssrc__default = /*#__PURE__*/_interopDefaultLegacy(postcssrc);
var match__default = /*#__PURE__*/_interopDefaultLegacy(match);
var open__default = /*#__PURE__*/_interopDefaultLegacy(open);
var execa__default = /*#__PURE__*/_interopDefaultLegacy(execa);
var launchEditorMiddleware__default = /*#__PURE__*/_interopDefaultLegacy(launchEditorMiddleware);
var readline__default = /*#__PURE__*/_interopDefaultLegacy(readline);
var aliasPlugin__default = /*#__PURE__*/_interopDefaultLegacy(aliasPlugin);
var dotenv__default = /*#__PURE__*/_interopDefaultLegacy(dotenv);
var dotenvExpand__default = /*#__PURE__*/_interopDefaultLegacy(dotenvExpand);
var commonjsPlugin__default = /*#__PURE__*/_interopDefaultLegacy(commonjsPlugin);
var dynamicImportVars__default = /*#__PURE__*/_interopDefaultLegacy(dynamicImportVars);

const DEFAULT_MAIN_FIELDS = [
    'module',
    'jsnext:main',
    'jsnext'
];
const DEFAULT_EXTENSIONS = [
    '.mjs',
    '.js',
    '.ts',
    '.jsx',
    '.tsx',
    '.json'
];
const JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/;
const OPTIMIZABLE_ENTRY_RE = /\.(?:m?js|ts)$/;
const SPECIAL_QUERY_RE = /[\?&](?:worker|sharedworker|raw|url)\b/;
/**
 * Prefix for resolved fs paths, since windows paths may not be valid as URLs.
 */
const FS_PREFIX = `/@fs/`;
/**
 * Prefix for resolved Ids that are not valid browser import specifiers
 */
const VALID_ID_PREFIX = `/@id/`;
/**
 * Some Rollup plugins use ids that starts with the null byte \0 to avoid
 * collisions, but it is not permitted in import URLs so we have to replace
 * them.
 */
const NULL_BYTE_PLACEHOLDER = `__x00__`;
const CLIENT_PUBLIC_PATH = `/@vite/client`;
const ENV_PUBLIC_PATH = `/@vite/env`;
// eslint-disable-next-line node/no-missing-require
const CLIENT_ENTRY = require.resolve('vite/dist/client/client.mjs');
// eslint-disable-next-line node/no-missing-require
const ENV_ENTRY = require.resolve('vite/dist/client/env.mjs');
const CLIENT_DIR = path__default.dirname(CLIENT_ENTRY);
// ** READ THIS ** before editing `KNOWN_ASSET_TYPES`.
//   If you add an asset to `KNOWN_ASSET_TYPES`, make sure to also add it
//   to the TypeScript declaration file `packages/vite/client.d.ts`.
const KNOWN_ASSET_TYPES = [
    // images
    'png',
    'jpe?g',
    'gif',
    'svg',
    'ico',
    'webp',
    'avif',
    // media
    'mp4',
    'webm',
    'ogg',
    'mp3',
    'wav',
    'flac',
    'aac',
    // fonts
    'woff2?',
    'eot',
    'ttf',
    'otf',
    // other
    'wasm',
    'webmanifest',
    'pdf'
];
const DEFAULT_ASSETS_RE = new RegExp(`\\.(` + KNOWN_ASSET_TYPES.join('|') + `)(\\?.*)?$`);
const DEP_VERSION_RE = /[\?&](v=[\w\.-]+)\b/;

function slash(p) {
    return p.replace(/\\/g, '/');
}
// Strip valid id prefix. This is prepended to resolved Ids that are
// not valid browser import specifiers by the importAnalysis plugin.
function unwrapId(id) {
    return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length) : id;
}
const flattenId = (id) => id.replace(/(\s*>\s*)/g, '__').replace(/[\/\.]/g, '_');
const normalizeId = (id) => id.replace(/(\s*>\s*)/g, ' > ');
function isBuiltin(id) {
    return builtins__default.includes(id);
}
const bareImportRE = /^[\w@](?!.*:\/\/)/;
const deepImportRE = /^([^@][^/]*)\/|^(@[^/]+\/[^/]+)\//;
let isRunningWithYarnPnp;
try {
    isRunningWithYarnPnp = Boolean(require('pnpapi'));
}
catch { }
const ssrExtensions = ['.js', '.cjs', '.json', '.node'];
function resolveFrom(id, basedir, preserveSymlinks = false, ssr = false) {
    return resolve__default.sync(id, {
        basedir,
        extensions: ssr ? ssrExtensions : DEFAULT_EXTENSIONS,
        // necessary to work with pnpm
        preserveSymlinks: preserveSymlinks || isRunningWithYarnPnp || false
    });
}
/**
 * like `resolveFrom` but supports resolving `>` path in `id`,
 * for example: `foo > bar > baz`
 */
function nestedResolveFrom(id, basedir, preserveSymlinks = false) {
    const pkgs = id.split('>').map((pkg) => pkg.trim());
    try {
        for (const pkg of pkgs) {
            basedir = resolveFrom(pkg, basedir, preserveSymlinks);
        }
    }
    catch { }
    return basedir;
}
// set in bin/vite.js
const filter = process.env.VITE_DEBUG_FILTER;
const DEBUG = process.env.DEBUG;
function createDebugger(namespace, options = {}) {
    const log = debug__default(namespace);
    const { onlyWhenFocused } = options;
    const focus = typeof onlyWhenFocused === 'string' ? onlyWhenFocused : namespace;
    return (msg, ...args) => {
        if (filter && !msg.includes(filter)) {
            return;
        }
        if (onlyWhenFocused && !(DEBUG === null || DEBUG === void 0 ? void 0 : DEBUG.includes(focus))) {
            return;
        }
        log(msg, ...args);
    };
}
const isWindows = os__default.platform() === 'win32';
const VOLUME_RE = /^[A-Z]:/i;
function normalizePath(id) {
    return path__default.posix.normalize(isWindows ? slash(id) : id);
}
function fsPathFromId(id) {
    const fsPath = normalizePath(id.slice(FS_PREFIX.length));
    return fsPath.startsWith('/') || fsPath.match(VOLUME_RE)
        ? fsPath
        : `/${fsPath}`;
}
function ensureVolumeInPath(file) {
    return isWindows ? path__default.resolve(file) : file;
}
const queryRE = /\?.*$/s;
const hashRE = /#.*$/s;
const cleanUrl = (url) => url.replace(hashRE, '').replace(queryRE, '');
const externalRE = /^(https?:)?\/\//;
const isExternalUrl = (url) => externalRE.test(url);
const dataUrlRE = /^\s*data:/i;
const isDataUrl = (url) => dataUrlRE.test(url);
const knownJsSrcRE = /\.((j|t)sx?|mjs|vue|marko|svelte)($|\?)/;
const isJSRequest = (url) => {
    url = cleanUrl(url);
    if (knownJsSrcRE.test(url)) {
        return true;
    }
    if (!path__default.extname(url) && !url.endsWith('/')) {
        return true;
    }
    return false;
};
const importQueryRE = /(\?|&)import=?(?:&|$)/;
const internalPrefixes = [
    FS_PREFIX,
    VALID_ID_PREFIX,
    CLIENT_PUBLIC_PATH,
    ENV_PUBLIC_PATH
];
const InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join('|')})`);
const trailingSeparatorRE = /[\?&]$/;
const isImportRequest = (url) => importQueryRE.test(url);
const isInternalRequest = (url) => InternalPrefixRE.test(url);
function removeImportQuery(url) {
    return url.replace(importQueryRE, '$1').replace(trailingSeparatorRE, '');
}
function injectQuery(url$1, queryToInject) {
    // encode percents for consistent behavior with pathToFileURL
    // see #2614 for details
    let resolvedUrl = new url.URL(url$1.replace(/%/g, '%25'), 'relative:///');
    if (resolvedUrl.protocol !== 'relative:') {
        resolvedUrl = url.pathToFileURL(url$1);
    }
    let { protocol, pathname, search, hash } = resolvedUrl;
    if (protocol === 'file:') {
        pathname = pathname.slice(1);
    }
    pathname = decodeURIComponent(pathname);
    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;
}
const timestampRE = /\bt=\d{13}&?\b/;
function removeTimestampQuery(url) {
    return url.replace(timestampRE, '').replace(trailingSeparatorRE, '');
}
async function asyncReplace(input, re, replacer) {
    let match;
    let remaining = input;
    let rewritten = '';
    while ((match = re.exec(remaining))) {
        rewritten += remaining.slice(0, match.index);
        rewritten += await replacer(match);
        remaining = remaining.slice(match.index + match[0].length);
    }
    rewritten += remaining;
    return rewritten;
}
function timeFrom(start, subtract = 0) {
    const time = Date.now() - start - subtract;
    const timeString = (time + `ms`).padEnd(5, ' ');
    if (time < 10) {
        return chalk__default.green(timeString);
    }
    else if (time < 50) {
        return chalk__default.yellow(timeString);
    }
    else {
        return chalk__default.red(timeString);
    }
}
/**
 * pretty url for logging.
 */
function prettifyUrl(url, root) {
    url = removeTimestampQuery(url);
    const isAbsoluteFile = url.startsWith(root);
    if (isAbsoluteFile || url.startsWith(FS_PREFIX)) {
        let file = path__default.relative(root, isAbsoluteFile ? url : fsPathFromId(url));
        const seg = file.split('/');
        const npmIndex = seg.indexOf(`node_modules`);
        const isSourceMap = file.endsWith('.map');
        if (npmIndex > 0) {
            file = seg[npmIndex + 1];
            if (file.startsWith('@')) {
                file = `${file}/${seg[npmIndex + 2]}`;
            }
            file = `npm: ${chalk__default.dim(file)}${isSourceMap ? ` (source map)` : ``}`;
        }
        return chalk__default.dim(file);
    }
    else {
        return chalk__default.dim(url);
    }
}
function isObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}
function isDefined(value) {
    return value != null;
}
function lookupFile(dir, formats, pathOnly = false) {
    for (const format of formats) {
        const fullPath = path__default.join(dir, format);
        if (fs__default.existsSync(fullPath) && fs__default.statSync(fullPath).isFile()) {
            return pathOnly ? fullPath : fs__default.readFileSync(fullPath, 'utf-8');
        }
    }
    const parentDir = path__default.dirname(dir);
    if (parentDir !== dir) {
        return lookupFile(parentDir, formats, pathOnly);
    }
}
const splitRE = /\r?\n/;
const range = 2;
function pad(source, n = 2) {
    const lines = source.split(splitRE);
    return lines.map((l) => ` `.repeat(n) + l).join(`\n`);
}
function posToNumber(source, pos) {
    if (typeof pos === 'number')
        return pos;
    const lines = source.split(splitRE);
    const { line, column } = pos;
    let start = 0;
    for (let i = 0; i < line - 1; i++) {
        start += lines[i].length + 1;
    }
    return start + column;
}
function numberToPos(source, offset) {
    if (typeof offset !== 'number')
        return offset;
    if (offset > source.length) {
        throw new Error(`offset is longer than source length! offset ${offset} > length ${source.length}`);
    }
    const lines = source.split(splitRE);
    let counted = 0;
    let line = 0;
    let column = 0;
    for (; line < lines.length; line++) {
        const lineLength = lines[line].length + 1;
        if (counted + lineLength >= offset) {
            column = offset - counted + 1;
            break;
        }
        counted += lineLength;
    }
    return { line: line + 1, column };
}
function generateCodeFrame(source, start = 0, end) {
    start = posToNumber(source, start);
    end = end || start;
    const lines = source.split(splitRE);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}
function writeFile(filename, content) {
    const dir = path__default.dirname(filename);
    if (!fs__default.existsSync(dir)) {
        fs__default.mkdirSync(dir, { recursive: true });
    }
    fs__default.writeFileSync(filename, content);
}
/**
 * Delete every file and subdirectory. **The given directory must exist.**
 * Pass an optional `skip` array to preserve files in the root directory.
 */
function emptyDir(dir, skip) {
    for (const file of fs__default.readdirSync(dir)) {
        if (skip === null || skip === void 0 ? void 0 : skip.includes(file)) {
            continue;
        }
        const abs = path__default.resolve(dir, file);
        // baseline is Node 12 so can't use rmSync :(
        if (fs__default.lstatSync(abs).isDirectory()) {
            emptyDir(abs);
            fs__default.rmdirSync(abs);
        }
        else {
            fs__default.unlinkSync(abs);
        }
    }
}
function copyDir(srcDir, destDir) {
    fs__default.mkdirSync(destDir, { recursive: true });
    for (const file of fs__default.readdirSync(srcDir)) {
        const srcFile = path__default.resolve(srcDir, file);
        if (srcFile === destDir) {
            continue;
        }
        const destFile = path__default.resolve(destDir, file);
        const stat = fs__default.statSync(srcFile);
        if (stat.isDirectory()) {
            copyDir(srcFile, destFile);
        }
        else {
            fs__default.copyFileSync(srcFile, destFile);
        }
    }
}
function ensureLeadingSlash(path) {
    return !path.startsWith('/') ? '/' + path : path;
}
function ensureWatchedFile(watcher, file, root) {
    if (file &&
        // only need to watch if out of root
        !file.startsWith(root + '/') &&
        // some rollup plugins use null bytes for private resolved Ids
        !file.includes('\0') &&
        fs__default.existsSync(file)) {
        // resolve file to normalized system path
        watcher.add(path__default.resolve(file));
    }
}
const escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
async function processSrcSet(srcs, replacer) {
    const imageCandidates = srcs
        .split(',')
        .map((s) => {
        const [url, descriptor] = s
            .replace(escapedSpaceCharacters, ' ')
            .trim()
            .split(' ', 2);
        return { url, descriptor };
    })
        .filter(({ url }) => !!url);
    const ret = await Promise.all(imageCandidates.map(async ({ url, descriptor }) => {
        return {
            url: await replacer({ url, descriptor }),
            descriptor
        };
    }));
    const url = ret.reduce((prev, { url, descriptor }, index) => {
        descriptor = descriptor || '';
        return (prev +=
            url + ` ${descriptor}${index === ret.length - 1 ? '' : ', '}`);
    }, '');
    return url;
}
// based on https://github.com/sveltejs/svelte/blob/abf11bb02b2afbd3e4cac509a0f70e318c306364/src/compiler/utils/mapped_code.ts#L221
const nullSourceMap = {
    names: [],
    sources: [],
    mappings: '',
    version: 3
};
function combineSourcemaps(filename, sourcemapList) {
    if (sourcemapList.length === 0 ||
        sourcemapList.every((m) => m.sources.length === 0)) {
        return { ...nullSourceMap };
    }
    // We don't declare type here so we can convert/fake/map as RawSourceMap
    let map; //: SourceMap
    let mapIndex = 1;
    const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === undefined;
    if (useArrayInterface) {
        map = remapping__default(sourcemapList, () => null, true);
    }
    else {
        map = remapping__default(sourcemapList[0], function loader(sourcefile) {
            if (sourcefile === filename && sourcemapList[mapIndex]) {
                return sourcemapList[mapIndex++];
            }
            else {
                return { ...nullSourceMap };
            }
        }, true);
    }
    if (!map.file) {
        delete map.file;
    }
    return map;
}
function unique(arr) {
    return Array.from(new Set(arr));
}
function resolveHostname(optionsHost) {
    let host;
    if (optionsHost === undefined ||
        optionsHost === false ||
        optionsHost === 'localhost') {
        // Use a secure default
        host = '127.0.0.1';
    }
    else if (optionsHost === true) {
        // If passed --host in the CLI without arguments
        host = undefined; // undefined typically means 0.0.0.0 or :: (listen on all IPs)
    }
    else {
        host = optionsHost;
    }
    // Set host name to localhost when possible, unless the user explicitly asked for '127.0.0.1'
    const name = (optionsHost !== '127.0.0.1' && host === '127.0.0.1') ||
        host === '0.0.0.0' ||
        host === '::' ||
        host === undefined
        ? 'localhost'
        : host;
    return { host, name };
}
function arraify(target) {
    return Array.isArray(target) ? target : [target];
}
function toUpperCaseDriveLetter(pathName) {
    return pathName.replace(/^\w:/, letter => letter.toUpperCase());
}
const multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//gm;
const singlelineCommentsRE = /\/\/.*/g;

/* eslint no-console: 0 */
const LogLevels = {
    silent: 0,
    error: 1,
    warn: 2,
    info: 3
};
let lastType;
let lastMsg;
let sameCount = 0;
function clearScreen() {
    const repeatCount = process.stdout.rows - 2;
    const blank = repeatCount > 0 ? '\n'.repeat(repeatCount) : '';
    console.log(blank);
    readline__default.cursorTo(process.stdout, 0, 0);
    readline__default.clearScreenDown(process.stdout);
}
function createLogger(level = 'info', options = {}) {
    if (options.customLogger) {
        return options.customLogger;
    }
    const loggedErrors = new WeakSet();
    const { prefix = '[vite]', allowClearScreen = true } = options;
    const thresh = LogLevels[level];
    const clear = allowClearScreen && process.stdout.isTTY && !process.env.CI
        ? clearScreen
        : () => { };
    function output(type, msg, options = {}) {
        if (thresh >= LogLevels[type]) {
            const method = type === 'info' ? 'log' : type;
            const format = () => {
                if (options.timestamp) {
                    const tag = type === 'info'
                        ? chalk__default.cyan.bold(prefix)
                        : type === 'warn'
                            ? chalk__default.yellow.bold(prefix)
                            : chalk__default.red.bold(prefix);
                    return `${chalk__default.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`;
                }
                else {
                    return msg;
                }
            };
            if (options.error) {
                loggedErrors.add(options.error);
            }
            if (type === lastType && msg === lastMsg) {
                sameCount++;
                clear();
                console[method](format(), chalk__default.yellow(`(x${sameCount + 1})`));
            }
            else {
                sameCount = 0;
                lastMsg = msg;
                lastType = type;
                if (options.clear) {
                    clear();
                }
                console[method](format());
            }
        }
    }
    const warnedMessages = new Set();
    const logger = {
        hasWarned: false,
        info(msg, opts) {
            output('info', msg, opts);
        },
        warn(msg, opts) {
            logger.hasWarned = true;
            output('warn', msg, opts);
        },
        warnOnce(msg, opts) {
            if (warnedMessages.has(msg))
                return;
            logger.hasWarned = true;
            output('warn', msg, opts);
            warnedMessages.add(msg);
        },
        error(msg, opts) {
            logger.hasWarned = true;
            output('error', msg, opts);
        },
        clearScreen(type) {
            if (thresh >= LogLevels[type]) {
                clear();
            }
        },
        hasErrorLogged(error) {
            return loggedErrors.has(error);
        }
    };
    return logger;
}
function printServerUrls(hostname, protocol, port, base, info) {
    if (hostname.host === '127.0.0.1') {
        const url = `${protocol}://${hostname.name}:${chalk__default.bold(port)}${base}`;
        info(`  > Local: ${chalk__default.cyan(url)}`);
        if (hostname.name !== '127.0.0.1') {
            info(`  > Network: ${chalk__default.dim('use `--host` to expose')}`);
        }
    }
    else {
        Object.values(os__default.networkInterfaces())
            .flatMap((nInterface) => nInterface !== null && nInterface !== void 0 ? nInterface : [])
            .filter((detail) => detail.family === 'IPv4')
            .map((detail) => {
            const type = detail.address.includes('127.0.0.1')
                ? 'Local:   '
                : 'Network: ';
            const host = detail.address.replace('127.0.0.1', hostname.name);
            const url = `${protocol}://${host}:${chalk__default.bold(port)}${base}`;
            return `  > ${type} ${chalk__default.cyan(url)}`;
        })
            .forEach((msg) => info(msg));
    }
}

const writeColors = {
    [0 /* JS */]: chalk__default.cyan,
    [1 /* CSS */]: chalk__default.magenta,
    [2 /* ASSET */]: chalk__default.green,
    [3 /* HTML */]: chalk__default.blue,
    [4 /* SOURCE_MAP */]: chalk__default.gray
};
function buildReporterPlugin(config) {
    const compress = util.promisify(zlib.gzip);
    const chunkLimit = config.build.chunkSizeWarningLimit;
    function isLarge(code) {
        // bail out on particularly large chunks
        return code.length / 1024 > chunkLimit;
    }
    async function getCompressedSize(code) {
        if (config.build.ssr ||
            !config.build.reportCompressedSize ||
            config.build.brotliSize === false) {
            return '';
        }
        return ` / gzip: ${((await compress(typeof code === 'string' ? code : Buffer.from(code)))
            .length / 1024).toFixed(2)} KiB`;
    }
    function printFileInfo(filePath, content, type, maxLength, compressedSize = '') {
        const outDir = normalizePath(path__default.relative(config.root, path__default.resolve(config.root, config.build.outDir))) + '/';
        const kibs = content.length / 1024;
        const sizeColor = kibs > chunkLimit ? chalk__default.yellow : chalk__default.dim;
        config.logger.info(`${chalk__default.gray(chalk__default.white.dim(outDir))}${writeColors[type](filePath.padEnd(maxLength + 2))} ${sizeColor(`${kibs.toFixed(2)} KiB${compressedSize}`)}`);
    }
    const tty = process.stdout.isTTY && !process.env.CI;
    const shouldLogInfo = LogLevels[config.logLevel || 'info'] >= LogLevels.info;
    let hasTransformed = false;
    let hasRenderedChunk = false;
    let transformedCount = 0;
    let chunkCount = 0;
    const logTransform = throttle((id) => {
        writeLine(`transforming (${transformedCount}) ${chalk__default.dim(path__default.relative(config.root, id))}`);
    });
    return {
        name: 'vite:reporter',
        transform(_, id) {
            transformedCount++;
            if (shouldLogInfo) {
                if (!tty) {
                    if (!hasTransformed) {
                        config.logger.info(`transforming...`);
                    }
                }
                else {
                    if (id.includes(`?`))
                        return;
                    logTransform(id);
                }
                hasTransformed = true;
            }
            return null;
        },
        buildEnd() {
            if (shouldLogInfo) {
                if (tty) {
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);
                }
                config.logger.info(`${chalk__default.green(`✓`)} ${transformedCount} modules transformed.`);
            }
        },
        renderStart() {
            chunkCount = 0;
        },
        renderChunk() {
            chunkCount++;
            if (shouldLogInfo) {
                if (!tty) {
                    if (!hasRenderedChunk) {
                        config.logger.info('rendering chunks...');
                    }
                }
                else {
                    writeLine(`rendering chunks (${chunkCount})...`);
                }
                hasRenderedChunk = true;
            }
            return null;
        },
        generateBundle() {
            if (shouldLogInfo && tty) {
                process.stdout.clearLine(0);
                process.stdout.cursorTo(0);
            }
        },
        async writeBundle(_, output) {
            let hasLargeChunks = false;
            if (shouldLogInfo) {
                let longest = 0;
                for (const file in output) {
                    const l = output[file].fileName.length;
                    if (l > longest)
                        longest = l;
                }
                // large chunks are deferred to be logged at the end so they are more
                // visible.
                const deferredLogs = [];
                await Promise.all(Object.keys(output).map(async (file) => {
                    const chunk = output[file];
                    if (chunk.type === 'chunk') {
                        const log = async () => {
                            printFileInfo(chunk.fileName, chunk.code, 0 /* JS */, longest, await getCompressedSize(chunk.code));
                            if (chunk.map) {
                                printFileInfo(chunk.fileName + '.map', chunk.map.toString(), 4 /* SOURCE_MAP */, longest);
                            }
                        };
                        if (isLarge(chunk.code)) {
                            hasLargeChunks = true;
                            deferredLogs.push(log);
                        }
                        else {
                            await log();
                        }
                    }
                    else if (chunk.source) {
                        const isCSS = chunk.fileName.endsWith('.css');
                        printFileInfo(chunk.fileName, chunk.source, isCSS ? 1 /* CSS */ : 2 /* ASSET */, longest, isCSS ? await getCompressedSize(chunk.source) : undefined);
                    }
                }));
                await Promise.all(deferredLogs.map((l) => l()));
            }
            else {
                hasLargeChunks = Object.keys(output).some((file) => {
                    const chunk = output[file];
                    return chunk.type === 'chunk' && chunk.code.length / 1024 > chunkLimit;
                });
            }
            if (hasLargeChunks &&
                config.build.minify &&
                !config.build.lib &&
                !config.build.ssr) {
                config.logger.warn(chalk__default.yellow(`\n(!) Some chunks are larger than ${chunkLimit} KiB after minification. Consider:\n` +
                    `- Using dynamic import() to code-split the application\n` +
                    `- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/guide/en/#outputmanualchunks\n` +
                    `- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`));
            }
        }
    };
}
function writeLine(output) {
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);
    if (output.length < process.stdout.columns) {
        process.stdout.write(output);
    }
    else {
        process.stdout.write(output.substring(0, process.stdout.columns - 1));
    }
}
function throttle(fn) {
    let timerHandle = null;
    return (...args) => {
        if (timerHandle)
            return;
        fn(...args);
        timerHandle = setTimeout(() => {
            timerHandle = null;
        }, 100);
    };
}

/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime$1() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime$1.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime$1.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime$1.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

var Mime_1 = Mime$1;

var standard = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma","es"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/mrb-consumer+xml":["*xdf"],"application/mrb-publish+xml":["*xdf"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["*xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-error+xml":["xer"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

let Mime = Mime_1;
var lite = new Mime(standard);

const assetUrlRE = /__VITE_ASSET__([a-z\d]{8})__(?:\$_(.*?)__)?/g;
// urls in JS must be quoted as strings, so when replacing them we need
// a different regex
const assetUrlQuotedRE = /"__VITE_ASSET__([a-z\d]{8})__(?:\$_(.*?)__)?"/g;
const rawRE = /(\?|&)raw(?:&|$)/;
const urlRE = /(\?|&)url(?:&|$)/;
const chunkToEmittedAssetsMap = new WeakMap();
const assetCache = new WeakMap();
const assetHashToFilenameMap = new WeakMap();
// save hashes of the files that has been emitted in build watch
const emittedHashMap = new WeakMap();
/**
 * Also supports loading plain strings with import text from './foo.txt?raw'
 */
function assetPlugin(config) {
    // assetHashToFilenameMap initialization in buildStart causes getAssetFilename to return undefined
    assetHashToFilenameMap.set(config, new Map());
    return {
        name: 'vite:asset',
        buildStart() {
            assetCache.set(config, new Map());
            emittedHashMap.set(config, new Set());
        },
        resolveId(id) {
            if (!config.assetsInclude(cleanUrl(id))) {
                return;
            }
            // imports to absolute urls pointing to files in /public
            // will fail to resolve in the main resolver. handle them here.
            const publicFile = checkPublicFile(id, config);
            if (publicFile) {
                return id;
            }
        },
        async load(id) {
            if (id.startsWith('\0')) {
                // Rollup convention, this id should be handled by the
                // plugin that marked it with \0
                return;
            }
            // raw requests, read from disk
            if (rawRE.test(id)) {
                const file = checkPublicFile(id, config) || cleanUrl(id);
                // raw query, read file and return as string
                return `export default ${JSON.stringify(await fs.promises.readFile(file, 'utf-8'))}`;
            }
            if (!config.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {
                return;
            }
            id = id.replace(urlRE, '$1').replace(/[\?&]$/, '');
            const url = await fileToUrl(id, config, this);
            return `export default ${JSON.stringify(url)}`;
        },
        renderChunk(code, chunk) {
            let match;
            let s;
            while ((match = assetUrlQuotedRE.exec(code))) {
                s = s || (s = new MagicString__default(code));
                const [full, hash, postfix = ''] = match;
                // some internal plugins may still need to emit chunks (e.g. worker) so
                // fallback to this.getFileName for that.
                const file = getAssetFilename(hash, config) || this.getFileName(hash);
                registerAssetToChunk(chunk, file);
                const outputFilepath = config.base + file + postfix;
                s.overwrite(match.index, match.index + full.length, JSON.stringify(outputFilepath));
            }
            if (s) {
                return {
                    code: s.toString(),
                    map: config.build.sourcemap ? s.generateMap({ hires: true }) : null
                };
            }
            else {
                return null;
            }
        },
        generateBundle(_, bundle) {
            // do not emit assets for SSR build
            if (config.command === 'build' && config.build.ssr) {
                for (const file in bundle) {
                    if (bundle[file].type === 'asset' &&
                        !file.includes('ssr-manifest.json')) {
                        delete bundle[file];
                    }
                }
            }
        }
    };
}
function registerAssetToChunk(chunk, file) {
    let emitted = chunkToEmittedAssetsMap.get(chunk);
    if (!emitted) {
        emitted = new Set();
        chunkToEmittedAssetsMap.set(chunk, emitted);
    }
    emitted.add(cleanUrl(file));
}
function checkPublicFile(url, { publicDir }) {
    // note if the file is in /public, the resolver would have returned it
    // as-is so it's not going to be a fully resolved path.
    if (!publicDir || !url.startsWith('/')) {
        return;
    }
    const publicFile = path__default.join(publicDir, cleanUrl(url));
    if (fs__default.existsSync(publicFile)) {
        return publicFile;
    }
    else {
        return;
    }
}
function fileToUrl(id, config, ctx) {
    if (config.command === 'serve') {
        return fileToDevUrl(id, config);
    }
    else {
        return fileToBuiltUrl(id, config, ctx);
    }
}
function fileToDevUrl(id, config) {
    let rtn;
    if (checkPublicFile(id, config)) {
        // in public dir, keep the url as-is
        rtn = id;
    }
    else if (id.startsWith(config.root)) {
        // in project root, infer short public path
        rtn = '/' + path__default.posix.relative(config.root, id);
    }
    else {
        // outside of project root, use absolute fs path
        // (this is special handled by the serve static middleware
        rtn = path__default.posix.join(FS_PREFIX + id);
    }
    return config.base + rtn.replace(/^\//, '');
}
function getAssetFilename(hash, config) {
    var _a;
    return (_a = assetHashToFilenameMap.get(config)) === null || _a === void 0 ? void 0 : _a.get(hash);
}
/**
 * converts the source filepath of the asset to the output filename based on the assetFileNames option. \
 * this function imitates the behavior of rollup.js. \
 * https://rollupjs.org/guide/en/#outputassetfilenames
 *
 * @example
 * ```ts
 * const content = Buffer.from('text');
 * const fileName = assetFileNamesToFileName(
 *   'assets/[name].[hash][extname]',
 *   '/path/to/file.txt',
 *   getAssetHash(content),
 *   content
 * )
 * // fileName: 'assets/file.982d9e3e.txt'
 * ```
 *
 * @param assetFileNames filename pattern. e.g. `'assets/[name].[hash][extname]'`
 * @param file filepath of the asset
 * @param contentHash hash of the asset. used for `'[hash]'` placeholder
 * @param content content of the asset. passed to `assetFileNames` if `assetFileNames` is a function
 * @returns output filename
 */
function assetFileNamesToFileName(assetFileNames, file, contentHash, content) {
    const basename = path__default.basename(file);
    // placeholders for `assetFileNames`
    // `hash` is slightly different from the rollup's one
    const extname = path__default.extname(basename);
    const ext = extname.substr(1);
    const name = basename.slice(0, -extname.length);
    const hash = contentHash;
    if (typeof assetFileNames === 'function') {
        assetFileNames = assetFileNames({
            name: file,
            source: content,
            type: 'asset'
        });
        if (typeof assetFileNames !== 'string') {
            throw new TypeError('assetFileNames must return a string');
        }
    }
    else if (typeof assetFileNames !== 'string') {
        throw new TypeError('assetFileNames must be a string or a function');
    }
    const fileName = assetFileNames.replace(/\[\w+\]/g, (placeholder) => {
        switch (placeholder) {
            case '[ext]':
                return ext;
            case '[extname]':
                return extname;
            case '[hash]':
                return hash;
            case '[name]':
                return name;
        }
        throw new Error(`invalid placeholder ${placeholder} in assetFileNames "${assetFileNames}"`);
    });
    return fileName;
}
/**
 * Register an asset to be emitted as part of the bundle (if necessary)
 * and returns the resolved public URL
 */
async function fileToBuiltUrl(id, config, pluginContext, skipPublicCheck = false) {
    var _a, _b, _c;
    if (!skipPublicCheck && checkPublicFile(id, config)) {
        return config.base + id.slice(1);
    }
    const cache = assetCache.get(config);
    const cached = cache.get(id);
    if (cached) {
        return cached;
    }
    const file = cleanUrl(id);
    const content = await fs.promises.readFile(file);
    let url$1;
    if (config.build.lib ||
        (!file.endsWith('.svg') &&
            content.length < Number(config.build.assetsInlineLimit))) {
        // base64 inlined as a string
        url$1 = `data:${lite.getType(file)};base64,${content.toString('base64')}`;
    }
    else {
        // emit as asset
        // rollup supports `import.meta.ROLLUP_FILE_URL_*`, but it generates code
        // that uses runtime url sniffing and it can be verbose when targeting
        // non-module format. It also fails to cascade the asset content change
        // into the chunk's hash, so we have to do our own content hashing here.
        // https://bundlers.tooling.report/hashing/asset-cascade/
        // https://github.com/rollup/rollup/issues/3415
        const map = assetHashToFilenameMap.get(config);
        const contentHash = getAssetHash(content);
        const { search, hash } = url.parse(id);
        const postfix = (search || '') + (hash || '');
        const output = (_b = (_a = config.build) === null || _a === void 0 ? void 0 : _a.rollupOptions) === null || _b === void 0 ? void 0 : _b.output;
        const assetFileNames = (_c = (output && !Array.isArray(output) ? output.assetFileNames : undefined)) !== null && _c !== void 0 ? _c : 
        // defaults to '<assetsDir>/[name].[hash][extname]'
        // slightly different from rollup's one ('assets/[name]-[hash][extname]')
        path__default.posix.join(config.build.assetsDir, '[name].[hash][extname]');
        const fileName = assetFileNamesToFileName(assetFileNames, file, contentHash, content);
        if (!map.has(contentHash)) {
            map.set(contentHash, fileName);
        }
        const emittedSet = emittedHashMap.get(config);
        if (!emittedSet.has(contentHash)) {
            const name = normalizePath(path__default.relative(config.root, file));
            pluginContext.emitFile({
                name,
                fileName,
                type: 'asset',
                source: content
            });
            emittedSet.add(contentHash);
        }
        url$1 = `__VITE_ASSET__${contentHash}__${postfix ? `$_${postfix}__` : ``}`;
    }
    cache.set(id, url$1);
    return url$1;
}
function getAssetHash(content) {
    return crypto.createHash('sha256').update(content).digest('hex').slice(0, 8);
}
async function urlToBuiltUrl(url, importer, config, pluginContext) {
    if (checkPublicFile(url, config)) {
        return config.base + url.slice(1);
    }
    const file = url.startsWith('/')
        ? path__default.join(config.root, url)
        : path__default.join(path__default.dirname(importer), url);
    return fileToBuiltUrl(file, config, pluginContext, 
    // skip public check since we just did it above
    true);
}

const cssLangs = `\\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\\?)`;
const cssLangRE = new RegExp(cssLangs);
const cssModuleRE = new RegExp(`\\.module${cssLangs}`);
const directRequestRE = /(\?|&)direct\b/;
const commonjsProxyRE = /\?commonjs-proxy/;
const inlineRE = /(\?|&)inline\b/;
const usedRE = /(\?|&)used\b/;
const isCSSRequest = (request) => cssLangRE.test(request);
const isDirectCSSRequest = (request) => cssLangRE.test(request) && directRequestRE.test(request);
const isDirectRequest = (request) => directRequestRE.test(request);
const cssModulesCache = new WeakMap();
const chunkToEmittedCssFileMap = new WeakMap();
const removedPureCssFilesCache = new WeakMap();
const postcssConfigCache = new WeakMap();
/**
 * Plugin applied before user plugins
 */
function cssPlugin(config) {
    let server;
    let moduleCache;
    const resolveUrl = config.createResolver({
        preferRelative: true,
        tryIndex: false,
        extensions: []
    });
    const atImportResolvers = createCSSResolvers(config);
    return {
        name: 'vite:css',
        configureServer(_server) {
            server = _server;
        },
        buildStart() {
            // Ensure a new cache for every build (i.e. rebuilding in watch mode)
            moduleCache = new Map();
            cssModulesCache.set(config, moduleCache);
            removedPureCssFilesCache.set(config, new Map());
        },
        async transform(raw, id) {
            if (!isCSSRequest(id) || commonjsProxyRE.test(id)) {
                return;
            }
            const urlReplacer = async (url, importer) => {
                if (checkPublicFile(url, config)) {
                    return config.base + url.slice(1);
                }
                const resolved = await resolveUrl(url, importer);
                if (resolved) {
                    return fileToUrl(resolved, config, this);
                }
                return url;
            };
            const { code: css, modules, deps } = await compileCSS(id, raw, config, urlReplacer, atImportResolvers, server);
            if (modules) {
                moduleCache.set(id, modules);
            }
            // track deps for build watch mode
            if (config.command === 'build' && config.build.watch && deps) {
                for (const file of deps) {
                    this.addWatchFile(file);
                }
            }
            // dev
            if (server) {
                // server only logic for handling CSS @import dependency hmr
                const { moduleGraph } = server;
                const thisModule = moduleGraph.getModuleById(id);
                if (thisModule) {
                    // CSS modules cannot self-accept since it exports values
                    const isSelfAccepting = !modules;
                    if (deps) {
                        // record deps in the module graph so edits to @import css can trigger
                        // main import to hot update
                        const depModules = new Set();
                        for (const file of deps) {
                            depModules.add(isCSSRequest(file)
                                ? moduleGraph.createFileOnlyEntry(file)
                                : await moduleGraph.ensureEntryFromUrl((await fileToUrl(file, config, this)).replace(config.base, '/')));
                        }
                        moduleGraph.updateModuleInfo(thisModule, depModules, 
                        // The root CSS proxy module is self-accepting and should not
                        // have an explicit accept list
                        new Set(), isSelfAccepting);
                        for (const file of deps) {
                            this.addWatchFile(file);
                        }
                    }
                    else {
                        thisModule.isSelfAccepting = isSelfAccepting;
                    }
                }
            }
            return {
                code: css,
                // TODO CSS source map
                map: { mappings: '' }
            };
        }
    };
}
/**
 * Plugin applied after user plugins
 */
function cssPostPlugin(config) {
    // styles initialization in buildStart causes a styling loss in watch
    const styles = new Map();
    let pureCssChunks;
    // when there are multiple rollup outputs and extracting CSS, only emit once,
    // since output formats have no effect on the generated CSS.
    let outputToExtractedCSSMap;
    let hasEmitted = false;
    return {
        name: 'vite:css-post',
        buildStart() {
            // Ensure new caches for every build (i.e. rebuilding in watch mode)
            pureCssChunks = new Set();
            outputToExtractedCSSMap = new Map();
            hasEmitted = false;
        },
        async transform(css, id, ssr) {
            if (!isCSSRequest(id) || commonjsProxyRE.test(id)) {
                return;
            }
            const inlined = inlineRE.test(id);
            const modules = cssModulesCache.get(config).get(id);
            const modulesCode = modules && pluginutils.dataToEsm(modules, { namedExports: true, preferConst: true });
            if (config.command === 'serve') {
                if (isDirectCSSRequest(id)) {
                    return css;
                }
                else {
                    // server only
                    if (ssr) {
                        return modulesCode || `export default ${JSON.stringify(css)}`;
                    }
                    if (inlined) {
                        return `export default ${JSON.stringify(css)}`;
                    }
                    return [
                        `import { updateStyle, removeStyle } from ${JSON.stringify(path__default.posix.join(config.base, CLIENT_PUBLIC_PATH))}`,
                        `const id = ${JSON.stringify(id)}`,
                        `const css = ${JSON.stringify(css)}`,
                        `updateStyle(id, css)`,
                        // css modules exports change on edit so it can't self accept
                        `${modulesCode || `import.meta.hot.accept()\nexport default css`}`,
                        `import.meta.hot.prune(() => removeStyle(id))`
                    ].join('\n');
                }
            }
            // build CSS handling ----------------------------------------------------
            // record css
            if (!inlined) {
                styles.set(id, css);
            }
            else {
                css = await minifyCSS(css, config);
            }
            return {
                code: modulesCode ||
                    (usedRE.test(id)
                        ? `export default ${JSON.stringify(css)}`
                        : `export default ''`),
                map: { mappings: '' },
                // avoid the css module from being tree-shaken so that we can retrieve
                // it in renderChunk()
                moduleSideEffects: inlined ? false : 'no-treeshake'
            };
        },
        async renderChunk(code, chunk, opts) {
            let chunkCSS = '';
            let isPureCssChunk = true;
            const ids = Object.keys(chunk.modules);
            for (const id of ids) {
                if (!isCSSRequest(id) ||
                    cssModuleRE.test(id) ||
                    commonjsProxyRE.test(id)) {
                    isPureCssChunk = false;
                }
                if (styles.has(id)) {
                    chunkCSS += styles.get(id);
                }
            }
            if (!chunkCSS) {
                return null;
            }
            // resolve asset URL placeholders to their built file URLs and perform
            // minification if necessary
            const processChunkCSS = async (css, { inlined, minify }) => {
                // replace asset url references with resolved url.
                const isRelativeBase = config.base === '' || config.base.startsWith('.');
                css = css.replace(assetUrlRE, (_, fileHash, postfix = '') => {
                    const filename = getAssetFilename(fileHash, config) + postfix;
                    registerAssetToChunk(chunk, filename);
                    if (!isRelativeBase || inlined) {
                        // absolute base or relative base but inlined (injected as style tag into
                        // index.html) use the base as-is
                        return config.base + filename;
                    }
                    else {
                        // relative base + extracted CSS - asset file will be in the same dir
                        return `./${path__default.posix.basename(filename)}`;
                    }
                });
                // only external @imports should exist at this point - and they need to
                // be hoisted to the top of the CSS chunk per spec (#1845)
                if (css.includes('@import')) {
                    css = await hoistAtImports(css);
                }
                if (minify && config.build.minify) {
                    css = await minifyCSS(css, config);
                }
                return css;
            };
            if (config.build.cssCodeSplit) {
                if (isPureCssChunk) {
                    // this is a shared CSS-only chunk that is empty.
                    pureCssChunks.add(chunk.fileName);
                }
                if (opts.format === 'es' || opts.format === 'cjs') {
                    chunkCSS = await processChunkCSS(chunkCSS, {
                        inlined: false,
                        minify: true
                    });
                    // emit corresponding css file
                    const fileHandle = this.emitFile({
                        name: chunk.name + '.css',
                        type: 'asset',
                        source: chunkCSS
                    });
                    chunkToEmittedCssFileMap.set(chunk, new Set([this.getFileName(fileHandle)]));
                }
                else if (!config.build.ssr) {
                    // legacy build, inline css
                    chunkCSS = await processChunkCSS(chunkCSS, {
                        inlined: true,
                        minify: true
                    });
                    const style = `__vite_style__`;
                    const injectCode = `var ${style} = document.createElement('style');` +
                        `${style}.innerHTML = ${JSON.stringify(chunkCSS)};` +
                        `document.head.appendChild(${style});`;
                    if (config.build.sourcemap) {
                        const s = new MagicString__default(code);
                        s.prepend(injectCode);
                        return {
                            code: s.toString(),
                            map: s.generateMap({ hires: true })
                        };
                    }
                    else {
                        return { code: injectCode + code };
                    }
                }
            }
            else {
                // non-split extracted CSS will be minified together
                chunkCSS = await processChunkCSS(chunkCSS, {
                    inlined: false,
                    minify: false
                });
                outputToExtractedCSSMap.set(opts, (outputToExtractedCSSMap.get(opts) || '') + chunkCSS);
            }
            return null;
        },
        async generateBundle(opts, bundle) {
            // remove empty css chunks and their imports
            if (pureCssChunks.size) {
                const emptyChunkFiles = [...pureCssChunks]
                    .map((file) => path__default.basename(file))
                    .join('|')
                    .replace(/\./g, '\\.');
                const emptyChunkRE = new RegExp(opts.format === 'es'
                    ? `\\bimport\\s*"[^"]*(?:${emptyChunkFiles})";\n?`
                    : `\\brequire\\(\\s*"[^"]*(?:${emptyChunkFiles})"\\);\n?`, 'g');
                for (const file in bundle) {
                    const chunk = bundle[file];
                    if (chunk.type === 'chunk') {
                        // remove pure css chunk from other chunk's imports,
                        // and also register the emitted CSS files under the importer
                        // chunks instead.
                        chunk.imports = chunk.imports.filter((file) => {
                            if (pureCssChunks.has(file)) {
                                const css = chunkToEmittedCssFileMap.get(bundle[file]);
                                if (css) {
                                    let existing = chunkToEmittedCssFileMap.get(chunk);
                                    if (!existing) {
                                        existing = new Set();
                                    }
                                    css.forEach((file) => existing.add(file));
                                    chunkToEmittedCssFileMap.set(chunk, existing);
                                }
                                return false;
                            }
                            return true;
                        });
                        chunk.code = chunk.code.replace(emptyChunkRE, 
                        // remove css import while preserving source map location
                        (m) => `/* empty css ${''.padEnd(m.length - 15)}*/`);
                    }
                }
                const removedPureCssFiles = removedPureCssFilesCache.get(config);
                pureCssChunks.forEach((fileName) => {
                    removedPureCssFiles.set(fileName, bundle[fileName]);
                    delete bundle[fileName];
                });
            }
            let extractedCss = outputToExtractedCSSMap.get(opts);
            if (extractedCss && !hasEmitted) {
                hasEmitted = true;
                // minify css
                if (config.build.minify) {
                    extractedCss = await minifyCSS(extractedCss, config);
                }
                this.emitFile({
                    name: 'style.css',
                    type: 'asset',
                    source: extractedCss
                });
            }
        }
    };
}
function createCSSResolvers(config) {
    let cssResolve;
    let sassResolve;
    let lessResolve;
    return {
        get css() {
            return (cssResolve ||
                (cssResolve = config.createResolver({
                    extensions: ['.css'],
                    mainFields: ['style'],
                    tryIndex: false,
                    preferRelative: true
                })));
        },
        get sass() {
            return (sassResolve ||
                (sassResolve = config.createResolver({
                    extensions: ['.scss', '.sass', '.css'],
                    mainFields: ['sass', 'style'],
                    tryIndex: true,
                    tryPrefix: '_',
                    preferRelative: true
                })));
        },
        get less() {
            return (lessResolve ||
                (lessResolve = config.createResolver({
                    extensions: ['.less', '.css'],
                    mainFields: ['less', 'style'],
                    tryIndex: false,
                    preferRelative: true
                })));
        }
    };
}
function getCssResolversKeys(resolvers) {
    return Object.keys(resolvers);
}
async function compileCSS(id, code, config, urlReplacer, atImportResolvers, server) {
    var _a;
    const { modules: modulesOptions, preprocessorOptions } = config.css || {};
    const isModule = modulesOptions !== false && cssModuleRE.test(id);
    // although at serve time it can work without processing, we do need to
    // crawl them in order to register watch dependencies.
    const needInlineImport = code.includes('@import');
    const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
    const postcssConfig = await resolvePostcssConfig(config);
    const lang = (_a = id.match(cssLangRE)) === null || _a === void 0 ? void 0 : _a[1];
    // 1. plain css that needs no processing
    if (lang === 'css' &&
        !postcssConfig &&
        !isModule &&
        !needInlineImport &&
        !hasUrl) {
        return { code };
    }
    let map;
    let modules;
    const deps = new Set();
    // 2. pre-processors: sass etc.
    if (isPreProcessor(lang)) {
        const preProcessor = preProcessors[lang];
        let opts = (preprocessorOptions && preprocessorOptions[lang]) || {};
        // support @import from node dependencies by default
        switch (lang) {
            case "scss" /* scss */:
            case "sass" /* sass */:
                opts = {
                    includePaths: ['node_modules'],
                    alias: config.resolve.alias,
                    ...opts
                };
                break;
            case "less" /* less */:
            case "styl" /* styl */:
            case "stylus" /* stylus */:
                opts = {
                    paths: ['node_modules'],
                    alias: config.resolve.alias,
                    ...opts
                };
        }
        // important: set this for relative import resolving
        opts.filename = cleanUrl(id);
        const preprocessResult = await preProcessor(code, config.root, opts, atImportResolvers);
        if (preprocessResult.errors.length) {
            throw preprocessResult.errors[0];
        }
        code = preprocessResult.code;
        map = preprocessResult.map;
        if (preprocessResult.deps) {
            preprocessResult.deps.forEach((dep) => {
                // sometimes sass registers the file itself as a dep
                if (normalizePath(dep) !== normalizePath(opts.filename)) {
                    deps.add(dep);
                }
            });
        }
    }
    // 3. postcss
    const postcssOptions = (postcssConfig && postcssConfig.options) || {};
    const postcssPlugins = postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : [];
    if (needInlineImport) {
        postcssPlugins.unshift((await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('postcss-import')); })).default({
            async resolve(id, basedir) {
                const resolved = await atImportResolvers.css(id, path__default.join(basedir, '*'));
                if (resolved) {
                    return path__default.resolve(resolved);
                }
                return id;
            }
        }));
    }
    postcssPlugins.push(UrlRewritePostcssPlugin({
        replacer: urlReplacer
    }));
    if (isModule) {
        postcssPlugins.unshift((await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('postcss-modules')); })).default({
            ...modulesOptions,
            getJSON(cssFileName, _modules, outputFileName) {
                modules = _modules;
                if (modulesOptions && typeof modulesOptions.getJSON === 'function') {
                    modulesOptions.getJSON(cssFileName, _modules, outputFileName);
                }
            },
            async resolve(id) {
                for (const key of getCssResolversKeys(atImportResolvers)) {
                    const resolved = await atImportResolvers[key](id);
                    if (resolved) {
                        return path__default.resolve(resolved);
                    }
                }
                return id;
            }
        }));
    }
    if (!postcssPlugins.length) {
        return {
            code,
            map
        };
    }
    // postcss is an unbundled dep and should be lazy imported
    const postcssResult = await (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('postcss')); }))
        .default(postcssPlugins)
        .process(code, {
        ...postcssOptions,
        to: id,
        from: id,
        map: {
            inline: false,
            annotation: false,
            prev: map
        }
    });
    // record CSS dependencies from @imports
    for (const message of postcssResult.messages) {
        if (message.type === 'dependency') {
            deps.add(message.file);
        }
        else if (message.type === 'dir-dependency') {
            // https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#3-dependencies
            const { dir, glob: globPattern = '**' } = message;
            const pattern = normalizePath(path__default.resolve(path__default.dirname(id), dir)) + `/` + globPattern;
            const files = glob__default.sync(pattern, {
                ignore: ['**/node_modules/**']
            });
            for (let i = 0; i < files.length; i++) {
                deps.add(files[i]);
            }
            if (server) {
                // register glob importers so we can trigger updates on file add/remove
                if (!(id in server._globImporters)) {
                    server._globImporters[id] = {
                        module: server.moduleGraph.getModuleById(id),
                        importGlobs: []
                    };
                }
                server._globImporters[id].importGlobs.push({
                    base: config.root,
                    pattern
                });
            }
        }
        else if (message.type === 'warning') {
            let msg = `[vite:css] ${message.text}`;
            if (message.line && message.column) {
                msg += `\n${generateCodeFrame(code, {
                    line: message.line,
                    column: message.column
                })}`;
            }
            config.logger.warn(chalk__default.yellow(msg));
        }
    }
    return {
        ast: postcssResult,
        code: postcssResult.css,
        map: postcssResult.map,
        modules,
        deps
    };
}
async function resolvePostcssConfig(config) {
    var _a;
    let result = postcssConfigCache.get(config);
    if (result !== undefined) {
        return result;
    }
    // inline postcss config via vite config
    const inlineOptions = (_a = config.css) === null || _a === void 0 ? void 0 : _a.postcss;
    if (isObject(inlineOptions)) {
        const options = { ...inlineOptions };
        delete options.plugins;
        result = {
            options,
            plugins: inlineOptions.plugins || []
        };
    }
    else {
        try {
            const searchPath = typeof inlineOptions === 'string' ? inlineOptions : config.root;
            // @ts-ignore
            result = await postcssrc__default({}, searchPath);
        }
        catch (e) {
            if (!/No PostCSS Config found/.test(e.message)) {
                throw e;
            }
            result = null;
        }
    }
    postcssConfigCache.set(config, result);
    return result;
}
// https://drafts.csswg.org/css-syntax-3/#identifier-code-point
const cssUrlRE = /(?<=^|[^\w\-\u0080-\uffff])url\(\s*('[^']+'|"[^"]+"|[^'")]+)\s*\)/;
const cssImageSetRE = /image-set\(([^)]+)\)/;
const UrlRewritePostcssPlugin = (opts) => {
    if (!opts) {
        throw new Error('base or replace is required');
    }
    return {
        postcssPlugin: 'vite-url-rewrite',
        Once(root) {
            const promises = [];
            root.walkDecls((declaration) => {
                const isCssUrl = cssUrlRE.test(declaration.value);
                const isCssImageSet = cssImageSetRE.test(declaration.value);
                if (isCssUrl || isCssImageSet) {
                    const replacerForDeclaration = (rawUrl) => {
                        var _a;
                        const importer = (_a = declaration.source) === null || _a === void 0 ? void 0 : _a.input.file;
                        return opts.replacer(rawUrl, importer);
                    };
                    const rewriterToUse = isCssUrl ? rewriteCssUrls : rewriteCssImageSet;
                    promises.push(rewriterToUse(declaration.value, replacerForDeclaration).then((url) => {
                        declaration.value = url;
                    }));
                }
            });
            if (promises.length) {
                return Promise.all(promises);
            }
        }
    };
};
UrlRewritePostcssPlugin.postcss = true;
function rewriteCssUrls(css, replacer) {
    return asyncReplace(css, cssUrlRE, async (match) => {
        const [matched, rawUrl] = match;
        return await doUrlReplace(rawUrl, matched, replacer);
    });
}
function rewriteCssImageSet(css, replacer) {
    return asyncReplace(css, cssImageSetRE, async (match) => {
        const [matched, rawUrl] = match;
        const url = await processSrcSet(rawUrl, ({ url }) => doUrlReplace(url, matched, replacer));
        return `image-set(${url})`;
    });
}
async function doUrlReplace(rawUrl, matched, replacer) {
    let wrap = '';
    const first = rawUrl[0];
    if (first === `"` || first === `'`) {
        wrap = first;
        rawUrl = rawUrl.slice(1, -1);
    }
    if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith('#')) {
        return matched;
    }
    return `url(${wrap}${await replacer(rawUrl)}${wrap})`;
}
async function minifyCSS(css, config) {
    const { code, warnings } = await esbuild.transform(css, {
        loader: 'css',
        minify: true,
        target: config.build.target || undefined
    });
    if (warnings.length) {
        const msgs = await esbuild.formatMessages(warnings, { kind: 'warning' });
        config.logger.warn(chalk__default.yellow(`warnings when minifying css:\n${msgs.join('\n')}`));
    }
    return code;
}
// #1845
// CSS @import can only appear at top of the file. We need to hoist all @import
// to top when multiple files are concatenated.
async function hoistAtImports(css) {
    const postcss = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('postcss')); });
    return (await postcss.default([AtImportHoistPlugin]).process(css)).css;
}
const AtImportHoistPlugin = () => {
    return {
        postcssPlugin: 'vite-hoist-at-imports',
        Once(root) {
            const imports = [];
            root.walkAtRules((rule) => {
                if (rule.name === 'import') {
                    // record in reverse so that can simply prepend to preserve order
                    imports.unshift(rule);
                }
            });
            imports.forEach((i) => root.prepend(i));
        }
    };
};
AtImportHoistPlugin.postcss = true;
const loadedPreprocessors = {};
function loadPreprocessor(lang, root) {
    var _a, _b;
    if (lang in loadedPreprocessors) {
        return loadedPreprocessors[lang];
    }
    try {
        // Search for the preprocessor in the root directory first, and fall back
        // to the default require paths.
        const fallbackPaths = ((_b = (_a = require.resolve).paths) === null || _b === void 0 ? void 0 : _b.call(_a, lang)) || [];
        const resolved = require.resolve(lang, { paths: [root, ...fallbackPaths] });
        return (loadedPreprocessors[lang] = require(resolved));
    }
    catch (e) {
        throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it?`);
    }
}
// .scss/.sass processor
const scss = async (source, root, options, resolvers) => {
    const render = loadPreprocessor("sass" /* sass */, root).render;
    const internalImporter = (url, importer, done) => {
        resolvers.sass(url, importer).then((resolved) => {
            if (resolved) {
                rebaseUrls(resolved, options.filename, options.alias)
                    .then(done)
                    .catch(done);
            }
            else {
                done(null);
            }
        });
    };
    const importer = [internalImporter];
    if (options.importer) {
        Array.isArray(options.importer)
            ? importer.push(...options.importer)
            : importer.push(options.importer);
    }
    const finalOptions = {
        ...options,
        data: await getSource(source, options.filename, options.additionalData),
        file: options.filename,
        outFile: options.filename,
        importer
    };
    try {
        const result = await new Promise((resolve, reject) => {
            render(finalOptions, (err, res) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
        const deps = result.stats.includedFiles;
        return {
            code: result.css.toString(),
            errors: [],
            deps
        };
    }
    catch (e) {
        // normalize SASS error
        e.id = e.file;
        e.frame = e.formatted;
        return { code: '', errors: [e], deps: [] };
    }
};
const sass = (source, root, options, aliasResolver) => scss(source, root, {
    ...options,
    indentedSyntax: true
}, aliasResolver);
/**
 * relative url() inside \@imported sass and less files must be rebased to use
 * root file as base.
 */
async function rebaseUrls(file, rootFile, alias) {
    file = path__default.resolve(file); // ensure os-specific flashes
    // in the same dir, no need to rebase
    const fileDir = path__default.dirname(file);
    const rootDir = path__default.dirname(rootFile);
    if (fileDir === rootDir) {
        return { file };
    }
    // no url()
    const content = fs__default.readFileSync(file, 'utf-8');
    if (!cssUrlRE.test(content)) {
        return { file };
    }
    const rebased = await rewriteCssUrls(content, (url) => {
        if (url.startsWith('/'))
            return url;
        // match alias, no need to rewrite
        for (const { find } of alias) {
            const matches = typeof find === 'string' ? url.startsWith(find) : find.test(url);
            if (matches) {
                return url;
            }
        }
        const absolute = path__default.resolve(fileDir, url);
        const relative = path__default.relative(rootDir, absolute);
        return normalizePath(relative);
    });
    return {
        file,
        contents: rebased
    };
}
// .less
const less = async (source, root, options, resolvers) => {
    const nodeLess = loadPreprocessor("less" /* less */, root);
    const viteResolverPlugin = createViteLessPlugin(nodeLess, options.filename, options.alias, resolvers);
    source = await getSource(source, options.filename, options.additionalData);
    let result;
    try {
        result = await nodeLess.render(source, {
            ...options,
            plugins: [viteResolverPlugin, ...(options.plugins || [])]
        });
    }
    catch (e) {
        const error = e;
        // normalize error info
        const normalizedError = new Error(error.message || error.type);
        normalizedError.loc = {
            file: error.filename || options.filename,
            line: error.line,
            column: error.column
        };
        return { code: '', errors: [normalizedError], deps: [] };
    }
    return {
        code: result.css.toString(),
        deps: result.imports,
        errors: []
    };
};
/**
 * Less manager, lazy initialized
 */
let ViteLessManager;
function createViteLessPlugin(less, rootFile, alias, resolvers) {
    if (!ViteLessManager) {
        ViteLessManager = class ViteManager extends less.FileManager {
            constructor(rootFile, resolvers, alias) {
                super();
                this.rootFile = rootFile;
                this.resolvers = resolvers;
                this.alias = alias;
            }
            supports() {
                return true;
            }
            supportsSync() {
                return false;
            }
            async loadFile(filename, dir, opts, env) {
                const resolved = await this.resolvers.less(filename, path__default.join(dir, '*'));
                if (resolved) {
                    const result = await rebaseUrls(resolved, this.rootFile, this.alias);
                    let contents;
                    if (result && 'contents' in result) {
                        contents = result.contents;
                    }
                    else {
                        contents = fs__default.readFileSync(resolved, 'utf-8');
                    }
                    return {
                        filename: path__default.resolve(resolved),
                        contents
                    };
                }
                else {
                    return super.loadFile(filename, dir, opts, env);
                }
            }
        };
    }
    return {
        install(_, pluginManager) {
            pluginManager.addFileManager(new ViteLessManager(rootFile, resolvers, alias));
        },
        minVersion: [3, 0, 0]
    };
}
// .styl
const styl = async (source, root, options) => {
    var _a;
    const nodeStylus = loadPreprocessor("stylus" /* stylus */, root);
    // Get source with preprocessor options.additionalData. Make sure a new line separator
    // is added to avoid any render error, as added stylus content may not have semi-colon separators
    source = await getSource(source, options.filename, options.additionalData, '\n');
    // Get preprocessor options.imports dependencies as stylus
    // does not return them with its builtin `.deps()` method
    const importsDeps = ((_a = options.imports) !== null && _a !== void 0 ? _a : []).map((dep) => path__default.resolve(dep));
    try {
        const ref = nodeStylus(source, options);
        // if (map) ref.set('sourcemap', { inline: false, comment: false })
        const result = ref.render();
        // Concat imports deps with computed deps
        const deps = [...ref.deps(), ...importsDeps];
        return { code: result, errors: [], deps };
    }
    catch (e) {
        return { code: '', errors: [e], deps: [] };
    }
};
function getSource(source, filename, additionalData, sep = '') {
    if (!additionalData)
        return source;
    if (typeof additionalData === 'function') {
        return additionalData(source, filename);
    }
    return additionalData + sep + source;
}
const preProcessors = Object.freeze({
    ["less" /* less */]: less,
    ["sass" /* sass */]: sass,
    ["scss" /* scss */]: scss,
    ["styl" /* styl */]: styl,
    ["stylus" /* stylus */]: styl
});
function isPreProcessor(lang) {
    return lang && lang in preProcessors;
}

async function transformImportGlob(source, pos, importer, importIndex, root, normalizeUrl, preload = true) {
    const isEager = source.slice(pos, pos + 21) === 'import.meta.globEager';
    const isEagerDefault = isEager && source.slice(pos + 21, pos + 28) === 'Default';
    const err = (msg) => {
        const e = new Error(`Invalid glob import syntax: ${msg}`);
        e.pos = pos;
        return e;
    };
    importer = cleanUrl(importer);
    const importerBasename = path__default.basename(importer);
    let [pattern, endIndex] = lexGlobPattern(source, pos);
    if (!pattern.startsWith('.') && !pattern.startsWith('/')) {
        throw err(`pattern must start with "." or "/" (relative to project root)`);
    }
    let base;
    let parentDepth = 0;
    const isAbsolute = pattern.startsWith('/');
    if (isAbsolute) {
        base = path__default.resolve(root);
        pattern = pattern.slice(1);
    }
    else {
        base = path__default.dirname(importer);
        while (pattern.startsWith('../')) {
            pattern = pattern.slice(3);
            base = path__default.resolve(base, '../');
            parentDepth++;
        }
        if (pattern.startsWith('./')) {
            pattern = pattern.slice(2);
        }
    }
    const files = glob__default.sync(pattern, {
        cwd: base,
        ignore: ['**/node_modules/**']
    });
    const imports = [];
    let importsString = ``;
    let entries = ``;
    for (let i = 0; i < files.length; i++) {
        // skip importer itself
        if (files[i] === importerBasename)
            continue;
        const file = isAbsolute
            ? `/${files[i]}`
            : parentDepth
                ? `${'../'.repeat(parentDepth)}${files[i]}`
                : `./${files[i]}`;
        let importee = file;
        if (normalizeUrl) {
            [importee] = await normalizeUrl(file, pos);
        }
        imports.push(importee);
        const identifier = `__glob_${importIndex}_${i}`;
        if (isEager) {
            importsString += `import ${isEagerDefault ? `` : `* as `}${identifier} from ${JSON.stringify(importee)};`;
            entries += ` ${JSON.stringify(file)}: ${identifier},`;
        }
        else {
            let imp = `import(${JSON.stringify(importee)})`;
            if (!normalizeUrl && preload) {
                imp =
                    `(${isModernFlag}` +
                        `? ${preloadMethod}(()=>${imp},"${preloadMarker}")` +
                        `: ${imp})`;
            }
            entries += ` ${JSON.stringify(file)}: () => ${imp},`;
        }
    }
    return {
        imports,
        importsString,
        exp: `{${entries}}`,
        endIndex,
        isEager,
        pattern,
        base
    };
}
function lexGlobPattern(code, pos) {
    let state = 0 /* inCall */;
    let pattern = '';
    let i = code.indexOf(`(`, pos) + 1;
    outer: for (; i < code.length; i++) {
        const char = code.charAt(i);
        switch (state) {
            case 0 /* inCall */:
                if (char === `'`) {
                    state = 1 /* inSingleQuoteString */;
                }
                else if (char === `"`) {
                    state = 2 /* inDoubleQuoteString */;
                }
                else if (char === '`') {
                    state = 3 /* inTemplateString */;
                }
                else if (/\s/.test(char)) {
                    continue;
                }
                else {
                    error$1(i);
                }
                break;
            case 1 /* inSingleQuoteString */:
                if (char === `'`) {
                    break outer;
                }
                else {
                    pattern += char;
                }
                break;
            case 2 /* inDoubleQuoteString */:
                if (char === `"`) {
                    break outer;
                }
                else {
                    pattern += char;
                }
                break;
            case 3 /* inTemplateString */:
                if (char === '`') {
                    break outer;
                }
                else {
                    pattern += char;
                }
                break;
            default:
                throw new Error('unknown import.meta.glob lexer state');
        }
    }
    return [pattern, code.indexOf(`)`, i) + 1];
}
function error$1(pos) {
    const err = new Error(`import.meta.glob() can only accept string literals.`);
    err.pos = pos;
    throw err;
}

/**
 * A flag for injected helpers. This flag will be set to `false` if the output
 * target is not native es - so that injected helper logic can be conditionally
 * dropped.
 */
const isModernFlag = `__VITE_IS_MODERN__`;
const preloadMethod = `__vitePreload`;
const preloadMarker = `__VITE_PRELOAD__`;
const preloadBaseMarker = `__VITE_PRELOAD_BASE__`;
const preloadHelperId = 'vite/preload-helper';
const preloadMarkerRE = new RegExp(`"${preloadMarker}"`, 'g');
/**
 * Helper for preloading CSS and direct imports of async chunks in parallel to
 * the async chunk itself.
 */
function detectScriptRel() {
    // @ts-ignore
    const relList = document.createElement('link').relList;
    // @ts-ignore
    return relList && relList.supports && relList.supports('modulepreload')
        ? 'modulepreload'
        : 'preload';
}
function preload(baseModule, deps) {
    // @ts-ignore
    if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {
        return baseModule();
    }
    return Promise.all(deps.map((dep) => {
        // @ts-ignore
        dep = `${base}${dep}`;
        // @ts-ignore
        if (dep in seen)
            return;
        // @ts-ignore
        seen[dep] = true;
        const isCss = dep.endsWith('.css');
        const cssSelector = isCss ? '[rel="stylesheet"]' : '';
        // @ts-ignore check if the file is already preloaded by SSR markup
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
            return;
        }
        // @ts-ignore
        const link = document.createElement('link');
        // @ts-ignore
        link.rel = isCss ? 'stylesheet' : scriptRel;
        if (!isCss) {
            link.as = 'script';
            link.crossOrigin = '';
        }
        link.href = dep;
        // @ts-ignore
        document.head.appendChild(link);
        if (isCss) {
            return new Promise((res, rej) => {
                link.addEventListener('load', res);
                link.addEventListener('error', rej);
            });
        }
    })).then(() => baseModule());
}
/**
 * Build only. During serve this is performed as part of ./importAnalysis.
 */
function buildImportAnalysisPlugin(config) {
    const ssr = !!config.build.ssr;
    const insertPreload = !(ssr || !!config.build.lib);
    const scriptRel = config.build.polyfillModulePreload
        ? `'modulepreload'`
        : `(${detectScriptRel.toString()})()`;
    const preloadCode = `const scriptRel = ${scriptRel};const seen = {};const base = '${preloadBaseMarker}';export const ${preloadMethod} = ${preload.toString()}`;
    return {
        name: 'vite:import-analysis',
        resolveId(id) {
            if (id === preloadHelperId) {
                return id;
            }
        },
        load(id) {
            if (id === preloadHelperId) {
                return preloadCode.replace(preloadBaseMarker, config.base);
            }
        },
        async transform(source, importer) {
            if (importer.includes('node_modules') &&
                !source.includes('import.meta.glob')) {
                return;
            }
            await esModuleLexer.init;
            let imports = [];
            try {
                imports = esModuleLexer.parse(source)[0];
            }
            catch (e) {
                this.error(e, e.idx);
            }
            if (!imports.length) {
                return null;
            }
            let s;
            const str = () => s || (s = new MagicString__default(source));
            let needPreloadHelper = false;
            for (let index = 0; index < imports.length; index++) {
                const { s: start, e: end, ss: expStart, n: specifier, d: dynamicIndex } = imports[index];
                // import.meta.glob
                if (source.slice(start, end) === 'import.meta' &&
                    source.slice(end, end + 5) === '.glob') {
                    const { importsString, exp, endIndex, isEager } = await transformImportGlob(source, start, importer, index, config.root, undefined, insertPreload);
                    str().prepend(importsString);
                    str().overwrite(expStart, endIndex, exp);
                    if (!isEager) {
                        needPreloadHelper = true;
                    }
                    continue;
                }
                if (dynamicIndex > -1 && insertPreload) {
                    needPreloadHelper = true;
                    const dynamicEnd = source.indexOf(`)`, end) + 1;
                    const original = source.slice(dynamicIndex, dynamicEnd);
                    const replacement = `${preloadMethod}(() => ${original},${isModernFlag}?"${preloadMarker}":void 0)`;
                    str().overwrite(dynamicIndex, dynamicEnd, replacement);
                }
                // Differentiate CSS imports that use the default export from those that
                // do not by injecting a ?used query - this allows us to avoid including
                // the CSS string when unnecessary (esbuild has trouble treeshaking
                // them)
                if (specifier &&
                    isCSSRequest(specifier) &&
                    source.slice(expStart, start).includes('from') &&
                    // edge case for package names ending with .css (e.g normalize.css)
                    !(bareImportRE.test(specifier) && !specifier.includes('/'))) {
                    const url = specifier.replace(/\?|$/, (m) => `?used${m ? '&' : ''}`);
                    str().overwrite(start, end, dynamicIndex > -1 ? `'${url}'` : url);
                }
            }
            if (needPreloadHelper &&
                insertPreload &&
                !source.includes(`const ${preloadMethod} =`)) {
                str().prepend(`import { ${preloadMethod} } from "${preloadHelperId}";`);
            }
            if (s) {
                return {
                    code: s.toString(),
                    map: config.build.sourcemap ? s.generateMap({ hires: true }) : null
                };
            }
        },
        renderChunk(code, _, { format }) {
            // make sure we only perform the preload logic in modern builds.
            if (code.indexOf(isModernFlag) > -1) {
                const re = new RegExp(isModernFlag, 'g');
                const isModern = String(format === 'es');
                if (config.build.sourcemap) {
                    const s = new MagicString__default(code);
                    let match;
                    while ((match = re.exec(code))) {
                        s.overwrite(match.index, match.index + isModernFlag.length, isModern);
                    }
                    return {
                        code: s.toString(),
                        map: s.generateMap({ hires: true })
                    };
                }
                else {
                    return code.replace(re, isModern);
                }
            }
            return null;
        },
        generateBundle({ format }, bundle) {
            if (format !== 'es' || ssr) {
                return;
            }
            for (const file in bundle) {
                const chunk = bundle[file];
                // can't use chunk.dynamicImports.length here since some modules e.g.
                // dynamic import to constant json may get inlined.
                if (chunk.type === 'chunk' && chunk.code.indexOf(preloadMarker) > -1) {
                    const code = chunk.code;
                    let imports;
                    try {
                        imports = esModuleLexer.parse(code)[0].filter((i) => i.d > -1);
                    }
                    catch (e) {
                        this.error(e, e.idx);
                    }
                    if (imports.length) {
                        const s = new MagicString__default(code);
                        for (let index = 0; index < imports.length; index++) {
                            const { s: start, e: end, d: dynamicIndex } = imports[index];
                            // check the chunk being imported
                            const url = code.slice(start, end);
                            const deps = new Set();
                            let hasRemovedPureCssChunk = false;
                            if (url[0] === `"` && url[url.length - 1] === `"`) {
                                const ownerFilename = chunk.fileName;
                                // literal import - trace direct imports and add to deps
                                const analyzed = new Set();
                                const addDeps = (filename) => {
                                    if (filename === ownerFilename)
                                        return;
                                    if (analyzed.has(filename))
                                        return;
                                    analyzed.add(filename);
                                    const chunk = bundle[filename];
                                    if (chunk) {
                                        deps.add(chunk.fileName);
                                        const cssFiles = chunkToEmittedCssFileMap.get(chunk);
                                        if (cssFiles) {
                                            cssFiles.forEach((file) => {
                                                deps.add(file);
                                            });
                                        }
                                        chunk.imports.forEach(addDeps);
                                    }
                                    else {
                                        const removedPureCssFiles = removedPureCssFilesCache.get(config);
                                        const chunk = removedPureCssFiles.get(filename);
                                        if (chunk) {
                                            const cssFiles = chunkToEmittedCssFileMap.get(chunk);
                                            if (cssFiles && cssFiles.size > 0) {
                                                cssFiles.forEach((file) => {
                                                    deps.add(file);
                                                });
                                                hasRemovedPureCssChunk = true;
                                            }
                                            s.overwrite(dynamicIndex, end + 1, 'Promise.resolve({})');
                                        }
                                    }
                                };
                                const normalizedFile = path__default.posix.join(path__default.posix.dirname(chunk.fileName), url.slice(1, -1));
                                addDeps(normalizedFile);
                            }
                            let markPos = code.indexOf(preloadMarker, end);
                            // fix issue #3051
                            if (markPos === -1 && imports.length === 1) {
                                markPos = code.indexOf(preloadMarker);
                            }
                            if (markPos > 0) {
                                s.overwrite(markPos - 1, markPos + preloadMarker.length + 1, 
                                // the dep list includes the main chunk, so only need to
                                // preload when there are actual other deps.
                                deps.size > 1 ||
                                    // main chunk is removed
                                    (hasRemovedPureCssChunk && deps.size > 0)
                                    ? `[${[...deps].map((d) => JSON.stringify(d)).join(',')}]`
                                    : `[]`);
                            }
                        }
                        chunk.code = s.toString();
                        // TODO source map
                    }
                    // there may still be markers due to inlined dynamic imports, remove
                    // all the markers regardless
                    chunk.code = chunk.code.replace(preloadMarkerRE, 'void 0');
                }
            }
        }
    };
}

const modulePreloadPolyfillId = 'vite/modulepreload-polyfill';
function modulePreloadPolyfillPlugin(config) {
    const skip = config.build.ssr;
    let polyfillString;
    return {
        name: 'vite:modulepreload-polyfill',
        resolveId(id) {
            if (id === modulePreloadPolyfillId) {
                return id;
            }
        },
        load(id) {
            if (id === modulePreloadPolyfillId) {
                if (skip) {
                    return '';
                }
                if (!polyfillString) {
                    polyfillString =
                        `const p = ${polyfill.toString()};` + `${isModernFlag}&&p();`;
                }
                return polyfillString;
            }
        }
    };
}
function polyfill() {
    const relList = document.createElement('link').relList;
    if (relList && relList.supports && relList.supports('modulepreload')) {
        return;
    }
    for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
    }
    new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.type !== 'childList') {
                continue;
            }
            for (const node of mutation.addedNodes) {
                if (node.tagName === 'LINK' && node.rel === 'modulepreload')
                    processPreload(node);
            }
        }
    }).observe(document, { childList: true, subtree: true });
    function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
            fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
            fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === 'use-credentials')
            fetchOpts.credentials = 'include';
        else if (script.crossorigin === 'anonymous')
            fetchOpts.credentials = 'omit';
        else
            fetchOpts.credentials = 'same-origin';
        return fetchOpts;
    }
    function processPreload(link) {
        if (link.ep)
            // ep marker = processed
            return;
        link.ep = true;
        // prepopulate the load record
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
    }
}

const htmlProxyRE = /\?html-proxy&index=(\d+)\.js$/;
const isHTMLProxy = (id) => htmlProxyRE.test(id);
const htmlCommentRE = /<!--[\s\S]*?-->/g;
const scriptModuleRE$1 = /(<script\b[^>]*type\s*=\s*(?:"module"|'module')[^>]*>)(.*?)<\/script>/gims;
function htmlInlineScriptProxyPlugin() {
    return {
        name: 'vite:html',
        resolveId(id) {
            if (htmlProxyRE.test(id)) {
                return id;
            }
        },
        load(id) {
            const proxyMatch = id.match(htmlProxyRE);
            if (proxyMatch) {
                const index = Number(proxyMatch[1]);
                const file = cleanUrl(id);
                const html = fs__default.readFileSync(file, 'utf-8').replace(htmlCommentRE, '');
                let match;
                scriptModuleRE$1.lastIndex = 0;
                for (let i = 0; i <= index; i++) {
                    match = scriptModuleRE$1.exec(html);
                }
                if (match) {
                    return match[2];
                }
                else {
                    throw new Error(`No matching html proxy module found from ${id}`);
                }
            }
        }
    };
}
// this extends the config in @vue/compiler-sfc with <link href>
const assetAttrsConfig = {
    link: ['href'],
    video: ['src', 'poster'],
    source: ['src', 'srcset'],
    img: ['src', 'srcset'],
    image: ['xlink:href', 'href'],
    use: ['xlink:href', 'href']
};
const isAsyncScriptMap = new WeakMap();
async function traverseHtml(html, filePath, visitor) {
    // lazy load compiler
    const { parse, transform } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@vue/compiler-dom')); });
    // @vue/compiler-core doesn't like lowercase doctypes
    html = html.replace(/<!doctype\s/i, '<!DOCTYPE ');
    try {
        const ast = parse(html, { comments: true });
        transform(ast, {
            nodeTransforms: [visitor]
        });
    }
    catch (e) {
        const parseError = {
            loc: filePath,
            frame: '',
            ...formatParseError(e, filePath, html)
        };
        throw new Error(`Unable to parse ${JSON.stringify(parseError.loc)}\n${parseError.frame}`);
    }
}
function getScriptInfo(node) {
    let src;
    let isModule = false;
    let isAsync = false;
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.name === 'src') {
                src = p;
            }
            else if (p.name === 'type' && p.value && p.value.content === 'module') {
                isModule = true;
            }
            else if (p.name === 'async') {
                isAsync = true;
            }
        }
    }
    return { src, isModule, isAsync };
}
function formatParseError(e, id, html) {
    // normalize the error to rollup format
    if (e.loc) {
        e.frame = generateCodeFrame(html, e.loc.start.offset);
        e.loc = {
            file: id,
            line: e.loc.start.line,
            column: e.loc.start.column
        };
    }
    return e;
}
/**
 * Compiles index.html into an entry js module
 */
function buildHtmlPlugin(config) {
    const [preHooks, postHooks] = resolveHtmlTransforms(config.plugins);
    const processedHtml = new Map();
    const isExcludedUrl = (url) => url.startsWith('#') ||
        isExternalUrl(url) ||
        isDataUrl(url) ||
        checkPublicFile(url, config);
    return {
        name: 'vite:build-html',
        buildStart() {
            isAsyncScriptMap.set(config, new Map());
        },
        async transform(html, id) {
            if (id.endsWith('.html')) {
                const publicPath = `/${slash(path__default.relative(config.root, id))}`;
                // pre-transform
                html = await applyHtmlTransforms(html, preHooks, {
                    path: publicPath,
                    filename: id
                });
                let js = '';
                const s = new MagicString__default(html);
                const assetUrls = [];
                let inlineModuleIndex = -1;
                let everyScriptIsAsync = true;
                let someScriptsAreAsync = false;
                let someScriptsAreDefer = false;
                await traverseHtml(html, id, (node) => {
                    if (node.type !== 1 /* ELEMENT */) {
                        return;
                    }
                    let shouldRemove = false;
                    // script tags
                    if (node.tag === 'script') {
                        const { src, isModule, isAsync } = getScriptInfo(node);
                        const url = src && src.value && src.value.content;
                        if (url && checkPublicFile(url, config)) {
                            // referencing public dir url, prefix with base
                            s.overwrite(src.value.loc.start.offset, src.value.loc.end.offset, `"${config.base + url.slice(1)}"`);
                        }
                        if (isModule) {
                            inlineModuleIndex++;
                            if (url && !isExcludedUrl(url)) {
                                // <script type="module" src="..."/>
                                // add it as an import
                                js += `\nimport ${JSON.stringify(url)}`;
                                shouldRemove = true;
                            }
                            else if (node.children.length) {
                                // <script type="module">...</script>
                                js += `\nimport "${id}?html-proxy&index=${inlineModuleIndex}.js"`;
                                shouldRemove = true;
                            }
                            everyScriptIsAsync && (everyScriptIsAsync = isAsync);
                            someScriptsAreAsync || (someScriptsAreAsync = isAsync);
                            someScriptsAreDefer || (someScriptsAreDefer = !isAsync);
                        }
                    }
                    // For asset references in index.html, also generate an import
                    // statement for each - this will be handled by the asset plugin
                    const assetAttrs = assetAttrsConfig[node.tag];
                    if (assetAttrs) {
                        for (const p of node.props) {
                            if (p.type === 6 /* ATTRIBUTE */ &&
                                p.value &&
                                assetAttrs.includes(p.name)) {
                                const url = p.value.content;
                                if (!isExcludedUrl(url)) {
                                    if (node.tag === 'link' && isCSSRequest(url)) {
                                        // CSS references, convert to import
                                        js += `\nimport ${JSON.stringify(url)}`;
                                        shouldRemove = true;
                                    }
                                    else {
                                        assetUrls.push(p);
                                    }
                                }
                                else if (checkPublicFile(url, config)) {
                                    s.overwrite(p.value.loc.start.offset, p.value.loc.end.offset, `"${config.base + url.slice(1)}"`);
                                }
                            }
                        }
                    }
                    if (shouldRemove) {
                        // remove the script tag from the html. we are going to inject new
                        // ones in the end.
                        s.remove(node.loc.start.offset, node.loc.end.offset);
                    }
                });
                isAsyncScriptMap.get(config).set(id, everyScriptIsAsync);
                if (someScriptsAreAsync && someScriptsAreDefer) {
                    config.logger.warn(`\nMixed async and defer script modules in ${id}, output script will fallback to defer. Every script, including inline ones, need to be marked as async for your output script to be async.`);
                }
                // for each encountered asset url, rewrite original html so that it
                // references the post-build location.
                for (const attr of assetUrls) {
                    const value = attr.value;
                    try {
                        const url = attr.name === 'srcset'
                            ? await processSrcSet(value.content, ({ url }) => urlToBuiltUrl(url, id, config, this))
                            : await urlToBuiltUrl(value.content, id, config, this);
                        s.overwrite(value.loc.start.offset, value.loc.end.offset, `"${url}"`);
                    }
                    catch (e) {
                        // #1885 preload may be pointing to urls that do not exist
                        // locally on disk
                        if (e.code !== 'ENOENT') {
                            throw e;
                        }
                    }
                }
                processedHtml.set(id, s.toString());
                // inject module preload polyfill
                if (config.build.polyfillModulePreload) {
                    js = `import "${modulePreloadPolyfillId}";\n${js}`;
                }
                return js;
            }
        },
        async generateBundle(options, bundle) {
            const analyzedChunk = new Map();
            const getImportedChunks = (chunk, seen = new Set()) => {
                const chunks = [];
                chunk.imports.forEach((file) => {
                    const importee = bundle[file];
                    if ((importee === null || importee === void 0 ? void 0 : importee.type) === 'chunk' && !seen.has(file)) {
                        seen.add(file);
                        // post-order traversal
                        chunks.push(...getImportedChunks(importee, seen));
                        chunks.push(importee);
                    }
                });
                return chunks;
            };
            const toScriptTag = (chunk, isAsync) => ({
                tag: 'script',
                attrs: {
                    ...(isAsync ? { async: true } : {}),
                    type: 'module',
                    crossorigin: true,
                    src: toPublicPath(chunk.fileName, config)
                }
            });
            const toPreloadTag = (chunk) => ({
                tag: 'link',
                attrs: {
                    rel: 'modulepreload',
                    href: toPublicPath(chunk.fileName, config)
                }
            });
            const getCssTagsForChunk = (chunk, seen = new Set()) => {
                const tags = [];
                if (!analyzedChunk.has(chunk)) {
                    analyzedChunk.set(chunk, 1);
                    chunk.imports.forEach((file) => {
                        const importee = bundle[file];
                        if ((importee === null || importee === void 0 ? void 0 : importee.type) === 'chunk') {
                            tags.push(...getCssTagsForChunk(importee, seen));
                        }
                    });
                }
                const cssFiles = chunkToEmittedCssFileMap.get(chunk);
                if (cssFiles) {
                    cssFiles.forEach((file) => {
                        if (!seen.has(file)) {
                            seen.add(file);
                            tags.push({
                                tag: 'link',
                                attrs: {
                                    rel: 'stylesheet',
                                    href: toPublicPath(file, config)
                                }
                            });
                        }
                    });
                }
                return tags;
            };
            for (const [id, html] of processedHtml) {
                const isAsync = isAsyncScriptMap.get(config).get(id);
                // resolve asset url references
                let result = html.replace(assetUrlRE, (_, fileHash, postfix = '') => {
                    return config.base + getAssetFilename(fileHash, config) + postfix;
                });
                // find corresponding entry chunk
                const chunk = Object.values(bundle).find((chunk) => chunk.type === 'chunk' &&
                    chunk.isEntry &&
                    chunk.facadeModuleId === id);
                let canInlineEntry = false;
                // inject chunk asset links
                if (chunk) {
                    // an entry chunk can be inlined if
                    //  - it's an ES module (e.g. not generated by the legacy plugin)
                    //  - it contains no meaningful code other than import statments
                    if (options.format === 'es' && isEntirelyImport(chunk.code)) {
                        canInlineEntry = true;
                    }
                    // when not inlined, inject <script> for entry and modulepreload its dependencies
                    // when inlined, discard entry chunk and inject <script> for everything in post-order
                    const imports = getImportedChunks(chunk);
                    const assetTags = canInlineEntry
                        ? imports.map((chunk) => toScriptTag(chunk, isAsync))
                        : [toScriptTag(chunk, isAsync), ...imports.map(toPreloadTag)];
                    assetTags.push(...getCssTagsForChunk(chunk));
                    result = injectToHead(result, assetTags);
                }
                // inject css link when cssCodeSplit is false
                if (!config.build.cssCodeSplit) {
                    const cssChunk = Object.values(bundle).find((chunk) => chunk.type === 'asset' && chunk.name === 'style.css');
                    if (cssChunk) {
                        result = injectToHead(result, [
                            {
                                tag: 'link',
                                attrs: {
                                    rel: 'stylesheet',
                                    href: toPublicPath(cssChunk.fileName, config)
                                }
                            }
                        ]);
                    }
                }
                const shortEmitName = path__default.posix.relative(config.root, id);
                result = await applyHtmlTransforms(result, postHooks, {
                    path: '/' + shortEmitName,
                    filename: id,
                    bundle,
                    chunk
                });
                if (chunk && canInlineEntry) {
                    // all imports from entry have been inlined to html, prevent rollup from outputting it
                    delete bundle[chunk.fileName];
                }
                this.emitFile({
                    type: 'asset',
                    fileName: shortEmitName,
                    source: result
                });
            }
        }
    };
}
function resolveHtmlTransforms(plugins) {
    const preHooks = [];
    const postHooks = [];
    for (const plugin of plugins) {
        const hook = plugin.transformIndexHtml;
        if (hook) {
            if (typeof hook === 'function') {
                postHooks.push(hook);
            }
            else if (hook.enforce === 'pre') {
                preHooks.push(hook.transform);
            }
            else {
                postHooks.push(hook.transform);
            }
        }
    }
    return [preHooks, postHooks];
}
async function applyHtmlTransforms(html, hooks, ctx) {
    const headTags = [];
    const headPrependTags = [];
    const bodyTags = [];
    const bodyPrependTags = [];
    for (const hook of hooks) {
        const res = await hook(html, ctx);
        if (!res) {
            continue;
        }
        if (typeof res === 'string') {
            html = res;
        }
        else {
            let tags;
            if (Array.isArray(res)) {
                tags = res;
            }
            else {
                html = res.html || html;
                tags = res.tags;
            }
            for (const tag of tags) {
                if (tag.injectTo === 'body') {
                    bodyTags.push(tag);
                }
                else if (tag.injectTo === 'body-prepend') {
                    bodyPrependTags.push(tag);
                }
                else if (tag.injectTo === 'head') {
                    headTags.push(tag);
                }
                else {
                    headPrependTags.push(tag);
                }
            }
        }
    }
    // inject tags
    if (headPrependTags.length) {
        html = injectToHead(html, headPrependTags, true);
    }
    if (headTags.length) {
        html = injectToHead(html, headTags);
    }
    if (bodyPrependTags.length) {
        html = injectToBody(html, bodyPrependTags, true);
    }
    if (bodyTags.length) {
        html = injectToBody(html, bodyTags);
    }
    return html;
}
const importRE = /\bimport\s*("[^"]*[^\\]"|'[^']*[^\\]');*/g;
const commentRE$1 = /\/\*[\s\S]*?\*\/|\/\/.*$/gm;
function isEntirelyImport(code) {
    // only consider "side-effect" imports, which match <script type=module> semantics exactly
    // the regexes will remove too little in some exotic cases, but false-negatives are alright
    return !code.replace(importRE, '').replace(commentRE$1, '').trim().length;
}
function toPublicPath(filename, config) {
    return isExternalUrl(filename) ? filename : config.base + filename;
}
const headInjectRE = /<\/head>/;
const headPrependInjectRE = [/<head>/, /<!doctype html>/i];
function injectToHead(html, tags, prepend = false) {
    const tagsHtml = serializeTags(tags);
    if (prepend) {
        // inject after head or doctype
        for (const re of headPrependInjectRE) {
            if (re.test(html)) {
                return html.replace(re, `$&\n${tagsHtml}`);
            }
        }
    }
    else {
        // inject before head close
        if (headInjectRE.test(html)) {
            return html.replace(headInjectRE, `${tagsHtml}\n  $&`);
        }
    }
    // if no <head> tag is present, just prepend
    return tagsHtml + `\n` + html;
}
const bodyInjectRE = /<\/body>/;
const bodyPrependInjectRE = /<body[^>]*>/;
function injectToBody(html, tags, prepend = false) {
    if (prepend) {
        // inject after body open
        const tagsHtml = `\n` + serializeTags(tags);
        if (bodyPrependInjectRE.test(html)) {
            return html.replace(bodyPrependInjectRE, `$&\n${tagsHtml}`);
        }
        // if no body, prepend
        return tagsHtml + `\n` + html;
    }
    else {
        // inject before body close
        const tagsHtml = `\n` + serializeTags(tags);
        if (bodyInjectRE.test(html)) {
            return html.replace(bodyInjectRE, `${tagsHtml}\n$&`);
        }
        // if no body, append
        return html + `\n` + tagsHtml;
    }
}
const unaryTags = new Set(['link', 'meta', 'base']);
function serializeTag({ tag, attrs, children }) {
    if (unaryTags.has(tag)) {
        return `<${tag}${serializeAttrs(attrs)}>`;
    }
    else {
        return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children)}</${tag}>`;
    }
}
function serializeTags(tags) {
    if (typeof tags === 'string') {
        return tags;
    }
    else if (tags) {
        return `  ${tags.map(serializeTag).join('\n    ')}`;
    }
    return '';
}
function serializeAttrs(attrs) {
    let res = '';
    for (const key in attrs) {
        if (typeof attrs[key] === 'boolean') {
            res += attrs[key] ? ` ${key}` : ``;
        }
        else {
            res += ` ${key}=${JSON.stringify(attrs[key])}`;
        }
    }
    return res;
}

const debug$8 = createDebugger('vite:esbuild');
let server;
async function transformWithEsbuild(code, filename, options, inMap) {
    var _a, _b, _c;
    let loader = options === null || options === void 0 ? void 0 : options.loader;
    if (!loader) {
        // if the id ends with a valid ext, use it (e.g. vue blocks)
        // otherwise, cleanup the query before checking the ext
        const ext = path__default
            .extname(/\.\w+$/.test(filename) ? filename : cleanUrl(filename))
            .slice(1);
        if (ext === 'cjs' || ext === 'mjs') {
            loader = 'js';
        }
        else {
            loader = ext;
        }
    }
    let tsconfigRaw = options === null || options === void 0 ? void 0 : options.tsconfigRaw;
    // if options provide tsconfigraw in string, it takes highest precedence
    if (typeof tsconfigRaw !== 'string') {
        // these fields would affect the compilation result
        // https://esbuild.github.io/content-types/#tsconfig-json
        const meaningfulFields = [
            'jsxFactory',
            'jsxFragmentFactory',
            'useDefineForClassFields',
            'importsNotUsedAsValues'
        ];
        const compilerOptionsForFile = {};
        if (loader === 'ts' || loader === 'tsx') {
            const loadedTsconfig = await loadTsconfigJsonForFile(filename);
            const loadedCompilerOptions = (_a = loadedTsconfig.compilerOptions) !== null && _a !== void 0 ? _a : {};
            for (const field of meaningfulFields) {
                if (field in loadedCompilerOptions) {
                    // @ts-ignore TypeScript can't tell they are of the same type
                    compilerOptionsForFile[field] = loadedCompilerOptions[field];
                }
            }
            // align with TypeScript 4.3
            // https://github.com/microsoft/TypeScript/pull/42663
            if (((_b = loadedCompilerOptions.target) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'esnext') {
                compilerOptionsForFile.useDefineForClassFields =
                    (_c = loadedCompilerOptions.useDefineForClassFields) !== null && _c !== void 0 ? _c : true;
            }
        }
        tsconfigRaw = {
            ...tsconfigRaw,
            compilerOptions: {
                ...compilerOptionsForFile,
                ...tsconfigRaw === null || tsconfigRaw === void 0 ? void 0 : tsconfigRaw.compilerOptions
            }
        };
    }
    const resolvedOptions = {
        sourcemap: true,
        // ensure source file name contains full query
        sourcefile: filename,
        ...options,
        loader,
        tsconfigRaw
    };
    delete resolvedOptions.include;
    delete resolvedOptions.exclude;
    delete resolvedOptions.jsxInject;
    try {
        const result = await esbuild.transform(code, resolvedOptions);
        let map;
        if (inMap && resolvedOptions.sourcemap) {
            const nextMap = JSON.parse(result.map);
            nextMap.sourcesContent = [];
            map = combineSourcemaps(filename, [
                nextMap,
                inMap
            ]);
        }
        else {
            map = resolvedOptions.sourcemap
                ? JSON.parse(result.map)
                : { mappings: '' };
        }
        if (Array.isArray(map.sources)) {
            map.sources = map.sources.map((it) => toUpperCaseDriveLetter(it));
        }
        return {
            ...result,
            map
        };
    }
    catch (e) {
        debug$8(`esbuild error with options used: `, resolvedOptions);
        // patch error information
        if (e.errors) {
            e.frame = '';
            e.errors.forEach((m) => {
                e.frame += `\n` + prettifyMessage(m, code);
            });
            e.loc = e.errors[0].location;
        }
        throw e;
    }
}
function esbuildPlugin(options = {}) {
    const filter = pluginutils.createFilter(options.include || /\.(tsx?|jsx)$/, options.exclude || /\.js$/);
    return {
        name: 'vite:esbuild',
        configureServer(_server) {
            server = _server;
            server.watcher
                .on('add', reloadOnTsconfigChange)
                .on('change', reloadOnTsconfigChange)
                .on('unlink', reloadOnTsconfigChange);
        },
        async transform(code, id) {
            if (filter(id) || filter(cleanUrl(id))) {
                const result = await transformWithEsbuild(code, id, options);
                if (result.warnings.length) {
                    result.warnings.forEach((m) => {
                        this.warn(prettifyMessage(m, code));
                    });
                }
                if (options.jsxInject && /\.(?:j|t)sx\b/.test(id)) {
                    result.code = options.jsxInject + ';' + result.code;
                }
                return {
                    code: result.code,
                    map: result.map
                };
            }
        }
    };
}
const buildEsbuildPlugin = (config) => {
    return {
        name: 'vite:esbuild-transpile',
        async renderChunk(code, chunk, opts) {
            // @ts-ignore injected by @vitejs/plugin-legacy
            if (opts.__vite_skip_esbuild__) {
                return null;
            }
            const target = config.build.target;
            const minify = config.build.minify === 'esbuild';
            if ((!target || target === 'esnext') && !minify) {
                return null;
            }
            return transformWithEsbuild(code, chunk.fileName, {
                target: target || undefined,
                minify
            });
        }
    };
};
function prettifyMessage(m, code) {
    let res = chalk__default.yellow(m.text);
    if (m.location) {
        const lines = code.split(/\r?\n/g);
        const line = Number(m.location.line);
        const column = Number(m.location.column);
        const offset = lines
            .slice(0, line - 1)
            .map((l) => l.length)
            .reduce((total, l) => total + l + 1, 0) + column;
        res += `\n` + generateCodeFrame(code, offset, offset + 1);
    }
    return res + `\n`;
}
const tsconfigCache = new Map();
async function loadTsconfigJsonForFile(filename) {
    try {
        const result = await tsconfck.parse(filename, {
            cache: tsconfigCache,
            resolveWithEmptyIfConfigNotFound: true
        });
        // tsconfig could be out of root, make sure it is watched on dev
        if (server && result.tsconfigFile !== 'no_tsconfig_file_found') {
            ensureWatchedFile(server.watcher, result.tsconfigFile, server.config.root);
        }
        return result.tsconfig;
    }
    catch (e) {
        if (e instanceof tsconfck.TSConfckParseError) {
            // tsconfig could be out of root, make sure it is watched on dev
            if (server && e.tsconfigFile) {
                ensureWatchedFile(server.watcher, e.tsconfigFile, server.config.root);
            }
        }
        throw e;
    }
}
function reloadOnTsconfigChange(changedFile) {
    // any tsconfig.json that's added in the workspace could be closer to a code file than a previously cached one
    // any json file in the tsconfig cache could have been used to compile ts
    if (path__default.basename(changedFile) === 'tsconfig.json' ||
        (changedFile.endsWith('.json') && tsconfigCache.has(changedFile))) {
        server.config.logger.info(`changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure typescript is compiled with updated config values.`, { clear: server.config.clearScreen, timestamp: true });
        // clear tsconfig cache so that recompile works with up2date configs
        tsconfigCache.clear();
        // clear module graph to remove code compiled with outdated config
        server.moduleGraph.invalidateAll();
        // force full reload
        server.ws.send({
            type: 'full-reload',
            path: '*'
        });
    }
}

function terserPlugin(options) {
    const worker = new okie.Worker((basedir, code, options) => {
        // when vite is linked, the worker thread won't share the same resolve
        // root with vite itself, so we have to pass in the basedir and resolve
        // terser first.
        // eslint-disable-next-line node/no-restricted-require
        const terserPath = require.resolve('terser', {
            paths: [basedir]
        });
        return require(terserPath).minify(code, options);
    });
    return {
        name: 'vite:terser',
        async renderChunk(code, _chunk, outputOptions) {
            const res = await worker.run(__dirname, code, {
                safari10: true,
                ...options,
                sourceMap: !!outputOptions.sourcemap,
                module: outputOptions.format.startsWith('es'),
                toplevel: outputOptions.format === 'cjs'
            });
            return {
                code: res.code,
                map: res.map
            };
        },
        closeBundle() {
            worker.stop();
        }
    };
}

function manifestPlugin(config) {
    const manifest = {};
    let outputCount;
    return {
        name: 'vite:manifest',
        buildStart() {
            outputCount = 0;
        },
        generateBundle({ format }, bundle) {
            var _a;
            function getChunkName(chunk) {
                if (chunk.facadeModuleId) {
                    let name = normalizePath(path__default.relative(config.root, chunk.facadeModuleId));
                    if (format === 'system' && !chunk.name.includes('-legacy')) {
                        const ext = path__default.extname(name);
                        name = name.slice(0, -ext.length) + `-legacy` + ext;
                    }
                    return name;
                }
                else {
                    return `_` + path__default.basename(chunk.fileName);
                }
            }
            function getInternalImports(imports) {
                const filteredImports = [];
                for (const file of imports) {
                    if (bundle[file] === undefined) {
                        continue;
                    }
                    filteredImports.push(getChunkName(bundle[file]));
                }
                return filteredImports;
            }
            function createChunk(chunk) {
                const manifestChunk = {
                    file: chunk.fileName
                };
                if (chunk.facadeModuleId) {
                    manifestChunk.src = getChunkName(chunk);
                }
                if (chunk.isEntry) {
                    manifestChunk.isEntry = true;
                }
                if (chunk.isDynamicEntry) {
                    manifestChunk.isDynamicEntry = true;
                }
                if (chunk.imports.length) {
                    const internalImports = getInternalImports(chunk.imports);
                    if (internalImports.length > 0) {
                        manifestChunk.imports = internalImports;
                    }
                }
                if (chunk.dynamicImports.length) {
                    const internalImports = getInternalImports(chunk.dynamicImports);
                    if (internalImports.length > 0) {
                        manifestChunk.dynamicImports = internalImports;
                    }
                }
                const cssFiles = chunkToEmittedCssFileMap.get(chunk);
                if (cssFiles) {
                    manifestChunk.css = [...cssFiles];
                }
                const assets = chunkToEmittedAssetsMap.get(chunk);
                if (assets)
                    [(manifestChunk.assets = [...assets])];
                return manifestChunk;
            }
            for (const file in bundle) {
                const chunk = bundle[file];
                if (chunk.type === 'chunk') {
                    manifest[getChunkName(chunk)] = createChunk(chunk);
                }
            }
            outputCount++;
            const output = (_a = config.build.rollupOptions) === null || _a === void 0 ? void 0 : _a.output;
            const outputLength = Array.isArray(output) ? output.length : 1;
            if (outputCount >= outputLength) {
                this.emitFile({
                    fileName: `manifest.json`,
                    type: 'asset',
                    source: JSON.stringify(manifest, null, 2)
                });
            }
        }
    };
}

const dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/;
const dataUriPrefix = `/@data-uri/`;
/**
 * Build only, since importing from a data URI works natively.
 */
function dataURIPlugin() {
    let resolved;
    return {
        name: 'vite:data-uri',
        buildStart() {
            resolved = {};
        },
        resolveId(id) {
            if (!dataUriRE.test(id)) {
                return null;
            }
            const uri = new url.URL(id);
            if (uri.protocol !== 'data:') {
                return null;
            }
            const match = uri.pathname.match(dataUriRE);
            if (!match) {
                return null;
            }
            const [, mime, format, data] = match;
            if (mime !== 'text/javascript') {
                throw new Error(`data URI with non-JavaScript mime type is not supported.`);
            }
            // decode data
            const base64 = format && /base64/i.test(format.substring(1));
            const content = base64
                ? Buffer.from(data, 'base64').toString('utf-8')
                : data;
            resolved[id] = content;
            return dataUriPrefix + id;
        },
        load(id) {
            if (id.startsWith(dataUriPrefix)) {
                id = id.slice(dataUriPrefix.length);
                return resolved[id] || null;
            }
        }
    };
}

// special id for paths marked with browser: false
// https://github.com/defunctzombie/package-browser-field-spec#ignore-a-module
const browserExternalId = '__vite-browser-external';
const isDebug$5 = process.env.DEBUG;
const debug$7 = createDebugger('vite:resolve-details', {
    onlyWhenFocused: true
});
function resolvePlugin(baseOptions) {
    const { root, isProduction, asSrc, ssrConfig, preferRelative = false } = baseOptions;
    const requireOptions = {
        ...baseOptions,
        isRequire: true
    };
    let server;
    const { target: ssrTarget, noExternal: ssrNoExternal } = ssrConfig !== null && ssrConfig !== void 0 ? ssrConfig : {};
    return {
        name: 'vite:resolve',
        configureServer(_server) {
            server = _server;
        },
        resolveId(id, importer, resolveOpts, ssr) {
            if (id.startsWith(browserExternalId)) {
                return id;
            }
            // fast path for commonjs proxy modules
            if (/\?commonjs/.test(id) || id === 'commonjsHelpers.js') {
                return;
            }
            const targetWeb = !ssr || ssrTarget === 'webworker';
            // this is passed by @rollup/plugin-commonjs
            const isRequire = resolveOpts &&
                resolveOpts.custom &&
                resolveOpts.custom['node-resolve'] &&
                resolveOpts.custom['node-resolve'].isRequire;
            const options = isRequire ? requireOptions : baseOptions;
            const preserveSymlinks = !!(server === null || server === void 0 ? void 0 : server.config.resolve.preserveSymlinks);
            let res;
            // explicit fs paths that starts with /@fs/*
            if (asSrc && id.startsWith(FS_PREFIX)) {
                const fsPath = fsPathFromId(id);
                res = tryFsResolve(fsPath, options, preserveSymlinks);
                isDebug$5 && debug$7(`[@fs] ${chalk__default.cyan(id)} -> ${chalk__default.dim(res)}`);
                // always return here even if res doesn't exist since /@fs/ is explicit
                // if the file doesn't exist it should be a 404
                return res || fsPath;
            }
            // URL
            // /foo -> /fs-root/foo
            if (asSrc && id.startsWith('/')) {
                const fsPath = path__default.resolve(root, id.slice(1));
                if ((res = tryFsResolve(fsPath, options, preserveSymlinks))) {
                    isDebug$5 && debug$7(`[url] ${chalk__default.cyan(id)} -> ${chalk__default.dim(res)}`);
                    return res;
                }
            }
            // relative
            if (id.startsWith('.') || (preferRelative && /^\w/.test(id))) {
                const basedir = importer ? path__default.dirname(importer) : process.cwd();
                const fsPath = path__default.resolve(basedir, id);
                // handle browser field mapping for relative imports
                const normalizedFsPath = normalizePath(fsPath);
                const pathFromBasedir = normalizedFsPath.slice(basedir.length);
                if (pathFromBasedir.startsWith('/node_modules/')) {
                    // normalize direct imports from node_modules to bare imports, so the
                    // hashing logic is shared and we avoid duplicated modules #2503
                    const bareImport = pathFromBasedir.slice('/node_modules/'.length);
                    if ((res = tryNodeResolve(bareImport, importer, options, targetWeb, server, ssr)) &&
                        res.id.startsWith(normalizedFsPath)) {
                        return res;
                    }
                }
                if (targetWeb &&
                    (res = tryResolveBrowserMapping(fsPath, importer, options, true, preserveSymlinks))) {
                    return res;
                }
                if ((res = tryFsResolve(fsPath, options, preserveSymlinks))) {
                    isDebug$5 && debug$7(`[relative] ${chalk__default.cyan(id)} -> ${chalk__default.dim(res)}`);
                    const pkg = importer != null && idToPkgMap.get(importer);
                    if (pkg) {
                        idToPkgMap.set(res, pkg);
                        return {
                            id: res,
                            moduleSideEffects: pkg.hasSideEffects(res)
                        };
                    }
                    return res;
                }
            }
            // absolute fs paths
            if (path__default.isAbsolute(id) &&
                (res = tryFsResolve(id, options, preserveSymlinks))) {
                isDebug$5 && debug$7(`[fs] ${chalk__default.cyan(id)} -> ${chalk__default.dim(res)}`);
                return res;
            }
            // external
            if (isExternalUrl(id)) {
                return {
                    id,
                    external: true
                };
            }
            // data uri: pass through (this only happens during build and will be
            // handled by dedicated plugin)
            if (isDataUrl(id)) {
                return null;
            }
            // bare package imports, perform node resolve
            if (bareImportRE.test(id)) {
                if (asSrc &&
                    server &&
                    !ssr &&
                    (res = tryOptimizedResolve(id, server, importer))) {
                    return res;
                }
                if (targetWeb &&
                    (res = tryResolveBrowserMapping(id, importer, options, false, preserveSymlinks))) {
                    return res;
                }
                if ((res = tryNodeResolve(id, importer, options, targetWeb, server, ssr))) {
                    return res;
                }
                // node built-ins.
                // externalize if building for SSR, otherwise redirect to empty module
                if (isBuiltin(id)) {
                    if (ssr) {
                        if (ssrNoExternal === true) {
                            let message = `Cannot bundle Node.js built-in "${id}"`;
                            if (importer) {
                                message += ` imported from "${path__default.relative(process.cwd(), importer)}"`;
                            }
                            message += `. Consider disabling ssr.noExternal or remove the built-in dependency.`;
                            this.error(message);
                        }
                        return {
                            id,
                            external: true
                        };
                    }
                    else {
                        if (!asSrc) {
                            debug$7(`externalized node built-in "${id}" to empty module. ` +
                                `(imported by: ${chalk__default.white.dim(importer)})`);
                        }
                        return isProduction
                            ? browserExternalId
                            : `${browserExternalId}:${id}`;
                    }
                }
            }
            isDebug$5 && debug$7(`[fallthrough] ${chalk__default.dim(id)}`);
        },
        load(id) {
            if (id.startsWith(browserExternalId)) {
                return isProduction
                    ? `export default {}`
                    : `export default new Proxy({}, {
  get() {
    throw new Error('Module "${id.slice(browserExternalId.length + 1)}" has been externalized for browser compatibility and cannot be accessed in client code.')
  }
})`;
            }
        }
    };
}
function tryFsResolve(fsPath, options, preserveSymlinks, tryIndex = true, targetWeb = true) {
    let file = fsPath;
    let postfix = '';
    let postfixIndex = fsPath.indexOf('?');
    if (postfixIndex < 0) {
        postfixIndex = fsPath.indexOf('#');
    }
    if (postfixIndex > 0) {
        file = fsPath.slice(0, postfixIndex);
        postfix = fsPath.slice(postfixIndex);
    }
    let res;
    if ((res = tryResolveFile(file, postfix, options, false, targetWeb, preserveSymlinks, options.tryPrefix, options.skipPackageJson))) {
        return res;
    }
    for (const ext of options.extensions || DEFAULT_EXTENSIONS) {
        if ((res = tryResolveFile(file + ext, postfix, options, false, targetWeb, preserveSymlinks, options.tryPrefix, options.skipPackageJson))) {
            return res;
        }
    }
    if ((res = tryResolveFile(file, postfix, options, tryIndex, targetWeb, preserveSymlinks, options.tryPrefix, options.skipPackageJson))) {
        return res;
    }
}
function tryResolveFile(file, postfix, options, tryIndex, targetWeb, preserveSymlinks, tryPrefix, skipPackageJson) {
    let isReadable = false;
    try {
        // #2051 if we don't have read permission on a directory, existsSync() still
        // works and will result in massively slow subsequent checks (which are
        // unnecessary in the first place)
        fs__default.accessSync(file, fs__default.constants.R_OK);
        isReadable = true;
    }
    catch (e) { }
    if (isReadable) {
        if (!fs__default.statSync(file).isDirectory()) {
            return normalizePath(ensureVolumeInPath(file)) + postfix;
        }
        else if (tryIndex) {
            if (!skipPackageJson) {
                const pkgPath = file + '/package.json';
                if (fs__default.existsSync(pkgPath)) {
                    // path points to a node package
                    const pkg = loadPackageData(pkgPath);
                    const resolved = resolvePackageEntry(file, pkg, options, targetWeb, preserveSymlinks);
                    return resolved ? getRealPath(resolved, preserveSymlinks) : resolved;
                }
            }
            const index = tryFsResolve(file + '/index', options, preserveSymlinks);
            if (index)
                return index + postfix;
        }
    }
    if (tryPrefix) {
        const prefixed = `${path__default.dirname(file)}/${tryPrefix}${path__default.basename(file)}`;
        return tryResolveFile(prefixed, postfix, options, tryIndex, targetWeb, preserveSymlinks);
    }
}
const idToPkgMap = new Map();
function tryNodeResolve(id, importer, options, targetWeb, server, ssr) {
    var _a, _b, _c;
    const { root, dedupe, isBuild } = options;
    // split id by last '>' for nested selected packages, for example:
    // 'foo > bar > baz' => 'foo > bar' & 'baz'
    // 'foo'             => ''          & 'foo'
    const lastArrowIndex = id.lastIndexOf('>');
    const nestedRoot = id.substring(0, lastArrowIndex).trim();
    const nestedPath = id.substring(lastArrowIndex + 1).trim();
    // check for deep import, e.g. "my-lib/foo"
    const deepMatch = nestedPath.match(deepImportRE);
    const pkgId = deepMatch ? deepMatch[1] || deepMatch[2] : nestedPath;
    let basedir;
    if (dedupe && dedupe.includes(pkgId)) {
        basedir = root;
    }
    else if (importer &&
        path__default.isAbsolute(importer) &&
        fs__default.existsSync(cleanUrl(importer))) {
        basedir = path__default.dirname(importer);
    }
    else {
        basedir = root;
    }
    const preserveSymlinks = !!(server === null || server === void 0 ? void 0 : server.config.resolve.preserveSymlinks);
    // nested node module, step-by-step resolve to the basedir of the nestedPath
    if (nestedRoot) {
        basedir = nestedResolveFrom(nestedRoot, basedir, preserveSymlinks);
    }
    const pkg = resolvePackageData(pkgId, basedir, preserveSymlinks);
    if (!pkg) {
        return;
    }
    let resolved = deepMatch
        ? resolveDeepImport('.' + id.slice(pkgId.length), pkg, options, targetWeb, preserveSymlinks)
        : resolvePackageEntry(id, pkg, options, targetWeb, preserveSymlinks);
    if (!resolved) {
        return;
    }
    resolved = getRealPath(resolved, preserveSymlinks);
    // link id to pkg for browser field mapping check
    idToPkgMap.set(resolved, pkg);
    if (isBuild) {
        // Resolve package side effects for build so that rollup can better
        // perform tree-shaking
        return {
            id: resolved,
            moduleSideEffects: pkg.hasSideEffects(resolved)
        };
    }
    else {
        if (!resolved.includes('node_modules') || // linked
            !server || // build
            server._isRunningOptimizer || // optimizing
            !server._optimizeDepsMetadata) {
            return { id: resolved };
        }
        // if we reach here, it's a valid dep import that hasn't been optimized.
        const isJsType = OPTIMIZABLE_ENTRY_RE.test(resolved);
        const exclude = (_a = server.config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.exclude;
        if (!isJsType ||
            (importer === null || importer === void 0 ? void 0 : importer.includes('node_modules')) ||
            (exclude === null || exclude === void 0 ? void 0 : exclude.includes(pkgId)) ||
            (exclude === null || exclude === void 0 ? void 0 : exclude.includes(id)) ||
            SPECIAL_QUERY_RE.test(resolved)) {
            // excluded from optimization
            // Inject a version query to npm deps so that the browser
            // can cache it without re-validation, but only do so for known js types.
            // otherwise we may introduce duplicated modules for externalized files
            // from pre-bundled deps.
            const versionHash = (_b = server._optimizeDepsMetadata) === null || _b === void 0 ? void 0 : _b.browserHash;
            if (versionHash && isJsType) {
                resolved = injectQuery(resolved, `v=${versionHash}`);
            }
        }
        else {
            // this is a missing import.
            // queue optimize-deps re-run.
            (_c = server._registerMissingImport) === null || _c === void 0 ? void 0 : _c.call(server, id, resolved, ssr);
        }
        return { id: resolved };
    }
}
function tryOptimizedResolve(id, server, importer) {
    const cacheDir = server.config.cacheDir;
    const depData = server._optimizeDepsMetadata;
    if (!cacheDir || !depData)
        return;
    const getOptimizedUrl = (optimizedData) => {
        return (optimizedData.file +
            `?v=${depData.browserHash}${optimizedData.needsInterop ? `&es-interop` : ``}`);
    };
    // check if id has been optimized
    const isOptimized = depData.optimized[id];
    if (isOptimized) {
        return getOptimizedUrl(isOptimized);
    }
    if (!importer)
        return;
    // further check if id is imported by nested dependency
    let resolvedSrc;
    for (const [pkgPath, optimizedData] of Object.entries(depData.optimized)) {
        // check for scenarios, e.g.
        //   pkgPath  => "my-lib > foo"
        //   id       => "foo"
        // this narrows the need to do a full resolve
        if (!pkgPath.endsWith(id))
            continue;
        // lazily initialize resolvedSrc
        if (resolvedSrc == null) {
            try {
                // this may throw errors if unable to resolve, e.g. aliased id
                resolvedSrc = normalizePath(resolveFrom(id, path__default.dirname(importer)));
            }
            catch {
                // this is best-effort only so swallow errors
                break;
            }
        }
        // match by src to correctly identify if id belongs to nested dependency
        if (optimizedData.src === resolvedSrc) {
            return getOptimizedUrl(optimizedData);
        }
    }
}
const packageCache = new Map();
function resolvePackageData(id, basedir, preserveSymlinks = false) {
    const cacheKey = id + basedir;
    if (packageCache.has(cacheKey)) {
        return packageCache.get(cacheKey);
    }
    try {
        const pkgPath = resolveFrom(`${id}/package.json`, basedir, preserveSymlinks);
        return loadPackageData(pkgPath, cacheKey);
    }
    catch (e) {
        isDebug$5 && debug$7(`${chalk__default.red(`[failed loading package.json]`)} ${id}`);
    }
}
function loadPackageData(pkgPath, cacheKey = pkgPath) {
    const data = JSON.parse(fs__default.readFileSync(pkgPath, 'utf-8'));
    const pkgDir = path__default.dirname(pkgPath);
    const { sideEffects } = data;
    let hasSideEffects;
    if (typeof sideEffects === 'boolean') {
        hasSideEffects = () => sideEffects;
    }
    else if (Array.isArray(sideEffects)) {
        hasSideEffects = pluginutils.createFilter(sideEffects, null, { resolve: pkgDir });
    }
    else {
        hasSideEffects = () => true;
    }
    const pkg = {
        dir: pkgDir,
        data,
        hasSideEffects,
        webResolvedImports: {},
        nodeResolvedImports: {},
        setResolvedCache(key, entry, targetWeb) {
            if (targetWeb) {
                pkg.webResolvedImports[key] = entry;
            }
            else {
                pkg.nodeResolvedImports[key] = entry;
            }
        },
        getResolvedCache(key, targetWeb) {
            if (targetWeb) {
                return pkg.webResolvedImports[key];
            }
            else {
                return pkg.nodeResolvedImports[key];
            }
        }
    };
    packageCache.set(cacheKey, pkg);
    return pkg;
}
function resolvePackageEntry(id, { dir, data, setResolvedCache, getResolvedCache }, options, targetWeb, preserveSymlinks = false) {
    var _a, _b;
    const cached = getResolvedCache('.', targetWeb);
    if (cached) {
        return cached;
    }
    try {
        let entryPoint;
        // resolve exports field with highest priority
        // using https://github.com/lukeed/resolve.exports
        if (data.exports) {
            entryPoint = resolveExports(data, '.', options, targetWeb);
        }
        // if exports resolved to .mjs, still resolve other fields.
        // This is because .mjs files can technically import .cjs files which would
        // make them invalid for pure ESM environments - so if other module/browser
        // fields are present, prioritize those instead.
        if (targetWeb && (!entryPoint || entryPoint.endsWith('.mjs'))) {
            // check browser field
            // https://github.com/defunctzombie/package-browser-field-spec
            const browserEntry = typeof data.browser === 'string'
                ? data.browser
                : isObject(data.browser) && data.browser['.'];
            if (browserEntry) {
                // check if the package also has a "module" field.
                if (typeof data.module === 'string' && data.module !== browserEntry) {
                    // if both are present, we may have a problem: some package points both
                    // to ESM, with "module" targeting Node.js, while some packages points
                    // "module" to browser ESM and "browser" to UMD.
                    // the heuristics here is to actually read the browser entry when
                    // possible and check for hints of UMD. If it is UMD, prefer "module"
                    // instead; Otherwise, assume it's ESM and use it.
                    const resolvedBrowserEntry = tryFsResolve(path__default.join(dir, browserEntry), options, preserveSymlinks);
                    if (resolvedBrowserEntry) {
                        const content = fs__default.readFileSync(resolvedBrowserEntry, 'utf-8');
                        if ((/typeof exports\s*==/.test(content) &&
                            /typeof module\s*==/.test(content)) ||
                            /module\.exports\s*=/.test(content)) {
                            // likely UMD or CJS(!!! e.g. firebase 7.x), prefer module
                            entryPoint = data.module;
                        }
                    }
                }
                else {
                    entryPoint = browserEntry;
                }
            }
        }
        if (!entryPoint || entryPoint.endsWith('.mjs')) {
            for (const field of options.mainFields || DEFAULT_MAIN_FIELDS) {
                if (typeof data[field] === 'string') {
                    entryPoint = data[field];
                    break;
                }
            }
        }
        entryPoint = entryPoint || data.main || 'index.js';
        // make sure we don't get scripts when looking for sass
        if (((_a = options.mainFields) === null || _a === void 0 ? void 0 : _a[0]) === 'sass' &&
            !((_b = options.extensions) === null || _b === void 0 ? void 0 : _b.includes(path__default.extname(entryPoint)))) {
            entryPoint = '';
            options.skipPackageJson = true;
        }
        // resolve object browser field in package.json
        const { browser: browserField } = data;
        if (targetWeb && isObject(browserField)) {
            entryPoint = mapWithBrowserField(entryPoint, browserField) || entryPoint;
        }
        entryPoint = path__default.join(dir, entryPoint);
        const resolvedEntryPoint = tryFsResolve(entryPoint, options, preserveSymlinks);
        if (resolvedEntryPoint) {
            isDebug$5 &&
                debug$7(`[package entry] ${chalk__default.cyan(id)} -> ${chalk__default.dim(resolvedEntryPoint)}`);
            setResolvedCache('.', resolvedEntryPoint, targetWeb);
            return resolvedEntryPoint;
        }
        else {
            packageEntryFailure(id);
        }
    }
    catch (e) {
        packageEntryFailure(id, e.message);
    }
}
function packageEntryFailure(id, details) {
    throw new Error(`Failed to resolve entry for package "${id}". ` +
        `The package may have incorrect main/module/exports specified in its package.json` +
        (details ? ': ' + details : '.'));
}
function resolveExports(pkg, key, options, targetWeb) {
    const conditions = [options.isProduction ? 'production' : 'development'];
    if (!options.isRequire) {
        conditions.push('module');
    }
    if (options.conditions) {
        conditions.push(...options.conditions);
    }
    return resolve_exports.resolve(pkg, key, {
        browser: targetWeb,
        require: options.isRequire,
        conditions
    });
}
function resolveDeepImport(id, { webResolvedImports, setResolvedCache, getResolvedCache, dir, data }, options, targetWeb, preserveSymlinks) {
    const cache = getResolvedCache(id, targetWeb);
    if (cache) {
        return cache;
    }
    let relativeId = id;
    const { exports: exportsField, browser: browserField } = data;
    // map relative based on exports data
    if (exportsField) {
        if (isObject(exportsField) && !Array.isArray(exportsField)) {
            relativeId = resolveExports(data, relativeId, options, targetWeb);
        }
        else {
            // not exposed
            relativeId = undefined;
        }
        if (!relativeId) {
            throw new Error(`Package subpath '${relativeId}' is not defined by "exports" in ` +
                `${path__default.join(dir, 'package.json')}.`);
        }
    }
    else if (targetWeb && isObject(browserField)) {
        const mapped = mapWithBrowserField(relativeId, browserField);
        if (mapped) {
            relativeId = mapped;
        }
        else if (mapped === false) {
            return (webResolvedImports[id] = browserExternalId);
        }
    }
    if (relativeId) {
        const resolved = tryFsResolve(path__default.join(dir, relativeId), options, preserveSymlinks, !exportsField, // try index only if no exports field
        targetWeb);
        if (resolved) {
            isDebug$5 &&
                debug$7(`[node/deep-import] ${chalk__default.cyan(id)} -> ${chalk__default.dim(resolved)}`);
            setResolvedCache(id, resolved, targetWeb);
            return resolved;
        }
    }
}
function tryResolveBrowserMapping(id, importer, options, isFilePath, preserveSymlinks) {
    let res;
    const pkg = importer && idToPkgMap.get(importer);
    if (pkg && isObject(pkg.data.browser)) {
        const mapId = isFilePath ? './' + slash(path__default.relative(pkg.dir, id)) : id;
        const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser);
        if (browserMappedPath) {
            const fsPath = path__default.join(pkg.dir, browserMappedPath);
            if ((res = tryFsResolve(fsPath, options, preserveSymlinks))) {
                isDebug$5 &&
                    debug$7(`[browser mapped] ${chalk__default.cyan(id)} -> ${chalk__default.dim(res)}`);
                idToPkgMap.set(res, pkg);
                return {
                    id: res,
                    moduleSideEffects: pkg.hasSideEffects(res)
                };
            }
        }
        else if (browserMappedPath === false) {
            return browserExternalId;
        }
    }
}
/**
 * given a relative path in pkg dir,
 * return a relative path in pkg dir,
 * mapped with the "map" object
 *
 * - Returning `undefined` means there is no browser mapping for this id
 * - Returning `false` means this id is explicitly externalized for browser
 */
function mapWithBrowserField(relativePathInPkgDir, map) {
    const normalizedPath = path__default.posix.normalize(relativePathInPkgDir);
    for (const key in map) {
        const normalizedKey = path__default.posix.normalize(key);
        if (normalizedPath === normalizedKey ||
            equalWithoutSuffix(normalizedPath, normalizedKey, '.js') ||
            equalWithoutSuffix(normalizedPath, normalizedKey, '/index.js')) {
            return map[key];
        }
    }
}
function equalWithoutSuffix(path, key, suffix) {
    return key.endsWith(suffix) && key.slice(0, -suffix.length) === path;
}
function getRealPath(resolved, preserveSymlinks) {
    if (!preserveSymlinks && browserExternalId !== resolved) {
        return normalizePath(fs__default.realpathSync(resolved));
    }
    return resolved;
}

const debug$6 = createDebugger('vite:ssr-external');
/**
 * Heuristics for determining whether a dependency should be externalized for
 * server-side rendering.
 *
 * TODO right now externals are imported using require(), we probably need to
 * rework this when more libraries ship native ESM distributions for Node.
 */
function resolveSSRExternal(config, knownImports, ssrExternals = new Set(), seen = new Set()) {
    var _a, _b, _c, _d;
    if (((_a = config.ssr) === null || _a === void 0 ? void 0 : _a.noExternal) === true) {
        return [];
    }
    const { root } = config;
    const pkgContent = lookupFile(root, ['package.json']);
    if (!pkgContent) {
        return [];
    }
    const pkg = JSON.parse(pkgContent);
    const importedDeps = knownImports.map(getNpmPackageName).filter(isDefined);
    const deps = unique([
        ...importedDeps,
        ...Object.keys(pkg.devDependencies || {}),
        ...Object.keys(pkg.dependencies || {})
    ]);
    const resolveOptions = {
        root,
        isProduction: false,
        isBuild: true
    };
    const depsToTrace = new Set();
    for (const id of deps) {
        if (seen.has(id)) {
            continue;
        }
        seen.add(id);
        let entry;
        let requireEntry;
        try {
            entry = (_b = tryNodeResolve(id, undefined, resolveOptions, true, undefined, true)) === null || _b === void 0 ? void 0 : _b.id;
            // normalizePath required for windows. tryNodeResolve uses normalizePath
            // which returns with '/', require.resolve returns with '\\'
            requireEntry = normalizePath(require.resolve(id, { paths: [root] }));
        }
        catch (e) {
            // resolve failed, assume include
            debug$6(`Failed to resolve entries for package "${id}"\n`, e);
            continue;
        }
        if (!entry) {
            // no esm entry but has require entry (is this even possible?)
            ssrExternals.add(id);
            continue;
        }
        if (!entry.includes('node_modules')) {
            // entry is not a node dep, possibly linked - don't externalize
            // instead, trace its dependencies.
            depsToTrace.add(id);
            continue;
        }
        if (entry !== requireEntry) {
            // has separate esm/require entry, assume require entry is cjs
            ssrExternals.add(id);
        }
        else {
            // node resolve and esm resolve resolves to the same file.
            if (!/\.m?js$/.test(entry)) {
                // entry is not js, cannot externalize
                continue;
            }
            // check if the entry is cjs
            const content = fs__default.readFileSync(entry, 'utf-8');
            if (/\bmodule\.exports\b|\bexports[.\[]|\brequire\s*\(/.test(content)) {
                ssrExternals.add(id);
            }
        }
    }
    for (const id of depsToTrace) {
        const depRoot = path__default.dirname(resolveFrom(`${id}/package.json`, root, !!config.resolve.preserveSymlinks));
        resolveSSRExternal({
            ...config,
            root: depRoot
        }, knownImports, ssrExternals, seen);
    }
    if ((_c = config.ssr) === null || _c === void 0 ? void 0 : _c.external) {
        config.ssr.external.forEach((id) => ssrExternals.add(id));
    }
    let externals = [...ssrExternals];
    if ((_d = config.ssr) === null || _d === void 0 ? void 0 : _d.noExternal) {
        const filter = pluginutils.createFilter(undefined, config.ssr.noExternal, {
            resolve: false
        });
        externals = externals.filter((id) => filter(id));
    }
    return externals.filter((id) => id !== 'vite');
}
function shouldExternalizeForSSR(id, externals) {
    const should = externals.some((e) => {
        if (id === e) {
            return true;
        }
        // deep imports, check ext before externalizing - only externalize
        // extension-less imports and explicit .js imports
        if (id.startsWith(e + '/') && (!path__default.extname(id) || id.endsWith('.js'))) {
            return true;
        }
    });
    return should;
}
function getNpmPackageName(importPath) {
    const parts = importPath.split('/');
    if (parts[0].startsWith('@')) {
        if (!parts[1])
            return null;
        return `${parts[0]}/${parts[1]}`;
    }
    else {
        return parts[0];
    }
}

function ssrManifestPlugin(config) {
    // module id => preload assets mapping
    const ssrManifest = {};
    const base = config.base;
    return {
        name: 'vite:ssr-manifest',
        generateBundle(_options, bundle) {
            for (const file in bundle) {
                const chunk = bundle[file];
                if (chunk.type === 'chunk') {
                    // links for certain entry chunks are already generated in static HTML
                    // in those cases we only need to record info for non-entry chunks
                    const cssFiles = chunk.isEntry
                        ? null
                        : chunkToEmittedCssFileMap.get(chunk);
                    const assetFiles = chunkToEmittedAssetsMap.get(chunk);
                    for (const id in chunk.modules) {
                        const normalizedId = pluginutils.normalizePath(path.relative(config.root, id));
                        const mappedChunks = ssrManifest[normalizedId] || (ssrManifest[normalizedId] = []);
                        if (!chunk.isEntry) {
                            mappedChunks.push(base + chunk.fileName);
                        }
                        if (cssFiles) {
                            cssFiles.forEach((file) => {
                                mappedChunks.push(base + file);
                            });
                        }
                        if (assetFiles) {
                            assetFiles.forEach((file) => {
                                mappedChunks.push(base + file);
                            });
                        }
                    }
                }
            }
            this.emitFile({
                fileName: 'ssr-manifest.json',
                type: 'asset',
                source: JSON.stringify(ssrManifest, null, 2)
            });
        }
    };
}

function prepareError(err) {
    // only copy the information we need and avoid serializing unnecessary
    // properties, since some errors may attach full objects (e.g. PostCSS)
    return {
        message: strip__default(err.message),
        stack: strip__default(cleanStack(err.stack || '')),
        id: err.id,
        frame: strip__default(err.frame || ''),
        plugin: err.plugin,
        pluginCode: err.pluginCode,
        loc: err.loc
    };
}
function buildErrorMessage(err, args = [], includeStack = true) {
    if (err.plugin)
        args.push(`  Plugin: ${chalk__default.magenta(err.plugin)}`);
    if (err.id)
        args.push(`  File: ${chalk__default.cyan(err.id)}`);
    if (err.frame)
        args.push(chalk__default.yellow(pad(err.frame)));
    if (includeStack && err.stack)
        args.push(pad(cleanStack(err.stack)));
    return args.join('\n');
}
function cleanStack(stack) {
    return stack
        .split(/\n/g)
        .filter((l) => /^\s*at/.test(l))
        .join('\n');
}
function errorMiddleware(server, allowNext = false) {
    // note the 4 args must be kept for connect to treat this as error middleware
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteErrorMiddleware(err, _req, res, next) {
        const msg = buildErrorMessage(err, [
            chalk__default.red(`Internal server error: ${err.message}`)
        ]);
        server.config.logger.error(msg, {
            clear: true,
            timestamp: true,
            error: err
        });
        server.ws.send({
            type: 'error',
            err: prepareError(err)
        });
        if (allowNext) {
            next();
        }
        else {
            if (err instanceof AccessRestrictedError) {
                res.statusCode = 403;
                res.write(renderErrorHTML(err.message));
                res.end();
            }
            res.statusCode = 500;
            res.end();
        }
    };
}
class AccessRestrictedError extends Error {
    constructor(msg) {
        super(msg);
    }
}
function renderErrorHTML(msg) {
    // to have syntax highlighting and autocompletion in IDE
    const html = String.raw;
    return html `
    <body>
      <h1>403 Restricted</h1>
      <p>${msg.replace(/\n/g, '<br/>')}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `;
}

/**
 * This file is refactored into TypeScript based on
 * https://github.com/preactjs/wmr/blob/main/packages/wmr/src/lib/rollup-plugin-container.js
 */
let parser = acorn__namespace.Parser.extend(acornClassFields__default, acornStaticClassFeatures__default);
async function createPluginContainer({ plugins, logger, root, build: { rollupOptions } }, watcher) {
    const isDebug = process.env.DEBUG;
    const seenResolves = {};
    const debugResolve = createDebugger('vite:resolve');
    const debugPluginResolve = createDebugger('vite:plugin-resolve', {
        onlyWhenFocused: 'vite:plugin'
    });
    const debugPluginTransform = createDebugger('vite:plugin-transform', {
        onlyWhenFocused: 'vite:plugin'
    });
    // ---------------------------------------------------------------------------
    const MODULES = new Map();
    const watchFiles = new Set();
    // get rollup version
    const rollupPkgPath = path.resolve(require.resolve('rollup'), '../../package.json');
    const minimalContext = {
        meta: {
            rollupVersion: JSON.parse(fs__default.readFileSync(rollupPkgPath, 'utf-8'))
                .version,
            watchMode: true
        }
    };
    function warnIncompatibleMethod(method, plugin) {
        logger.warn(chalk__default.cyan(`[plugin:${plugin}] `) +
            chalk__default.yellow(`context method ${chalk__default.bold(`${method}()`)} is not supported in serve mode. This plugin is likely not vite-compatible.`));
    }
    // we should create a new context for each async hook pipeline so that the
    // active plugin in that pipeline can be tracked in a concurrency-safe manner.
    // using a class to make creating new contexts more efficient
    class Context {
        constructor(initialPlugin) {
            this.meta = minimalContext.meta;
            this.ssr = false;
            this._activeId = null;
            this._activeCode = null;
            this._addedImports = null;
            this._activePlugin = initialPlugin || null;
        }
        parse(code, opts = {}) {
            return parser.parse(code, {
                sourceType: 'module',
                ecmaVersion: 2020,
                locations: true,
                ...opts
            });
        }
        async resolve(id, importer, options) {
            let skips;
            if ((options === null || options === void 0 ? void 0 : options.skipSelf) && this._activePlugin) {
                skips = new Set(this._resolveSkips);
                skips.add(this._activePlugin);
            }
            let out = await container.resolveId(id, importer, skips, this.ssr);
            if (typeof out === 'string')
                out = { id: out };
            return out;
        }
        getModuleInfo(id) {
            let mod = MODULES.get(id);
            if (mod)
                return mod.info;
            mod = {
                /** @type {import('rollup').ModuleInfo} */
                // @ts-ignore-next
                info: {}
            };
            MODULES.set(id, mod);
            return mod.info;
        }
        getModuleIds() {
            return MODULES.keys();
        }
        addWatchFile(id) {
            watchFiles.add(id);
            (this._addedImports || (this._addedImports = new Set())).add(id);
            if (watcher)
                ensureWatchedFile(watcher, id, root);
        }
        getWatchFiles() {
            return [...watchFiles];
        }
        emitFile(assetOrFile) {
            warnIncompatibleMethod(`emitFile`, this._activePlugin.name);
            return '';
        }
        setAssetSource() {
            warnIncompatibleMethod(`setAssetSource`, this._activePlugin.name);
        }
        getFileName() {
            warnIncompatibleMethod(`getFileName`, this._activePlugin.name);
            return '';
        }
        warn(e, position) {
            const err = formatError(e, position, this);
            const msg = buildErrorMessage(err, [chalk__default.yellow(`warning: ${err.message}`)], false);
            logger.warn(msg, {
                clear: true,
                timestamp: true
            });
        }
        error(e, position) {
            // error thrown here is caught by the transform middleware and passed on
            // the the error middleware.
            throw formatError(e, position, this);
        }
    }
    function formatError(e, position, ctx) {
        const err = (typeof e === 'string' ? new Error(e) : e);
        if (ctx._activePlugin)
            err.plugin = ctx._activePlugin.name;
        if (ctx._activeId && !err.id)
            err.id = ctx._activeId;
        if (ctx._activeCode) {
            err.pluginCode = ctx._activeCode;
            const pos = position != null
                ? position
                : err.pos != null
                    ? err.pos
                    : // some rollup plugins, e.g. json, sets position instead of pos
                        err.position;
            if (pos != null) {
                let errLocation;
                try {
                    errLocation = numberToPos(ctx._activeCode, pos);
                }
                catch (err2) {
                    logger.error(chalk__default.red(`Error in error handler:\n${err2.stack || err2.message}\n`), 
                    // print extra newline to separate the two errors
                    { error: err2 });
                    throw err;
                }
                err.loc = err.loc || {
                    file: err.id,
                    ...errLocation
                };
                err.frame = err.frame || generateCodeFrame(ctx._activeCode, pos);
            }
            else if (err.loc) {
                // css preprocessors may report errors in an included file
                if (!err.frame) {
                    let code = ctx._activeCode;
                    if (err.loc.file) {
                        err.id = normalizePath(err.loc.file);
                        try {
                            code = fs__default.readFileSync(err.loc.file, 'utf-8');
                        }
                        catch { }
                    }
                    err.frame = generateCodeFrame(code, err.loc);
                }
            }
            else if (err.line && err.column) {
                err.loc = {
                    file: err.id,
                    line: err.line,
                    column: err.column
                };
                err.frame = err.frame || generateCodeFrame(ctx._activeCode, err.loc);
            }
        }
        return err;
    }
    class TransformContext extends Context {
        constructor(filename, code, inMap) {
            super();
            this.originalSourcemap = null;
            this.sourcemapChain = [];
            this.combinedMap = null;
            this.filename = filename;
            this.originalCode = code;
            if (inMap) {
                this.sourcemapChain.push(inMap);
            }
        }
        _getCombinedSourcemap(createIfNull = false) {
            let combinedMap = this.combinedMap;
            for (let m of this.sourcemapChain) {
                if (typeof m === 'string')
                    m = JSON.parse(m);
                if (!('version' in m)) {
                    // empty, nullified source map
                    combinedMap = this.combinedMap = null;
                    this.sourcemapChain.length = 0;
                    break;
                }
                if (!combinedMap) {
                    combinedMap = m;
                }
                else {
                    combinedMap = combineSourcemaps(this.filename, [
                        {
                            ...m,
                            sourcesContent: combinedMap.sourcesContent
                        },
                        combinedMap
                    ]);
                }
            }
            if (!combinedMap) {
                return createIfNull
                    ? new MagicString__default(this.originalCode).generateMap({
                        includeContent: true,
                        hires: true,
                        source: this.filename
                    })
                    : null;
            }
            if (combinedMap !== this.combinedMap) {
                this.combinedMap = combinedMap;
                this.sourcemapChain.length = 0;
            }
            return this.combinedMap;
        }
        getCombinedSourcemap() {
            return this._getCombinedSourcemap(true);
        }
    }
    let closed = false;
    const container = {
        options: await (async () => {
            let options = rollupOptions;
            for (const plugin of plugins) {
                if (!plugin.options)
                    continue;
                options =
                    (await plugin.options.call(minimalContext, options)) || options;
            }
            if (options.acornInjectPlugins) {
                parser = acorn__namespace.Parser.extend(...[acornClassFields__default, acornStaticClassFeatures__default].concat(options.acornInjectPlugins));
            }
            return {
                acorn: acorn__namespace,
                acornInjectPlugins: [],
                ...options
            };
        })(),
        async buildStart() {
            await Promise.all(plugins.map((plugin) => {
                if (plugin.buildStart) {
                    return plugin.buildStart.call(new Context(plugin), container.options);
                }
            }));
        },
        async resolveId(rawId, importer = path.join(root, 'index.html'), skips, ssr) {
            const ctx = new Context();
            ctx.ssr = !!ssr;
            ctx._resolveSkips = skips;
            const resolveStart = isDebug ? Date.now() : 0;
            let id = null;
            const partial = {};
            for (const plugin of plugins) {
                if (!plugin.resolveId)
                    continue;
                if (skips === null || skips === void 0 ? void 0 : skips.has(plugin))
                    continue;
                ctx._activePlugin = plugin;
                const pluginResolveStart = isDebug ? Date.now() : 0;
                const result = await plugin.resolveId.call(ctx, rawId, importer, {}, ssr);
                if (!result)
                    continue;
                if (typeof result === 'string') {
                    id = result;
                }
                else {
                    id = result.id;
                    Object.assign(partial, result);
                }
                isDebug &&
                    debugPluginResolve(timeFrom(pluginResolveStart), plugin.name, prettifyUrl(id, root));
                // resolveId() is hookFirst - first non-null result is returned.
                break;
            }
            if (isDebug && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
                const key = rawId + id;
                // avoid spamming
                if (!seenResolves[key]) {
                    seenResolves[key] = true;
                    debugResolve(`${timeFrom(resolveStart)} ${chalk__default.cyan(rawId)} -> ${chalk__default.dim(id)}`);
                }
            }
            if (id) {
                partial.id = isExternalUrl(id) ? id : normalizePath(id);
                return partial;
            }
            else {
                return null;
            }
        },
        async load(id, ssr) {
            const ctx = new Context();
            ctx.ssr = !!ssr;
            for (const plugin of plugins) {
                if (!plugin.load)
                    continue;
                ctx._activePlugin = plugin;
                const result = await plugin.load.call(ctx, id, ssr);
                if (result != null) {
                    return result;
                }
            }
            return null;
        },
        async transform(code, id, inMap, ssr) {
            const ctx = new TransformContext(id, code, inMap);
            ctx.ssr = !!ssr;
            for (const plugin of plugins) {
                if (!plugin.transform)
                    continue;
                ctx._activePlugin = plugin;
                ctx._activeId = id;
                ctx._activeCode = code;
                const start = isDebug ? Date.now() : 0;
                let result;
                try {
                    result = await plugin.transform.call(ctx, code, id, ssr);
                }
                catch (e) {
                    ctx.error(e);
                }
                if (!result)
                    continue;
                isDebug &&
                    debugPluginTransform(timeFrom(start), plugin.name, prettifyUrl(id, root));
                if (isObject(result)) {
                    code = result.code || '';
                    if (result.map)
                        ctx.sourcemapChain.push(result.map);
                }
                else {
                    code = result;
                }
            }
            return {
                code,
                map: ctx._getCombinedSourcemap()
            };
        },
        async close() {
            if (closed)
                return;
            const ctx = new Context();
            await Promise.all(plugins.map((p) => p.buildEnd && p.buildEnd.call(ctx)));
            await Promise.all(plugins.map((p) => p.closeBundle && p.closeBundle.call(ctx)));
            closed = true;
        }
    };
    return container;
}

const debug$5 = createDebugger('vite:deps');
const htmlTypesRE = /\.(html|vue|svelte)$/;
// A simple regex to detect import sources. This is only used on
// <script lang="ts"> blocks in vue (setup only) or svelte files, since
// seemingly unused imports are dropped by esbuild when transpiling TS which
// prevents it from crawling further.
// We can't use es-module-lexer because it can't handle TS, and don't want to
// use Acorn because it's slow. Luckily this doesn't have to be bullet proof
// since even missed imports can be caught at runtime, and false positives will
// simply be ignored.
const importsRE = /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from\s*)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm;
async function scanImports(config) {
    var _a, _b, _c, _d;
    const s = Date.now();
    let entries = [];
    const explicitEntryPatterns = (_a = config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.entries;
    const buildInput = (_b = config.build.rollupOptions) === null || _b === void 0 ? void 0 : _b.input;
    if (explicitEntryPatterns) {
        entries = await globEntries(explicitEntryPatterns, config);
    }
    else if (buildInput) {
        const resolvePath = (p) => path__default.resolve(config.root, p);
        if (typeof buildInput === 'string') {
            entries = [resolvePath(buildInput)];
        }
        else if (Array.isArray(buildInput)) {
            entries = buildInput.map(resolvePath);
        }
        else if (isObject(buildInput)) {
            entries = Object.values(buildInput).map(resolvePath);
        }
        else {
            throw new Error('invalid rollupOptions.input value.');
        }
    }
    else {
        entries = await globEntries('**/*.html', config);
    }
    // Non-supported entry file types and virtual files should not be scanned for
    // dependencies.
    entries = entries.filter((entry) => (JS_TYPES_RE.test(entry) || htmlTypesRE.test(entry)) &&
        fs__default.existsSync(entry));
    if (!entries.length) {
        config.logger.warn('Could not determine entry point from rollupOptions or html files. Skipping dependency pre-bundling.');
        return { deps: {}, missing: {} };
    }
    else {
        debug$5(`Crawling dependencies using entries:\n  ${entries.join('\n  ')}`);
    }
    const deps = {};
    const missing = {};
    const container = await createPluginContainer(config);
    const plugin = esbuildScanPlugin(config, container, deps, missing, entries);
    const { plugins = [], ...esbuildOptions } = (_d = (_c = config.optimizeDeps) === null || _c === void 0 ? void 0 : _c.esbuildOptions) !== null && _d !== void 0 ? _d : {};
    await Promise.all(entries.map((entry) => esbuild.build({
        absWorkingDir: process.cwd(),
        write: false,
        entryPoints: [entry],
        bundle: true,
        format: 'esm',
        logLevel: 'error',
        plugins: [...plugins, plugin],
        ...esbuildOptions
    })));
    debug$5(`Scan completed in ${Date.now() - s}ms:`, deps);
    return {
        deps,
        missing
    };
}
function globEntries(pattern, config) {
    return glob__default(pattern, {
        cwd: config.root,
        ignore: [
            '**/node_modules/**',
            `**/${config.build.outDir}/**`,
            `**/__tests__/**`
        ],
        absolute: true
    });
}
const scriptModuleRE = /(<script\b[^>]*type\s*=\s*(?:"module"|'module')[^>]*>)(.*?)<\/script>/gims;
const scriptRE = /(<script\b(?:\s[^>]*>|>))(.*?)<\/script>/gims;
const commentRE = /<!--(.|[\r\n])*?-->/;
const srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
const typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
const langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
function esbuildScanPlugin(config, container, depImports, missing, entries) {
    var _a, _b;
    const seen = new Map();
    const resolve = async (id, importer) => {
        const key = id + (importer && path__default.dirname(importer));
        if (seen.has(key)) {
            return seen.get(key);
        }
        const resolved = await container.resolveId(id, importer && normalizePath(importer));
        const res = resolved === null || resolved === void 0 ? void 0 : resolved.id;
        seen.set(key, res);
        return res;
    };
    const include = (_a = config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.include;
    const exclude = [
        ...(((_b = config.optimizeDeps) === null || _b === void 0 ? void 0 : _b.exclude) || []),
        '@vite/client',
        '@vite/env'
    ];
    const externalUnlessEntry = ({ path }) => ({
        path,
        external: !entries.includes(path)
    });
    return {
        name: 'vite:dep-scan',
        setup(build) {
            // external urls
            build.onResolve({ filter: externalRE }, ({ path }) => ({
                path,
                external: true
            }));
            // data urls
            build.onResolve({ filter: dataUrlRE }, ({ path }) => ({
                path,
                external: true
            }));
            // html types: extract script contents -----------------------------------
            build.onResolve({ filter: htmlTypesRE }, async ({ path, importer }) => {
                return {
                    path: await resolve(path, importer),
                    namespace: 'html'
                };
            });
            // extract scripts inside HTML-like files and treat it as a js module
            build.onLoad({ filter: htmlTypesRE, namespace: 'html' }, async ({ path }) => {
                let raw = fs__default.readFileSync(path, 'utf-8');
                // Avoid matching the content of the comment
                raw = raw.replace(commentRE, '<!---->');
                const isHtml = path.endsWith('.html');
                const regex = isHtml ? scriptModuleRE : scriptRE;
                regex.lastIndex = 0;
                let js = '';
                let loader = 'js';
                let match;
                while ((match = regex.exec(raw))) {
                    const [, openTag, content] = match;
                    const srcMatch = openTag.match(srcRE);
                    const typeMatch = openTag.match(typeRE);
                    const langMatch = openTag.match(langRE);
                    const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
                    const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
                    // skip type="application/ld+json" and other non-JS types
                    if (type &&
                        !(type.includes('javascript') ||
                            type.includes('ecmascript') ||
                            type === 'module')) {
                        continue;
                    }
                    if (lang === 'ts' || lang === 'tsx' || lang === 'jsx') {
                        loader = lang;
                    }
                    if (srcMatch) {
                        const src = srcMatch[1] || srcMatch[2] || srcMatch[3];
                        js += `import ${JSON.stringify(src)}\n`;
                    }
                    else if (content.trim()) {
                        js += content + '\n';
                    }
                }
                // empty singleline & multiline comments to avoid matching comments
                const code = js
                    .replace(multilineCommentsRE, '/* */')
                    .replace(singlelineCommentsRE, '');
                if (loader.startsWith('ts') &&
                    (path.endsWith('.svelte') ||
                        (path.endsWith('.vue') && /<script\s+setup/.test(raw)))) {
                    // when using TS + (Vue + <script setup>) or Svelte, imports may seem
                    // unused to esbuild and dropped in the build output, which prevents
                    // esbuild from crawling further.
                    // the solution is to add `import 'x'` for every source to force
                    // esbuild to keep crawling due to potential side effects.
                    let m;
                    while ((m = importsRE.exec(code)) != null) {
                        // This is necessary to avoid infinite loops with zero-width matches
                        if (m.index === importsRE.lastIndex) {
                            importsRE.lastIndex++;
                        }
                        js += `\nimport ${m[1]}`;
                    }
                }
                if (!code.includes(`export default`)) {
                    js += `\nexport default {}`;
                }
                if (code.includes('import.meta.glob')) {
                    return {
                        // transformGlob already transforms to js
                        loader: 'js',
                        contents: await transformGlob(js, path, config.root, loader)
                    };
                }
                return {
                    loader,
                    contents: js
                };
            });
            // bare imports: record and externalize ----------------------------------
            build.onResolve({
                // avoid matching windows volume
                filter: /^[\w@][^:]/
            }, async ({ path: id, importer }) => {
                if (exclude === null || exclude === void 0 ? void 0 : exclude.some((e) => e === id || id.startsWith(e + '/'))) {
                    return externalUnlessEntry({ path: id });
                }
                if (depImports[id]) {
                    return externalUnlessEntry({ path: id });
                }
                const resolved = await resolve(id, importer);
                if (resolved) {
                    if (shouldExternalizeDep(resolved, id)) {
                        return externalUnlessEntry({ path: id });
                    }
                    if (resolved.includes('node_modules') || (include === null || include === void 0 ? void 0 : include.includes(id))) {
                        // dependency or forced included, externalize and stop crawling
                        if (OPTIMIZABLE_ENTRY_RE.test(resolved)) {
                            depImports[id] = resolved;
                        }
                        return externalUnlessEntry({ path: id });
                    }
                    else {
                        const namespace = htmlTypesRE.test(resolved) ? 'html' : undefined;
                        // linked package, keep crawling
                        return {
                            path: path__default.resolve(resolved),
                            namespace
                        };
                    }
                }
                else {
                    missing[id] = normalizePath(importer);
                }
            });
            // Externalized file types -----------------------------------------------
            // these are done on raw ids using esbuild's native regex filter so it
            // should be faster than doing it in the catch-all via js
            // they are done after the bare import resolve because a package name
            // may end with these extensions
            // css & json
            build.onResolve({
                filter: /\.(css|less|sass|scss|styl|stylus|pcss|postcss|json)$/
            }, externalUnlessEntry);
            // known asset types
            build.onResolve({
                filter: new RegExp(`\\.(${KNOWN_ASSET_TYPES.join('|')})$`)
            }, externalUnlessEntry);
            // known vite query types: ?worker, ?raw
            build.onResolve({ filter: SPECIAL_QUERY_RE }, ({ path }) => ({
                path,
                external: true
            }));
            // catch all -------------------------------------------------------------
            build.onResolve({
                filter: /.*/
            }, async ({ path: id, importer }) => {
                // use vite resolver to support urls and omitted extensions
                const resolved = await resolve(id, importer);
                if (resolved) {
                    if (shouldExternalizeDep(resolved, id)) {
                        return externalUnlessEntry({ path: id });
                    }
                    const namespace = htmlTypesRE.test(resolved) ? 'html' : undefined;
                    return {
                        path: path__default.resolve(cleanUrl(resolved)),
                        namespace
                    };
                }
                else {
                    // resolve failed... probably unsupported type
                    return externalUnlessEntry({ path: id });
                }
            });
            // for jsx/tsx, we need to access the content and check for
            // presence of import.meta.glob, since it results in import relationships
            // but isn't crawled by esbuild.
            build.onLoad({ filter: JS_TYPES_RE }, ({ path: id }) => {
                let ext = path__default.extname(id).slice(1);
                if (ext === 'mjs')
                    ext = 'js';
                let contents = fs__default.readFileSync(id, 'utf-8');
                if (ext.endsWith('x') && config.esbuild && config.esbuild.jsxInject) {
                    contents = config.esbuild.jsxInject + `\n` + contents;
                }
                if (contents.includes('import.meta.glob')) {
                    return transformGlob(contents, id, config.root, ext).then((contents) => ({
                        loader: ext,
                        contents
                    }));
                }
                return {
                    loader: ext,
                    contents
                };
            });
        }
    };
}
async function transformGlob(source, importer, root, loader) {
    // transform the content first since es-module-lexer can't handle non-js
    if (loader !== 'js') {
        source = (await esbuild.transform(source, { loader })).code;
    }
    await esModuleLexer.init;
    const imports = esModuleLexer.parse(source)[0];
    const s = new MagicString__default(source);
    for (let index = 0; index < imports.length; index++) {
        const { s: start, e: end, ss: expStart } = imports[index];
        const url = source.slice(start, end);
        if (url !== 'import.meta')
            continue;
        if (source.slice(end, end + 5) !== '.glob')
            continue;
        const { importsString, exp, endIndex } = await transformImportGlob(source, start, normalizePath(importer), index, root);
        s.prepend(importsString);
        s.overwrite(expStart, endIndex, exp);
    }
    return s.toString();
}
function shouldExternalizeDep(resolvedId, rawId) {
    // not a valid file path
    if (!path__default.isAbsolute(resolvedId)) {
        return true;
    }
    // virtual id
    if (resolvedId === rawId || resolvedId.includes('\0')) {
        return true;
    }
    // resolved is not a scannable type
    if (!JS_TYPES_RE.test(resolvedId) && !htmlTypesRE.test(resolvedId)) {
        return true;
    }
    return false;
}

/**
 * Convert `new URL('./foo.png', import.meta.url)` to its resolved built URL
 *
 * Supports tempalte string with dynamic segments:
 * ```
 * new URL(`./dir/${name}.png`, import.meta.url)
 * // transformed to
 * import.meta.globEager('./dir/**.png')[`./dir/${name}.png`].default
 * ```
 */
function assetImportMetaUrlPlugin(config) {
    return {
        name: 'vite:asset-import-meta-url',
        async transform(code, id, ssr) {
            if (code.includes('new URL') && code.includes(`import.meta.url`)) {
                const importMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\)/g;
                const noCommentsCode = code
                    .replace(multilineCommentsRE, (m) => ' '.repeat(m.length))
                    .replace(singlelineCommentsRE, (m) => ' '.repeat(m.length));
                let s = null;
                let match;
                while ((match = importMetaUrlRE.exec(noCommentsCode))) {
                    const { 0: exp, 1: rawUrl, index } = match;
                    if (ssr) {
                        this.error(`\`new URL(url, import.meta.url)\` is not supported in SSR.`, index);
                    }
                    if (!s)
                        s = new MagicString__default(code);
                    // potential dynamic template string
                    if (rawUrl[0] === '`' && /\$\{/.test(rawUrl)) {
                        const ast = this.parse(rawUrl);
                        const templateLiteral = ast.body[0].expression;
                        if (templateLiteral.expressions.length) {
                            const pattern = buildGlobPattern(templateLiteral);
                            // Note: native import.meta.url is not supported in the baseline
                            // target so we use window.location here -
                            s.overwrite(index, index + exp.length, `new URL(import.meta.globEagerDefault(${JSON.stringify(pattern)})[${rawUrl}], window.location)`);
                            continue;
                        }
                    }
                    const url = rawUrl.slice(1, -1);
                    const file = path__default.resolve(path__default.dirname(id), url);
                    const builtUrl = await fileToUrl(file, config, this);
                    s.overwrite(index, index + exp.length, `new URL(${JSON.stringify(builtUrl)}, window.location)`);
                }
                if (s) {
                    return {
                        code: s.toString(),
                        map: config.build.sourcemap ? s.generateMap({ hires: true }) : null
                    };
                }
            }
            return null;
        }
    };
}
function buildGlobPattern(ast) {
    let pattern = '';
    let lastElementIndex = -1;
    for (const exp of ast.expressions) {
        for (let i = lastElementIndex + 1; i < ast.quasis.length; i++) {
            const el = ast.quasis[i];
            if (el.end < exp.start) {
                pattern += el.value.raw;
                lastElementIndex = i;
            }
        }
        pattern += '**';
    }
    for (let i = lastElementIndex + 1; i < ast.quasis.length; i++) {
        pattern += ast.quasis[i].value.raw;
    }
    return pattern;
}

/**
 * A plugin to provide build load fallback for arbitrary request with queries.
 */
function loadFallbackPlugin() {
    return {
        name: 'vite:load-fallback',
        async load(id) {
            try {
                return fs.promises.readFile(cleanUrl(id), 'utf-8');
            }
            catch (e) {
                return fs.promises.readFile(id, 'utf-8');
            }
        }
    };
}

function resolveBuildOptions(raw) {
    const resolved = {
        target: 'modules',
        polyfillModulePreload: true,
        outDir: 'dist',
        assetsDir: 'assets',
        assetsInlineLimit: 4096,
        cssCodeSplit: !(raw === null || raw === void 0 ? void 0 : raw.lib),
        sourcemap: false,
        rollupOptions: {},
        commonjsOptions: {
            include: [/node_modules/],
            extensions: ['.js', '.cjs'],
            ...raw === null || raw === void 0 ? void 0 : raw.commonjsOptions
        },
        dynamicImportVarsOptions: {
            warnOnError: true,
            exclude: [/node_modules/],
            ...raw === null || raw === void 0 ? void 0 : raw.dynamicImportVarsOptions
        },
        minify: (raw === null || raw === void 0 ? void 0 : raw.ssr) ? false : 'terser',
        terserOptions: {},
        write: true,
        emptyOutDir: null,
        manifest: false,
        lib: false,
        ssr: false,
        ssrManifest: false,
        reportCompressedSize: true,
        // brotliSize: true,
        chunkSizeWarningLimit: 500,
        watch: null,
        ...raw
    };
    // handle special build targets
    if (resolved.target === 'modules') {
        // Support browserslist
        // "defaults and supports es6-module and supports es6-module-dynamic-import",
        resolved.target = [
            'es2019',
            'edge88',
            'firefox78',
            'chrome87',
            'safari13.1'
        ];
    }
    else if (resolved.target === 'esnext' && resolved.minify === 'terser') {
        // esnext + terser: limit to es2019 so it can be minified by terser
        resolved.target = 'es2019';
    }
    // normalize false string into actual false
    if (resolved.minify === 'false') {
        resolved.minify = false;
    }
    return resolved;
}
function resolveBuildPlugins(config) {
    const options = config.build;
    return {
        pre: [
            buildHtmlPlugin(config),
            commonjsPlugin__default(options.commonjsOptions),
            dataURIPlugin(),
            dynamicImportVars__default(options.dynamicImportVarsOptions),
            assetImportMetaUrlPlugin(config),
            ...(options.rollupOptions.plugins
                ? options.rollupOptions.plugins.filter((p) => !!p)
                : [])
        ],
        post: [
            buildImportAnalysisPlugin(config),
            buildEsbuildPlugin(config),
            ...(options.minify && options.minify !== 'esbuild'
                ? [terserPlugin(options.terserOptions)]
                : []),
            ...(options.manifest ? [manifestPlugin(config)] : []),
            ...(options.ssrManifest ? [ssrManifestPlugin(config)] : []),
            buildReporterPlugin(config),
            loadFallbackPlugin()
        ]
    };
}
/**
 * Track parallel build calls and only stop the esbuild service when all
 * builds are done. (#1098)
 */
let parallelCallCounts = 0;
// we use a separate counter to track since the call may error before the
// bundle is even pushed.
const parallelBuilds = [];
/**
 * Bundles the app for production.
 * Returns a Promise containing the build result.
 */
async function build(inlineConfig = {}) {
    parallelCallCounts++;
    try {
        return await doBuild(inlineConfig);
    }
    finally {
        parallelCallCounts--;
        if (parallelCallCounts <= 0) {
            await Promise.all(parallelBuilds.map((bundle) => bundle.close()));
            parallelBuilds.length = 0;
        }
    }
}
async function doBuild(inlineConfig = {}) {
    var _a, _b, _c, _d;
    const config = await resolveConfig(inlineConfig, 'build', 'production');
    const options = config.build;
    const ssr = !!options.ssr;
    const libOptions = options.lib;
    config.logger.info(chalk__default.cyan(`vite v${require('vite/package.json').version} ${chalk__default.green(`building ${ssr ? `SSR bundle ` : ``}for ${config.mode}...`)}`));
    const resolve = (p) => path__default.resolve(config.root, p);
    const input = libOptions
        ? resolve(libOptions.entry)
        : typeof options.ssr === 'string'
            ? resolve(options.ssr)
            : ((_a = options.rollupOptions) === null || _a === void 0 ? void 0 : _a.input) || resolve('index.html');
    if (ssr && typeof input === 'string' && input.endsWith('.html')) {
        throw new Error(`rollupOptions.input should not be an html file when building for SSR. ` +
            `Please specify a dedicated SSR entry.`);
    }
    const outDir = resolve(options.outDir);
    // inject ssr arg to plugin load/transform hooks
    const plugins = (ssr ? config.plugins.map((p) => injectSsrFlagToHooks(p)) : config.plugins);
    // inject ssrExternal if present
    const userExternal = (_b = options.rollupOptions) === null || _b === void 0 ? void 0 : _b.external;
    let external = userExternal;
    if (ssr) {
        // see if we have cached deps data available
        let knownImports;
        if (config.cacheDir) {
            const dataPath = path__default.join(config.cacheDir, '_metadata.json');
            try {
                const data = JSON.parse(fs__default.readFileSync(dataPath, 'utf-8'));
                knownImports = Object.keys(data.optimized);
            }
            catch (e) { }
        }
        if (!knownImports) {
            // no dev deps optimization data, do a fresh scan
            knownImports = Object.keys((await scanImports(config)).deps);
        }
        external = resolveExternal(resolveSSRExternal(config, knownImports), userExternal);
    }
    const rollup = require('rollup');
    const rollupOptions = {
        input,
        preserveEntrySignatures: ssr
            ? 'allow-extension'
            : libOptions
                ? 'strict'
                : false,
        ...options.rollupOptions,
        plugins,
        external,
        onwarn(warning, warn) {
            onRollupWarning(warning, warn, config);
        }
    };
    const outputBuildError = (e) => {
        let msg = chalk__default.red((e.plugin ? `[${e.plugin}] ` : '') + e.message);
        if (e.id) {
            msg += `\nfile: ${chalk__default.cyan(e.id + (e.loc ? `:${e.loc.line}:${e.loc.column}` : ''))}`;
        }
        if (e.frame) {
            msg += `\n` + chalk__default.yellow(e.frame);
        }
        config.logger.error(msg, { error: e });
    };
    try {
        const buildOutputOptions = (output = {}) => {
            return {
                dir: outDir,
                format: ssr ? 'cjs' : 'es',
                exports: ssr ? 'named' : 'auto',
                sourcemap: options.sourcemap,
                name: libOptions ? libOptions.name : undefined,
                entryFileNames: ssr
                    ? `[name].js`
                    : libOptions
                        ? resolveLibFilename(libOptions, output.format || 'es', config.root)
                        : path__default.posix.join(options.assetsDir, `[name].[hash].js`),
                chunkFileNames: libOptions
                    ? `[name].js`
                    : path__default.posix.join(options.assetsDir, `[name].[hash].js`),
                assetFileNames: libOptions
                    ? `[name].[ext]`
                    : path__default.posix.join(options.assetsDir, `[name].[hash].[ext]`),
                // #764 add `Symbol.toStringTag` when build es module into cjs chunk
                // #1048 add `Symbol.toStringTag` for module default export
                namespaceToStringTag: true,
                inlineDynamicImports: ssr && typeof input === 'string',
                manualChunks: !ssr &&
                    !libOptions &&
                    (output === null || output === void 0 ? void 0 : output.format) !== 'umd' &&
                    (output === null || output === void 0 ? void 0 : output.format) !== 'iife'
                    ? createMoveToVendorChunkFn()
                    : undefined,
                ...output
            };
        };
        // resolve lib mode outputs
        const outputs = resolveBuildOutputs((_c = options.rollupOptions) === null || _c === void 0 ? void 0 : _c.output, libOptions, config.logger);
        // watch file changes with rollup
        if (config.build.watch) {
            config.logger.info(chalk__default.cyanBright(`\nwatching for file changes...`));
            const output = [];
            if (Array.isArray(outputs)) {
                for (const resolvedOutput of outputs) {
                    output.push(buildOutputOptions(resolvedOutput));
                }
            }
            else {
                output.push(buildOutputOptions(outputs));
            }
            const watcherOptions = config.build.watch;
            const watcher = rollup.watch({
                ...rollupOptions,
                output,
                watch: {
                    ...watcherOptions,
                    chokidar: {
                        ignored: [
                            '**/node_modules/**',
                            '**/.git/**',
                            ...(((_d = watcherOptions === null || watcherOptions === void 0 ? void 0 : watcherOptions.chokidar) === null || _d === void 0 ? void 0 : _d.ignored) || [])
                        ],
                        ignoreInitial: true,
                        ignorePermissionErrors: true,
                        ...watcherOptions.chokidar
                    }
                }
            });
            watcher.on('event', (event) => {
                if (event.code === 'BUNDLE_START') {
                    config.logger.info(chalk__default.cyanBright(`\nbuild started...`));
                    if (options.write) {
                        prepareOutDir(outDir, options.emptyOutDir, config);
                    }
                }
                else if (event.code === 'BUNDLE_END') {
                    event.result.close();
                    config.logger.info(chalk__default.cyanBright(`built in ${event.duration}ms.`));
                }
                else if (event.code === 'ERROR') {
                    outputBuildError(event.error);
                }
            });
            // stop watching
            watcher.close();
            return watcher;
        }
        // write or generate files with rollup
        const bundle = await rollup.rollup(rollupOptions);
        parallelBuilds.push(bundle);
        const generate = (output = {}) => {
            return bundle[options.write ? 'write' : 'generate'](buildOutputOptions(output));
        };
        if (options.write) {
            prepareOutDir(outDir, options.emptyOutDir, config);
        }
        if (Array.isArray(outputs)) {
            const res = [];
            for (const output of outputs) {
                res.push(await generate(output));
            }
            return res;
        }
        else {
            return await generate(outputs);
        }
    }
    catch (e) {
        outputBuildError(e);
        throw e;
    }
}
function prepareOutDir(outDir, emptyOutDir, config) {
    if (fs__default.existsSync(outDir)) {
        if (emptyOutDir == null &&
            !normalizePath(outDir).startsWith(config.root + '/')) {
            // warn if outDir is outside of root
            config.logger.warn(chalk__default.yellow(`\n${chalk__default.bold(`(!)`)} outDir ${chalk__default.white.dim(outDir)} is not inside project root and will not be emptied.\n` +
                `Use --emptyOutDir to override.\n`));
        }
        else if (emptyOutDir !== false) {
            emptyDir(outDir, ['.git']);
        }
    }
    if (config.publicDir && fs__default.existsSync(config.publicDir)) {
        copyDir(config.publicDir, outDir);
    }
}
function getPkgName(root) {
    const { name } = JSON.parse(lookupFile(root, ['package.json']) || `{}`);
    return (name === null || name === void 0 ? void 0 : name.startsWith('@')) ? name.split('/')[1] : name;
}
function createMoveToVendorChunkFn(config) {
    const cache = new Map();
    return (id, { getModuleInfo }) => {
        if (id.includes('node_modules') &&
            !isCSSRequest(id) &&
            staticImportedByEntry(id, getModuleInfo, cache)) {
            return 'vendor';
        }
    };
}
function staticImportedByEntry(id, getModuleInfo, cache, importStack = []) {
    if (cache.has(id)) {
        return cache.get(id);
    }
    if (importStack.includes(id)) {
        // circular deps!
        cache.set(id, false);
        return false;
    }
    const mod = getModuleInfo(id);
    if (!mod) {
        cache.set(id, false);
        return false;
    }
    if (mod.isEntry) {
        cache.set(id, true);
        return true;
    }
    const someImporterIs = mod.importers.some((importer) => staticImportedByEntry(importer, getModuleInfo, cache, importStack.concat(id)));
    cache.set(id, someImporterIs);
    return someImporterIs;
}
function resolveLibFilename(libOptions, format, root) {
    if (typeof libOptions.fileName === 'function') {
        return libOptions.fileName(format);
    }
    const name = libOptions.fileName || getPkgName(root);
    if (!name)
        throw new Error('Name in package.json is required if option "build.lib.fileName" is not provided.');
    return `${name}.${format}.js`;
}
function resolveBuildOutputs(outputs, libOptions, logger) {
    if (libOptions) {
        const formats = libOptions.formats || ['es', 'umd'];
        if ((formats.includes('umd') || formats.includes('iife')) &&
            !libOptions.name) {
            throw new Error(`Option "build.lib.name" is required when output formats ` +
                `include "umd" or "iife".`);
        }
        if (!outputs) {
            return formats.map((format) => ({ format }));
        }
        else if (!Array.isArray(outputs)) {
            return formats.map((format) => ({ ...outputs, format }));
        }
        else if (libOptions.formats) {
            // user explicitly specifying own output array
            logger.warn(chalk__default.yellow(`"build.lib.formats" will be ignored because ` +
                `"build.rollupOptions.output" is already an array format`));
        }
    }
    return outputs;
}
const warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`];
const dynamicImportWarningIgnoreList = [
    `Unsupported expression`,
    `statically analyzed`
];
function onRollupWarning(warning, warn, config) {
    var _a;
    if (warning.code === 'UNRESOLVED_IMPORT') {
        const id = warning.source;
        const importer = warning.importer;
        // throw unless it's commonjs external...
        if (!importer || !/\?commonjs-external$/.test(importer)) {
            throw new Error(`[vite]: Rollup failed to resolve import "${id}" from "${importer}".\n` +
                `This is most likely unintended because it can break your application at runtime.\n` +
                `If you do want to externalize this module explicitly add it to\n` +
                `\`build.rollupOptions.external\``);
        }
    }
    if (warning.plugin === 'rollup-plugin-dynamic-import-variables' &&
        dynamicImportWarningIgnoreList.some((msg) => warning.message.includes(msg))) {
        return;
    }
    if (!warningIgnoreList.includes(warning.code)) {
        const userOnWarn = (_a = config.build.rollupOptions) === null || _a === void 0 ? void 0 : _a.onwarn;
        if (userOnWarn) {
            userOnWarn(warning, warn);
        }
        else if (warning.code === 'PLUGIN_WARNING') {
            config.logger.warn(`${chalk__default.bold.yellow(`[plugin:${warning.plugin}]`)} ${chalk__default.yellow(warning.message)}`);
        }
        else {
            warn(warning);
        }
    }
}
function resolveExternal(ssrExternals, user) {
    return ((id, parentId, isResolved) => {
        if (shouldExternalizeForSSR(id, ssrExternals)) {
            return true;
        }
        if (user) {
            if (typeof user === 'function') {
                return user(id, parentId, isResolved);
            }
            else if (Array.isArray(user)) {
                return user.some((test) => isExternal(id, test));
            }
            else {
                return isExternal(id, user);
            }
        }
    });
}
function isExternal(id, test) {
    if (typeof test === 'string') {
        return id === test;
    }
    else {
        return test.test(id);
    }
}
function injectSsrFlagToHooks(p) {
    const { resolveId, load, transform } = p;
    return {
        ...p,
        resolveId: wrapSsrHook(resolveId),
        load: wrapSsrHook(load),
        transform: wrapSsrHook(transform)
    };
}
function wrapSsrHook(fn) {
    if (!fn)
        return;
    return function (...args) {
        return fn.call(this, ...args, true);
    };
}

var build$1 = {
    __proto__: null,
    resolveBuildOptions: resolveBuildOptions,
    resolveBuildPlugins: resolveBuildPlugins,
    build: build,
    resolveLibFilename: resolveLibFilename,
    onRollupWarning: onRollupWarning
};

async function resolveHttpServer({ proxy }, app, httpsOptions) {
    if (!httpsOptions) {
        return require('http').createServer(app);
    }
    if (proxy) {
        // #484 fallback to http1 when proxy is needed.
        return require('https').createServer(httpsOptions, app);
    }
    else {
        return require('http2').createSecureServer({
            ...httpsOptions,
            allowHTTP1: true
        }, app);
    }
}
async function resolveHttpsConfig(config) {
    if (!config.server.https)
        return undefined;
    const httpsOption = isObject(config.server.https) ? config.server.https : {};
    const { ca, cert, key, pfx } = httpsOption;
    Object.assign(httpsOption, {
        ca: readFileIfExists(ca),
        cert: readFileIfExists(cert),
        key: readFileIfExists(key),
        pfx: readFileIfExists(pfx)
    });
    if (!httpsOption.key || !httpsOption.cert) {
        httpsOption.cert = httpsOption.key = await getCertificate(config);
    }
    return httpsOption;
}
function readFileIfExists(value) {
    if (typeof value === 'string') {
        try {
            return fs__default.readFileSync(path__default.resolve(value));
        }
        catch (e) {
            return value;
        }
    }
    return value;
}
/**
 * https://github.com/webpack/webpack-dev-server/blob/master/lib/utils/createCertificate.js
 *
 * Copyright JS Foundation and other contributors
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/webpack/webpack-dev-server/blob/master/LICENSE
 */
async function createCertificate() {
    const { generate } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('selfsigned')); });
    const pems = generate(null, {
        algorithm: 'sha256',
        days: 30,
        keySize: 2048,
        extensions: [
            // {
            //   name: 'basicConstraints',
            //   cA: true,
            // },
            {
                name: 'keyUsage',
                keyCertSign: true,
                digitalSignature: true,
                nonRepudiation: true,
                keyEncipherment: true,
                dataEncipherment: true
            },
            {
                name: 'extKeyUsage',
                serverAuth: true,
                clientAuth: true,
                codeSigning: true,
                timeStamping: true
            },
            {
                name: 'subjectAltName',
                altNames: [
                    {
                        // type 2 is DNS
                        type: 2,
                        value: 'localhost'
                    },
                    {
                        type: 2,
                        value: 'localhost.localdomain'
                    },
                    {
                        type: 2,
                        value: 'lvh.me'
                    },
                    {
                        type: 2,
                        value: '*.lvh.me'
                    },
                    {
                        type: 2,
                        value: '[::1]'
                    },
                    {
                        // type 7 is IP
                        type: 7,
                        ip: '127.0.0.1'
                    },
                    {
                        type: 7,
                        ip: 'fe80::1'
                    }
                ]
            }
        ]
    });
    return pems.private + pems.cert;
}
async function getCertificate(config) {
    if (!config.cacheDir)
        return await createCertificate();
    const cachePath = path__default.join(config.cacheDir, '_cert.pem');
    try {
        const [stat, content] = await Promise.all([
            fs.promises.stat(cachePath),
            fs.promises.readFile(cachePath, 'utf8')
        ]);
        if (Date.now() - stat.ctime.valueOf() > 30 * 24 * 60 * 60 * 1000) {
            throw new Error('cache is outdated.');
        }
        return content;
    }
    catch {
        const content = await createCertificate();
        fs.promises
            .mkdir(config.cacheDir, { recursive: true })
            .then(() => fs.promises.writeFile(cachePath, content))
            .catch(() => { });
        return content;
    }
}
async function httpServerStart(httpServer, serverOptions) {
    return new Promise((resolve, reject) => {
        let { port, strictPort, host, logger } = serverOptions;
        const onError = (e) => {
            if (e.code === 'EADDRINUSE') {
                if (strictPort) {
                    httpServer.removeListener('error', onError);
                    reject(new Error(`Port ${port} is already in use`));
                }
                else {
                    logger.info(`Port ${port} is in use, trying another one...`);
                    httpServer.listen(++port, host);
                }
            }
            else {
                httpServer.removeListener('error', onError);
                reject(e);
            }
        };
        httpServer.on('error', onError);
        httpServer.listen(port, host, () => {
            httpServer.removeListener('error', onError);
            resolve(port);
        });
    });
}

const HMR_HEADER = 'vite-hmr';
function createWebSocketServer(server, config, httpsOptions) {
    let wss;
    let httpsServer = undefined;
    const hmr = isObject(config.server.hmr) && config.server.hmr;
    const wsServer = (hmr && hmr.server) || server;
    if (wsServer) {
        wss = new WebSocket__default.Server({ noServer: true });
        wsServer.on('upgrade', (req, socket, head) => {
            if (req.headers['sec-websocket-protocol'] === HMR_HEADER) {
                wss.handleUpgrade(req, socket, head, (ws) => {
                    wss.emit('connection', ws, req);
                });
            }
        });
    }
    else {
        const websocketServerOptions = {};
        const port = (hmr && hmr.port) || 24678;
        if (httpsOptions) {
            // if we're serving the middlewares over https, the ws library doesn't support automatically creating an https server, so we need to do it ourselves
            // create an inline https server and mount the websocket server to it
            httpsServer = https.createServer(httpsOptions, (req, res) => {
                const statusCode = 426;
                const body = http.STATUS_CODES[statusCode];
                if (!body)
                    throw new Error(`No body text found for the ${statusCode} status code`);
                res.writeHead(statusCode, {
                    'Content-Length': body.length,
                    'Content-Type': 'text/plain'
                });
                res.end(body);
            });
            httpsServer.listen(port);
            websocketServerOptions.server = httpsServer;
        }
        else {
            // we don't need to serve over https, just let ws handle its own server
            websocketServerOptions.port = port;
        }
        // vite dev server in middleware mode
        wss = new WebSocket__default.Server(websocketServerOptions);
    }
    wss.on('connection', (socket) => {
        socket.send(JSON.stringify({ type: 'connected' }));
        if (bufferedError) {
            socket.send(JSON.stringify(bufferedError));
            bufferedError = null;
        }
    });
    wss.on('error', (e) => {
        if (e.code !== 'EADDRINUSE') {
            config.logger.error(chalk__default.red(`WebSocket server error:\n${e.stack || e.message}`), { error: e });
        }
    });
    // On page reloads, if a file fails to compile and returns 500, the server
    // sends the error payload before the client connection is established.
    // If we have no open clients, buffer the error and send it to the next
    // connected client.
    let bufferedError = null;
    return {
        send(payload) {
            if (payload.type === 'error' && !wss.clients.size) {
                bufferedError = payload;
                return;
            }
            const stringified = JSON.stringify(payload);
            wss.clients.forEach((client) => {
                if (client.readyState === WebSocket__default.OPEN) {
                    client.send(stringified);
                }
            });
        },
        close() {
            return new Promise((resolve, reject) => {
                wss.close((err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        if (httpsServer) {
                            httpsServer.close((err) => {
                                if (err) {
                                    reject(err);
                                }
                                else {
                                    resolve();
                                }
                            });
                        }
                        else {
                            resolve();
                        }
                    }
                });
            });
        }
    };
}

// this middleware is only active when (config.base !== '/')
function baseMiddleware({ config }) {
    const base = config.base;
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteBaseMiddleware(req, res, next) {
        var _a;
        const url$1 = req.url;
        const parsed = url.parse(url$1);
        const path = parsed.pathname || '/';
        if (path.startsWith(base)) {
            // rewrite url to remove base.. this ensures that other middleware does
            // not need to consider base being prepended or not
            req.url = url$1.replace(base, '/');
            return next();
        }
        // skip redirect and error fallback on middleware mode, #4057
        if (config.server.middlewareMode) {
            return next();
        }
        if (path === '/' || path === '/index.html') {
            // redirect root visit to based url
            res.writeHead(302, {
                Location: base
            });
            res.end();
            return;
        }
        else if ((_a = req.headers.accept) === null || _a === void 0 ? void 0 : _a.includes('text/html')) {
            // non-based page visit
            const redirectPath = base + url$1.slice(1);
            res.writeHead(404, {
                'Content-Type': 'text/html'
            });
            res.end(`The server is configured with a public base URL of ${base} - ` +
                `did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
            return;
        }
        next();
    };
}

const debug$4 = createDebugger('vite:proxy');
function proxyMiddleware(httpServer, config) {
    const options = config.server.proxy;
    // lazy require only when proxy is used
    const proxies = {};
    Object.keys(options).forEach((context) => {
        let opts = options[context];
        if (typeof opts === 'string') {
            opts = { target: opts, changeOrigin: true };
        }
        const proxy = httpProxy__default.createProxyServer(opts);
        proxy.on('error', (err) => {
            config.logger.error(`${chalk__default.red(`http proxy error:`)}\n${err.stack}`, {
                timestamp: true,
                error: err
            });
        });
        if (opts.configure) {
            opts.configure(proxy, opts);
        }
        // clone before saving because http-proxy mutates the options
        proxies[context] = [proxy, { ...opts }];
    });
    if (httpServer) {
        httpServer.on('upgrade', (req, socket, head) => {
            var _a;
            const url = req.url;
            for (const context in proxies) {
                if (doesProxyContextMatchUrl(context, url)) {
                    const [proxy, opts] = proxies[context];
                    if ((opts.ws || ((_a = opts.target) === null || _a === void 0 ? void 0 : _a.toString().startsWith('ws:'))) &&
                        req.headers['sec-websocket-protocol'] !== HMR_HEADER) {
                        if (opts.rewrite) {
                            req.url = opts.rewrite(url);
                        }
                        debug$4(`${req.url} -> ws ${opts.target}`);
                        proxy.ws(req, socket, head);
                        return;
                    }
                }
            }
        });
    }
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteProxyMiddleware(req, res, next) {
        const url = req.url;
        for (const context in proxies) {
            if (doesProxyContextMatchUrl(context, url)) {
                const [proxy, opts] = proxies[context];
                const options = {};
                if (opts.bypass) {
                    const bypassResult = opts.bypass(req, res, opts);
                    if (typeof bypassResult === 'string') {
                        req.url = bypassResult;
                        debug$4(`bypass: ${req.url} -> ${bypassResult}`);
                        return next();
                    }
                    else if (isObject(bypassResult)) {
                        Object.assign(options, bypassResult);
                        debug$4(`bypass: ${req.url} use modified options: %O`, options);
                        return next();
                    }
                    else if (bypassResult === false) {
                        debug$4(`bypass: ${req.url} -> 404`);
                        return res.end(404);
                    }
                }
                debug$4(`${req.url} -> ${opts.target || opts.forward}`);
                if (opts.rewrite) {
                    req.url = opts.rewrite(req.url);
                }
                proxy.web(req, res, options);
                return;
            }
        }
        next();
    };
}
function doesProxyContextMatchUrl(context, url) {
    return ((context.startsWith('^') && new RegExp(context).test(url)) ||
        url.startsWith(context));
}

function spaFallbackMiddleware(root) {
    const historySpaFallbackMiddleware = history__default({
        logger: createDebugger('vite:spa-fallback'),
        // support /dir/ without explicit index.html
        rewrites: [
            {
                from: /\/$/,
                to({ parsedUrl }) {
                    const rewritten = parsedUrl.pathname + 'index.html';
                    if (fs__default.existsSync(path__default.join(root, rewritten))) {
                        return rewritten;
                    }
                    else {
                        return `/index.html`;
                    }
                }
            }
        ]
    });
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteSpaFallbackMiddleware(req, res, next) {
        return historySpaFallbackMiddleware(req, res, next);
    };
}

const isDebug$4 = process.env.DEBUG;
const alias = {
    js: 'application/javascript',
    css: 'text/css',
    html: 'text/html',
    json: 'application/json'
};
function send(req, res, content, type, etag = getEtag__default(content, { weak: true }), cacheControl = 'no-cache', map) {
    if (req.headers['if-none-match'] === etag) {
        res.statusCode = 304;
        return res.end();
    }
    res.setHeader('Content-Type', alias[type] || type);
    res.setHeader('Cache-Control', cacheControl);
    res.setHeader('Etag', etag);
    // inject source map reference
    if (map && map.mappings) {
        if (isDebug$4) {
            content += `\n/*${JSON.stringify(map, null, 2).replace(/\*\//g, '*\\/')}*/\n`;
        }
        content += genSourceMapString(map);
    }
    res.statusCode = 200;
    return res.end(content);
}
function genSourceMapString(map) {
    if (typeof map !== 'string') {
        map = JSON.stringify(map);
    }
    return `\n//# sourceMappingURL=data:application/json;base64,${Buffer.from(map).toString('base64')}`;
}

const ssrModuleExportsKey = `__vite_ssr_exports__`;
const ssrImportKey = `__vite_ssr_import__`;
const ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
const ssrExportAllKey = `__vite_ssr_exportAll__`;
const ssrImportMetaKey = `__vite_ssr_import_meta__`;
async function ssrTransform(code, inMap, url) {
    const s = new MagicString__default(code);
    const ast = parser.parse(code, {
        sourceType: 'module',
        ecmaVersion: 2021,
        locations: true
    });
    let uid = 0;
    const deps = new Set();
    const dynamicDeps = new Set();
    const idToImportMap = new Map();
    const declaredConst = new Set();
    function defineImport(node, source) {
        deps.add(source);
        const importId = `__vite_ssr_import_${uid++}__`;
        s.appendLeft(node.start, `const ${importId} = await ${ssrImportKey}(${JSON.stringify(source)});\n`);
        return importId;
    }
    function defineExport(position, name, local = name) {
        s.appendRight(position, `\nObject.defineProperty(${ssrModuleExportsKey}, "${name}", ` +
            `{ enumerable: true, configurable: true, get(){ return ${local} }});`);
    }
    // 1. check all import statements and record id -> importName map
    for (const node of ast.body) {
        // import foo from 'foo' --> foo -> __import_foo__.default
        // import { baz } from 'foo' --> baz -> __import_foo__.baz
        // import * as ok from 'foo' --> ok -> __import_foo__
        if (node.type === 'ImportDeclaration') {
            const importId = defineImport(node, node.source.value);
            for (const spec of node.specifiers) {
                if (spec.type === 'ImportSpecifier') {
                    idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
                }
                else if (spec.type === 'ImportDefaultSpecifier') {
                    idToImportMap.set(spec.local.name, `${importId}.default`);
                }
                else {
                    // namespace specifier
                    idToImportMap.set(spec.local.name, importId);
                }
            }
            s.remove(node.start, node.end);
        }
    }
    // 2. check all export statements and define exports
    for (const node of ast.body) {
        // named exports
        if (node.type === 'ExportNamedDeclaration') {
            if (node.declaration) {
                if (node.declaration.type === 'FunctionDeclaration' ||
                    node.declaration.type === 'ClassDeclaration') {
                    // export function foo() {}
                    defineExport(node.end, node.declaration.id.name);
                }
                else {
                    // export const foo = 1, bar = 2
                    for (const declaration of node.declaration.declarations) {
                        const names = periscopic.extract_names(declaration.id);
                        for (const name of names) {
                            defineExport(node.end, name);
                        }
                    }
                }
                s.remove(node.start, node.declaration.start);
            }
            else {
                s.remove(node.start, node.end);
                if (node.source) {
                    // export { foo, bar } from './foo'
                    const importId = defineImport(node, node.source.value);
                    for (const spec of node.specifiers) {
                        defineExport(node.end, spec.exported.name, `${importId}.${spec.local.name}`);
                    }
                }
                else {
                    // export { foo, bar }
                    for (const spec of node.specifiers) {
                        const local = spec.local.name;
                        const binding = idToImportMap.get(local);
                        defineExport(node.end, spec.exported.name, binding || local);
                    }
                }
            }
        }
        // default export
        if (node.type === 'ExportDefaultDeclaration') {
            if ('id' in node.declaration && node.declaration.id) {
                // named hoistable/class exports
                // export default function foo() {}
                // export default class A {}
                const { name } = node.declaration.id;
                s.remove(node.start, node.start + 15 /* 'export default '.length */);
                s.append(`\nObject.defineProperty(${ssrModuleExportsKey}, "default", ` +
                    `{ enumerable: true, value: ${name} });`);
            }
            else {
                // anonymous default exports
                s.overwrite(node.start, node.start + 14 /* 'export default'.length */, `${ssrModuleExportsKey}.default =`);
            }
        }
        // export * from './foo'
        if (node.type === 'ExportAllDeclaration') {
            if (node.exported) {
                const importId = defineImport(node, node.source.value);
                s.remove(node.start, node.end);
                defineExport(node.end, node.exported.name, `${importId}`);
            }
            else {
                const importId = defineImport(node, node.source.value);
                s.remove(node.start, node.end);
                s.appendLeft(node.end, `${ssrExportAllKey}(${importId});`);
            }
        }
    }
    // 3. convert references to import bindings & import.meta references
    walk(ast, {
        onIdentifier(id, parent, parentStack) {
            const binding = idToImportMap.get(id.name);
            if (!binding) {
                return;
            }
            if (isStaticProperty(parent) && parent.shorthand) {
                // let binding used in a property shorthand
                // { foo } -> { foo: __import_x__.foo }
                // skip for destructuring patterns
                if (!parent.inPattern ||
                    isInDestructuringAssignment(parent, parentStack)) {
                    s.appendLeft(id.end, `: ${binding}`);
                }
            }
            else if (parent.type === 'ClassDeclaration' &&
                id === parent.superClass) {
                if (!declaredConst.has(id.name)) {
                    declaredConst.add(id.name);
                    // locate the top-most node containing the class declaration
                    const topNode = parentStack[1];
                    s.prependRight(topNode.start, `const ${id.name} = ${binding};\n`);
                }
            }
            else {
                s.overwrite(id.start, id.end, binding);
            }
        },
        onImportMeta(node) {
            s.overwrite(node.start, node.end, ssrImportMetaKey);
        },
        onDynamicImport(node) {
            s.overwrite(node.start, node.start + 6, ssrDynamicImportKey);
            if (node.type === 'ImportExpression' && node.source.type === 'Literal') {
                dynamicDeps.add(node.source.value);
            }
        }
    });
    let map = s.generateMap({ hires: true });
    if (inMap && inMap.mappings && inMap.sources.length > 0) {
        map = combineSourcemaps(url, [
            {
                ...map,
                sources: inMap.sources,
                sourcesContent: inMap.sourcesContent
            },
            inMap
        ]);
    }
    else {
        map.sources = [url];
        map.sourcesContent = [code];
    }
    return {
        code: s.toString(),
        map,
        deps: [...deps],
        dynamicDeps: [...dynamicDeps]
    };
}
/**
 * Same logic from \@vue/compiler-core & \@vue/compiler-sfc
 * Except this is using acorn AST
 */
function walk(root, { onIdentifier, onImportMeta, onDynamicImport }) {
    const parentStack = [];
    const scope = Object.create(null);
    const scopeMap = new WeakMap();
    const setScope = (node, name) => {
        let scopeIds = scopeMap.get(node);
        if (scopeIds && scopeIds.has(name)) {
            return;
        }
        if (name in scope) {
            scope[name]++;
        }
        else {
            scope[name] = 1;
        }
        if (!scopeIds) {
            scopeIds = new Set();
            scopeMap.set(node, scopeIds);
        }
        scopeIds.add(name);
    };
    estreeWalker.walk(root, {
        enter(node, parent) {
            if (node.type === 'ImportDeclaration') {
                return this.skip();
            }
            parent && parentStack.push(parent);
            if (node.type === 'MetaProperty' && node.meta.name === 'import') {
                onImportMeta(node);
            }
            else if (node.type === 'ImportExpression') {
                onDynamicImport(node);
            }
            if (node.type === 'Identifier') {
                if (!scope[node.name] && isRefIdentifier(node, parent, parentStack)) {
                    onIdentifier(node, parent, parentStack);
                }
            }
            else if (isFunction(node)) {
                // walk function expressions and add its arguments to known identifiers
                // so that we don't prefix them
                node.params.forEach((p) => estreeWalker.walk(p, {
                    enter(child, parent) {
                        if (child.type === 'Identifier' &&
                            // do not record as scope variable if is a destructuring key
                            !isStaticPropertyKey(child, parent) &&
                            // do not record if this is a default value
                            // assignment of a destructuring variable
                            !(parent &&
                                parent.type === 'AssignmentPattern' &&
                                parent.right === child)) {
                            setScope(node, child.name);
                        }
                    }
                }));
            }
            else if (node.type === 'Property' && parent.type === 'ObjectPattern') {
                node.inPattern = true;
            }
            else if (node.type === 'VariableDeclarator') {
                const parentFunction = findParentFunction(parentStack);
                if (parentFunction) {
                    if (node.id.type === 'ObjectPattern') {
                        node.id.properties.forEach((property) => {
                            if (property.type === 'RestElement') {
                                setScope(parentFunction, property.argument.name);
                            }
                            else {
                                setScope(parentFunction, property.value.name);
                            }
                        });
                    }
                    else {
                        setScope(parentFunction, node.id.name);
                    }
                }
            }
        },
        leave(node, parent) {
            parent && parentStack.pop();
            const scopeIds = scopeMap.get(node);
            if (scopeIds) {
                scopeIds.forEach((id) => {
                    scope[id]--;
                    if (scope[id] === 0) {
                        delete scope[id];
                    }
                });
            }
        }
    });
}
function isRefIdentifier(id, parent, parentStack) {
    // declaration id
    if (parent.type === 'CatchClause' ||
        ((parent.type === 'VariableDeclarator' ||
            parent.type === 'ClassDeclaration') &&
            parent.id === id)) {
        return false;
    }
    if (isFunction(parent)) {
        // function declaration/expression id
        if (parent.id === id) {
            return false;
        }
        // params list
        if (parent.params.includes(id)) {
            return false;
        }
    }
    // class method name
    if (parent.type === 'MethodDefinition') {
        return false;
    }
    // property key
    // this also covers object destructuring pattern
    if (isStaticPropertyKey(id, parent) || parent.inPattern) {
        return false;
    }
    // non-assignment array destructuring pattern
    if (parent.type === 'ArrayPattern' &&
        !isInDestructuringAssignment(parent, parentStack)) {
        return false;
    }
    // member expression property
    if (parent.type === 'MemberExpression' &&
        parent.property === id &&
        !parent.computed) {
        return false;
    }
    if (parent.type === 'ExportSpecifier') {
        return false;
    }
    // is a special keyword but parsed as identifier
    if (id.name === 'arguments') {
        return false;
    }
    return true;
}
const isStaticProperty = (node) => node && node.type === 'Property' && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
function isFunction(node) {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
}
function findParentFunction(parentStack) {
    for (let i = parentStack.length - 1; i >= 0; i--) {
        const node = parentStack[i];
        if (isFunction(node)) {
            return node;
        }
    }
}
function isInDestructuringAssignment(parent, parentStack) {
    if (parent &&
        (parent.type === 'Property' || parent.type === 'ArrayPattern')) {
        let i = parentStack.length;
        while (i--) {
            const p = parentStack[i];
            if (p.type === 'AssignmentExpression') {
                return true;
            }
            else if (p.type !== 'Property' && !p.type.endsWith('Pattern')) {
                break;
            }
        }
    }
    return false;
}

const isDebug$3 = !!process.env.DEBUG;
const debug$3 = createDebugger('vite:sourcemap', {
    onlyWhenFocused: true
});
async function injectSourcesContent(map, file, logger) {
    let sourceRoot;
    try {
        // The source root is undefined for virtual modules and permission errors.
        sourceRoot = await fs.promises.realpath(path__default.resolve(path__default.dirname(file), map.sourceRoot || ''));
    }
    catch { }
    const missingSources = [];
    map.sourcesContent = await Promise.all(map.sources.map((sourcePath) => {
        if (sourcePath) {
            sourcePath = decodeURI(sourcePath);
            if (sourceRoot) {
                sourcePath = path__default.resolve(sourceRoot, sourcePath);
            }
            return fs.promises.readFile(sourcePath, 'utf-8').catch(() => {
                missingSources.push(sourcePath);
                return null;
            });
        }
        return null;
    }));
    // Use this command…
    //    DEBUG="vite:sourcemap" vite build
    // …to log the missing sources.
    if (missingSources.length) {
        logger.warnOnce(`Sourcemap for "${file}" points to missing source files`);
        isDebug$3 && debug$3(`Missing sources:\n  ` + missingSources.join(`\n  `));
    }
}

const sirvOptions = {
    dev: true,
    etag: true,
    extensions: [],
    setHeaders(res, pathname) {
        // Matches js, jsx, ts, tsx.
        // The reason this is done, is that the .ts file extension is reserved
        // for the MIME type video/mp2t. In almost all cases, we can expect
        // these files to be TypeScript files, and for Vite to serve them with
        // this Content-Type.
        if (/\.[tj]sx?$/.test(pathname)) {
            res.setHeader('Content-Type', 'application/javascript');
        }
    }
};
function servePublicMiddleware(dir) {
    const serve = sirv__default(dir, sirvOptions);
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteServePublicMiddleware(req, res, next) {
        // skip import request and internal requests `/@fs/ /@vite-client` etc...
        if (isImportRequest(req.url) || isInternalRequest(req.url)) {
            return next();
        }
        serve(req, res, next);
    };
}
function serveStaticMiddleware(dir, config) {
    const serve = sirv__default(dir, sirvOptions);
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteServeStaticMiddleware(req, res, next) {
        // only serve the file if it's not an html request
        // so that html requests can fallthrough to our html middleware for
        // special processing
        // also skip internal requests `/@fs/ /@vite-client` etc...
        if (path__default.extname(cleanUrl(req.url)) === '.html' ||
            isInternalRequest(req.url)) {
            return next();
        }
        const url = decodeURI(req.url);
        // apply aliases to static requests as well
        let redirected;
        for (const { find, replacement } of config.resolve.alias) {
            const matches = typeof find === 'string' ? url.startsWith(find) : find.test(url);
            if (matches) {
                redirected = url.replace(find, replacement);
                break;
            }
        }
        if (redirected) {
            // dir is pre-normalized to posix style
            if (redirected.startsWith(dir)) {
                redirected = redirected.slice(dir.length);
            }
            req.url = redirected;
        }
        serve(req, res, next);
    };
}
function serveRawFsMiddleware(server) {
    const serveFromRoot = sirv__default('/', sirvOptions);
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteServeRawFsMiddleware(req, res, next) {
        let url = req.url;
        // In some cases (e.g. linked monorepos) files outside of root will
        // reference assets that are also out of served root. In such cases
        // the paths are rewritten to `/@fs/` prefixed paths and must be served by
        // searching based from fs root.
        if (url.startsWith(FS_PREFIX)) {
            // restrict files outside of `fs.allow`
            ensureServingAccess(slash(path__default.resolve(fsPathFromId(url))), server);
            url = url.slice(FS_PREFIX.length);
            if (isWindows)
                url = url.replace(/^[A-Z]:/i, '');
            req.url = url;
            serveFromRoot(req, res, next);
        }
        else {
            next();
        }
    };
}
function isFileServingAllowed(url, server) {
    // explicitly disabled
    if (server.config.server.fs.strict === false)
        return true;
    const file = ensureLeadingSlash(normalizePath(cleanUrl(url)));
    if (server.moduleGraph.safeModulesPath.has(file))
        return true;
    if (server.config.server.fs.allow.some((i) => file.startsWith(i + '/')))
        return true;
    if (!server.config.server.fs.strict) {
        server.config.logger.warnOnce(`Unrestricted file system access to "${url}"`);
        server.config.logger.warnOnce(`For security concerns, accessing files outside of serving allow list will ` +
            `be restricted by default in the future version of Vite. ` +
            `Refer to https://vitejs.dev/config/#server-fs-allow for more details.`);
        return true;
    }
    return false;
}
function ensureServingAccess(url, server) {
    if (!isFileServingAllowed(url, server)) {
        const allow = server.config.server.fs.allow;
        throw new AccessRestrictedError(`The request url "${url}" is outside of Vite serving allow list:

${allow.map((i) => `- ${i}`).join('\n')}

Refer to docs https://vitejs.dev/config/#server-fs-allow for configurations and more details.`);
    }
}

const debugLoad = createDebugger('vite:load');
const debugTransform = createDebugger('vite:transform');
const debugCache$1 = createDebugger('vite:cache');
const isDebug$2 = !!process.env.DEBUG;
async function transformRequest(url, server, options = {}) {
    var _a, _b;
    const { config, pluginContainer, moduleGraph, watcher } = server;
    url = removeTimestampQuery(url);
    const { root, logger } = config;
    const prettyUrl = isDebug$2 ? prettifyUrl(url, root) : '';
    const ssr = !!options.ssr;
    // check if we have a fresh cache
    const module = await moduleGraph.getModuleByUrl(url);
    const cached = module && (ssr ? module.ssrTransformResult : module.transformResult);
    if (cached) {
        isDebug$2 && debugCache$1(`[memory] ${prettyUrl}`);
        return cached;
    }
    // resolve
    const id = ((_a = (await pluginContainer.resolveId(url))) === null || _a === void 0 ? void 0 : _a.id) || url;
    const file = cleanUrl(id);
    let code = null;
    let map = null;
    // load
    const loadStart = isDebug$2 ? Date.now() : 0;
    const loadResult = await pluginContainer.load(id, ssr);
    if (loadResult == null) {
        // if this is an html request and there is no load result, skip ahead to
        // SPA fallback.
        if (options.html && !id.endsWith('.html')) {
            return null;
        }
        // try fallback loading it from fs as string
        // if the file is a binary, there should be a plugin that already loaded it
        // as string
        // only try the fallback if access is allowed, skip for out of root url
        // like /service-worker.js or /api/users
        if (options.ssr || isFileServingAllowed(file, server)) {
            try {
                code = await fs.promises.readFile(file, 'utf-8');
                isDebug$2 && debugLoad(`${timeFrom(loadStart)} [fs] ${prettyUrl}`);
            }
            catch (e) {
                if (e.code !== 'ENOENT') {
                    throw e;
                }
            }
        }
        if (code) {
            try {
                map = (_b = (convertSourceMap__namespace.fromSource(code) ||
                    convertSourceMap__namespace.fromMapFileSource(code, path__default.dirname(file)))) === null || _b === void 0 ? void 0 : _b.toObject();
            }
            catch (e) {
                logger.warn(`Failed to load source map for ${url}.`, {
                    timestamp: true
                });
            }
        }
    }
    else {
        isDebug$2 && debugLoad(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`);
        if (isObject(loadResult)) {
            code = loadResult.code;
            map = loadResult.map;
        }
        else {
            code = loadResult;
        }
    }
    if (code == null) {
        if (checkPublicFile(url, config)) {
            throw new Error(`Failed to load url ${url} (resolved id: ${id}). ` +
                `This file is in /public and will be copied as-is during build without ` +
                `going through the plugin transforms, and therefore should not be ` +
                `imported from source code. It can only be referenced via HTML tags.`);
        }
        else {
            return null;
        }
    }
    // ensure module in graph after successful load
    const mod = await moduleGraph.ensureEntryFromUrl(url);
    ensureWatchedFile(watcher, mod.file, root);
    // transform
    const transformStart = isDebug$2 ? Date.now() : 0;
    const transformResult = await pluginContainer.transform(code, id, map, ssr);
    if (transformResult == null ||
        (isObject(transformResult) && transformResult.code == null)) {
        // no transform applied, keep code as-is
        isDebug$2 &&
            debugTransform(timeFrom(transformStart) + chalk__default.dim(` [skipped] ${prettyUrl}`));
    }
    else {
        isDebug$2 && debugTransform(`${timeFrom(transformStart)} ${prettyUrl}`);
        code = transformResult.code;
        map = transformResult.map;
    }
    if (map && mod.file) {
        map = (typeof map === 'string' ? JSON.parse(map) : map);
        if (map.mappings && !map.sourcesContent) {
            await injectSourcesContent(map, mod.file, logger);
        }
    }
    if (ssr) {
        return (mod.ssrTransformResult = await ssrTransform(code, map, url));
    }
    else {
        return (mod.transformResult = {
            code,
            map,
            etag: getEtag__default(code, { weak: true })
        });
    }
}

/**
 * Time (ms) Vite has to full-reload the page before returning
 * an empty response.
 */
const NEW_DEPENDENCY_BUILD_TIMEOUT = 1000;
const debugCache = createDebugger('vite:cache');
const isDebug$1 = !!process.env.DEBUG;
const knownIgnoreList = new Set(['/', '/favicon.ico']);
function transformMiddleware(server) {
    const { config: { root, logger, cacheDir }, moduleGraph } = server;
    // determine the url prefix of files inside cache directory
    let cacheDirPrefix;
    if (cacheDir) {
        const cacheDirRelative = normalizePath(path__default.relative(root, cacheDir));
        if (cacheDirRelative.startsWith('../')) {
            // if the cache directory is outside root, the url prefix would be something
            // like '/@fs/absolute/path/to/node_modules/.vite'
            cacheDirPrefix = `/@fs/${normalizePath(cacheDir).replace(/^\//, '')}`;
        }
        else {
            // if the cache directory is inside root, the url prefix would be something
            // like '/node_modules/.vite'
            cacheDirPrefix = `/${cacheDirRelative}`;
        }
    }
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return async function viteTransformMiddleware(req, res, next) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (req.method !== 'GET' || knownIgnoreList.has(req.url)) {
            return next();
        }
        if (server._pendingReload &&
            // always allow vite client requests so that it can trigger page reload
            !((_a = req.url) === null || _a === void 0 ? void 0 : _a.startsWith(CLIENT_PUBLIC_PATH)) &&
            !((_b = req.url) === null || _b === void 0 ? void 0 : _b.includes('vite/dist/client'))) {
            // missing dep pending reload, hold request until reload happens
            server._pendingReload.then(() => 
            // If the refresh has not happened after timeout, Vite considers
            // something unexpected has happened. In this case, Vite
            // returns an empty response that will error.
            setTimeout(() => {
                // Don't do anything if response has already been sent
                if (res.writableEnded)
                    return;
                // status code request timeout
                res.statusCode = 408;
                res.end(`<h1>[vite] Something unexpected happened while optimizing "${req.url}"<h1>` +
                    `<p>The current page should have reloaded by now</p>`);
            }, NEW_DEPENDENCY_BUILD_TIMEOUT));
            return;
        }
        let url = decodeURI(removeTimestampQuery(req.url)).replace(NULL_BYTE_PLACEHOLDER, '\0');
        const withoutQuery = cleanUrl(url);
        try {
            const isSourceMap = withoutQuery.endsWith('.map');
            // since we generate source map references, handle those requests here
            if (isSourceMap) {
                const originalUrl = url.replace(/\.map($|\?)/, '$1');
                const map = (_d = (_c = (await moduleGraph.getModuleByUrl(originalUrl))) === null || _c === void 0 ? void 0 : _c.transformResult) === null || _d === void 0 ? void 0 : _d.map;
                if (map) {
                    return send(req, res, JSON.stringify(map), 'json');
                }
                else {
                    return next();
                }
            }
            // check if public dir is inside root dir
            const publicDir = normalizePath(server.config.publicDir);
            const rootDir = normalizePath(server.config.root);
            if (publicDir.startsWith(rootDir)) {
                const publicPath = `${publicDir.slice(rootDir.length)}/`;
                // warn explicit public paths
                if (url.startsWith(publicPath)) {
                    logger.warn(chalk__default.yellow(`files in the public directory are served at the root path.\n` +
                        `Instead of ${chalk__default.cyan(url)}, use ${chalk__default.cyan(url.replace(publicPath, '/'))}.`));
                }
            }
            if (isJSRequest(url) ||
                isImportRequest(url) ||
                isCSSRequest(url) ||
                isHTMLProxy(url)) {
                // strip ?import
                url = removeImportQuery(url);
                // Strip valid id prefix. This is prepended to resolved Ids that are
                // not valid browser import specifiers by the importAnalysis plugin.
                url = unwrapId(url);
                // for CSS, we need to differentiate between normal CSS requests and
                // imports
                if (isCSSRequest(url) &&
                    !isDirectRequest(url) &&
                    ((_e = req.headers.accept) === null || _e === void 0 ? void 0 : _e.includes('text/css'))) {
                    url = injectQuery(url, 'direct');
                }
                // check if we can return 304 early
                const ifNoneMatch = req.headers['if-none-match'];
                if (ifNoneMatch &&
                    ((_g = (_f = (await moduleGraph.getModuleByUrl(url))) === null || _f === void 0 ? void 0 : _f.transformResult) === null || _g === void 0 ? void 0 : _g.etag) ===
                        ifNoneMatch) {
                    isDebug$1 && debugCache(`[304] ${prettifyUrl(url, root)}`);
                    res.statusCode = 304;
                    return res.end();
                }
                // resolve, load and transform using the plugin container
                const result = await transformRequest(url, server, {
                    html: (_h = req.headers.accept) === null || _h === void 0 ? void 0 : _h.includes('text/html')
                });
                if (result) {
                    const type = isDirectCSSRequest(url) ? 'css' : 'js';
                    const isDep = DEP_VERSION_RE.test(url) ||
                        (cacheDirPrefix && url.startsWith(cacheDirPrefix));
                    return send(req, res, result.code, type, result.etag, 
                    // allow browser to cache npm deps!
                    isDep ? 'max-age=31536000,immutable' : 'no-cache', result.map);
                }
            }
        }
        catch (e) {
            return next(e);
        }
        next();
    };
}

function createDevHtmlTransformFn(server) {
    const [preHooks, postHooks] = resolveHtmlTransforms(server.config.plugins);
    return (url, html, originalUrl) => {
        return applyHtmlTransforms(html, [...preHooks, devHtmlHook, ...postHooks], {
            path: url,
            filename: getHtmlFilename(url, server),
            server,
            originalUrl
        });
    };
}
function getHtmlFilename(url, server) {
    if (url.startsWith(FS_PREFIX)) {
        return fsPathFromId(url);
    }
    else {
        return path__default.join(server.config.root, url.slice(1));
    }
}
const startsWithSingleSlashRE = /^\/(?!\/)/;
const processNodeUrl = (node, s, config, htmlPath, originalUrl) => {
    var _a;
    const url = ((_a = node.value) === null || _a === void 0 ? void 0 : _a.content) || '';
    if (startsWithSingleSlashRE.test(url)) {
        // prefix with base
        s.overwrite(node.value.loc.start.offset, node.value.loc.end.offset, `"${config.base + url.slice(1)}"`);
    }
    else if (url.startsWith('.') &&
        originalUrl &&
        originalUrl !== '/' &&
        htmlPath === '/index.html') {
        // #3230 if some request url (localhost:3000/a/b) return to fallback html, the relative assets
        // path will add `/a/` prefix, it will caused 404.
        // rewrite before `./index.js` -> `localhost:3000/a/index.js`.
        // rewrite after `../index.js` -> `localhost:3000/index.js`.
        s.overwrite(node.value.loc.start.offset, node.value.loc.end.offset, `"${path__default.posix.join(path__default.posix.relative(originalUrl, '/'), url.slice(1))}"`);
    }
};
const devHtmlHook = async (html, { path: htmlPath, server, originalUrl }) => {
    // TODO: solve this design issue
    // Optional chain expressions can return undefined by design
    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
    const config = server === null || server === void 0 ? void 0 : server.config;
    const base = config.base || '/';
    const s = new MagicString__default(html);
    let scriptModuleIndex = -1;
    await traverseHtml(html, htmlPath, (node) => {
        if (node.type !== 1 /* ELEMENT */) {
            return;
        }
        // script tags
        if (node.tag === 'script') {
            const { src, isModule } = getScriptInfo(node);
            if (isModule) {
                scriptModuleIndex++;
            }
            if (src) {
                processNodeUrl(src, s, config, htmlPath, originalUrl);
            }
            else if (isModule) {
                // inline js module. convert to src="proxy"
                s.overwrite(node.loc.start.offset, node.loc.end.offset, `<script type="module" src="${config.base + htmlPath.slice(1)}?html-proxy&index=${scriptModuleIndex}.js"></script>`);
            }
        }
        // elements with [href/src] attrs
        const assetAttrs = assetAttrsConfig[node.tag];
        if (assetAttrs) {
            for (const p of node.props) {
                if (p.type === 6 /* ATTRIBUTE */ &&
                    p.value &&
                    assetAttrs.includes(p.name)) {
                    processNodeUrl(p, s, config, htmlPath, originalUrl);
                }
            }
        }
    });
    html = s.toString();
    return {
        html,
        tags: [
            {
                tag: 'script',
                attrs: {
                    type: 'module',
                    src: path__default.posix.join(base, CLIENT_PUBLIC_PATH)
                },
                injectTo: 'head-prepend'
            }
        ]
    };
};
function indexHtmlMiddleware(server) {
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return async function viteIndexHtmlMiddleware(req, res, next) {
        const url = req.url && cleanUrl(req.url);
        // spa-fallback always redirects to /index.html
        if ((url === null || url === void 0 ? void 0 : url.endsWith('.html')) && req.headers['sec-fetch-dest'] !== 'script') {
            const filename = getHtmlFilename(url, server);
            if (fs__default.existsSync(filename)) {
                try {
                    let html = fs__default.readFileSync(filename, 'utf-8');
                    html = await server.transformIndexHtml(url, html, req.originalUrl);
                    return send(req, res, html, 'html');
                }
                catch (e) {
                    return next(e);
                }
            }
        }
        next();
    };
}

const logTime = createDebugger('vite:time');
function timeMiddleware(root) {
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    return function viteTimeMiddleware(req, res, next) {
        const start = Date.now();
        const end = res.end;
        res.end = (...args) => {
            logTime(`${timeFrom(start)} ${prettifyUrl(req.url, root)}`);
            // @ts-ignore
            return end.call(res, ...args);
        };
        next();
    };
}

class ModuleNode {
    constructor(url) {
        /**
         * Resolved file system path + query
         */
        this.id = null;
        this.file = null;
        this.importers = new Set();
        this.importedModules = new Set();
        this.acceptedHmrDeps = new Set();
        this.isSelfAccepting = false;
        this.transformResult = null;
        this.ssrTransformResult = null;
        this.ssrModule = null;
        this.lastHMRTimestamp = 0;
        this.url = url;
        this.type = isDirectCSSRequest(url) ? 'css' : 'js';
    }
}
function invalidateSSRModule(mod, seen) {
    if (seen.has(mod)) {
        return;
    }
    seen.add(mod);
    mod.ssrModule = null;
    mod.importers.forEach((importer) => invalidateSSRModule(importer, seen));
}
class ModuleGraph {
    constructor(container) {
        this.urlToModuleMap = new Map();
        this.idToModuleMap = new Map();
        // a single file may corresponds to multiple modules with different queries
        this.fileToModulesMap = new Map();
        this.safeModulesPath = new Set();
        this.container = container;
    }
    async getModuleByUrl(rawUrl) {
        const [url] = await this.resolveUrl(rawUrl);
        return this.urlToModuleMap.get(url);
    }
    getModuleById(id) {
        return this.idToModuleMap.get(removeTimestampQuery(id));
    }
    getModulesByFile(file) {
        return this.fileToModulesMap.get(file);
    }
    onFileChange(file) {
        const mods = this.getModulesByFile(file);
        if (mods) {
            const seen = new Set();
            mods.forEach((mod) => {
                this.invalidateModule(mod, seen);
            });
        }
    }
    invalidateModule(mod, seen = new Set()) {
        mod.transformResult = null;
        mod.ssrTransformResult = null;
        invalidateSSRModule(mod, seen);
    }
    invalidateAll() {
        const seen = new Set();
        this.idToModuleMap.forEach((mod) => {
            this.invalidateModule(mod, seen);
        });
    }
    /**
     * Update the module graph based on a module's updated imports information
     * If there are dependencies that no longer have any importers, they are
     * returned as a Set.
     */
    async updateModuleInfo(mod, importedModules, acceptedModules, isSelfAccepting) {
        mod.isSelfAccepting = isSelfAccepting;
        const prevImports = mod.importedModules;
        const nextImports = (mod.importedModules = new Set());
        let noLongerImported;
        // update import graph
        for (const imported of importedModules) {
            const dep = typeof imported === 'string'
                ? await this.ensureEntryFromUrl(imported)
                : imported;
            dep.importers.add(mod);
            nextImports.add(dep);
        }
        // remove the importer from deps that were imported but no longer are.
        prevImports.forEach((dep) => {
            if (!nextImports.has(dep)) {
                dep.importers.delete(mod);
                if (!dep.importers.size) {
                    (noLongerImported || (noLongerImported = new Set())).add(dep);
                }
            }
        });
        // update accepted hmr deps
        const deps = (mod.acceptedHmrDeps = new Set());
        for (const accepted of acceptedModules) {
            const dep = typeof accepted === 'string'
                ? await this.ensureEntryFromUrl(accepted)
                : accepted;
            deps.add(dep);
        }
        return noLongerImported;
    }
    async ensureEntryFromUrl(rawUrl) {
        const [url, resolvedId] = await this.resolveUrl(rawUrl);
        let mod = this.urlToModuleMap.get(url);
        if (!mod) {
            mod = new ModuleNode(url);
            this.urlToModuleMap.set(url, mod);
            mod.id = resolvedId;
            this.idToModuleMap.set(resolvedId, mod);
            const file = (mod.file = cleanUrl(resolvedId));
            let fileMappedModules = this.fileToModulesMap.get(file);
            if (!fileMappedModules) {
                fileMappedModules = new Set();
                this.fileToModulesMap.set(file, fileMappedModules);
            }
            fileMappedModules.add(mod);
        }
        return mod;
    }
    // some deps, like a css file referenced via @import, don't have its own
    // url because they are inlined into the main css import. But they still
    // need to be represented in the module graph so that they can trigger
    // hmr in the importing css file.
    createFileOnlyEntry(file) {
        file = normalizePath(file);
        let fileMappedModules = this.fileToModulesMap.get(file);
        if (!fileMappedModules) {
            fileMappedModules = new Set();
            this.fileToModulesMap.set(file, fileMappedModules);
        }
        const url = `${FS_PREFIX}${file}`;
        for (const m of fileMappedModules) {
            if (m.url === url || m.id === file) {
                return m;
            }
        }
        const mod = new ModuleNode(url);
        mod.file = file;
        fileMappedModules.add(mod);
        return mod;
    }
    // for incoming urls, it is important to:
    // 1. remove the HMR timestamp query (?t=xxxx)
    // 2. resolve its extension so that urls with or without extension all map to
    // the same module
    async resolveUrl(url$1) {
        var _a;
        url$1 = removeImportQuery(removeTimestampQuery(url$1));
        const resolvedId = ((_a = (await this.container.resolveId(url$1))) === null || _a === void 0 ? void 0 : _a.id) || url$1;
        const ext = path.extname(cleanUrl(resolvedId));
        const { pathname, search, hash } = url.parse(url$1);
        if (ext && !pathname.endsWith(ext)) {
            url$1 = pathname + ext + (search || '') + (hash || '');
        }
        return [url$1, resolvedId];
    }
}

const debugHmr = createDebugger('vite:hmr');
const normalizedClientDir = normalizePath(CLIENT_DIR);
function getShortName(file, root) {
    return file.startsWith(root + '/') ? path__default.posix.relative(root, file) : file;
}
async function handleHMRUpdate(file, server) {
    const { ws, config, moduleGraph } = server;
    const shortFile = getShortName(file, config.root);
    const isConfig = file === config.configFile;
    const isConfigDependency = config.configFileDependencies.some((name) => file === path__default.resolve(name));
    const isEnv = config.inlineConfig.envFile !== false && file.endsWith('.env');
    if (isConfig || isConfigDependency || isEnv) {
        // auto restart server
        debugHmr(`[config change] ${chalk__default.dim(shortFile)}`);
        config.logger.info(chalk__default.green(`${path__default.relative(process.cwd(), file)} changed, restarting server...`), { clear: true, timestamp: true });
        await restartServer(server);
        return;
    }
    debugHmr(`[file change] ${chalk__default.dim(shortFile)}`);
    // (dev only) the client itself cannot be hot updated.
    if (file.startsWith(normalizedClientDir)) {
        ws.send({
            type: 'full-reload',
            path: '*'
        });
        return;
    }
    const mods = moduleGraph.getModulesByFile(file);
    // check if any plugin wants to perform custom HMR handling
    const timestamp = Date.now();
    const hmrContext = {
        file,
        timestamp,
        modules: mods ? [...mods] : [],
        read: () => readModifiedFile(file),
        server
    };
    for (const plugin of config.plugins) {
        if (plugin.handleHotUpdate) {
            const filteredModules = await plugin.handleHotUpdate(hmrContext);
            if (filteredModules) {
                hmrContext.modules = filteredModules;
                break;
            }
        }
    }
    if (!hmrContext.modules.length) {
        // html file cannot be hot updated
        if (file.endsWith('.html')) {
            config.logger.info(chalk__default.green(`page reload `) + chalk__default.dim(shortFile), {
                clear: true,
                timestamp: true
            });
            ws.send({
                type: 'full-reload',
                path: config.server.middlewareMode
                    ? '*'
                    : '/' + normalizePath(path__default.relative(config.root, file))
            });
        }
        else {
            // loaded but not in the module graph, probably not js
            debugHmr(`[no modules matched] ${chalk__default.dim(shortFile)}`);
        }
        return;
    }
    updateModules(shortFile, hmrContext.modules, timestamp, server);
}
function updateModules(file, modules, timestamp, { config, ws }) {
    const updates = [];
    const invalidatedModules = new Set();
    let needFullReload = false;
    for (const mod of modules) {
        invalidate(mod, timestamp, invalidatedModules);
        if (needFullReload) {
            continue;
        }
        const boundaries = new Set();
        const hasDeadEnd = propagateUpdate(mod, boundaries);
        if (hasDeadEnd) {
            needFullReload = true;
            continue;
        }
        updates.push(...[...boundaries].map(({ boundary, acceptedVia }) => ({
            type: `${boundary.type}-update`,
            timestamp,
            path: boundary.url,
            acceptedPath: acceptedVia.url
        })));
    }
    if (needFullReload) {
        config.logger.info(chalk__default.green(`page reload `) + chalk__default.dim(file), {
            clear: true,
            timestamp: true
        });
        ws.send({
            type: 'full-reload'
        });
    }
    else {
        config.logger.info(updates
            .map(({ path }) => chalk__default.green(`hmr update `) + chalk__default.dim(path))
            .join('\n'), { clear: true, timestamp: true });
        ws.send({
            type: 'update',
            updates
        });
    }
}
async function handleFileAddUnlink(file, server, isUnlink = false) {
    var _a;
    const modules = [...((_a = server.moduleGraph.getModulesByFile(file)) !== null && _a !== void 0 ? _a : [])];
    if (isUnlink && file in server._globImporters) {
        delete server._globImporters[file];
    }
    else {
        for (const i in server._globImporters) {
            const { module, importGlobs } = server._globImporters[i];
            for (const { base, pattern } of importGlobs) {
                if (match__default(file, pattern) || match__default(path__default.relative(base, file), pattern)) {
                    modules.push(module);
                    // We use `onFileChange` to invalidate `module.file` so that subsequent `ssrLoadModule()`
                    // calls get fresh glob import results with(out) the newly added(/removed) `file`.
                    server.moduleGraph.onFileChange(module.file);
                    break;
                }
            }
        }
    }
    if (modules.length > 0) {
        updateModules(getShortName(file, server.config.root), modules, Date.now(), server);
    }
}
function propagateUpdate(node, boundaries, currentChain = [node]) {
    if (node.isSelfAccepting) {
        boundaries.add({
            boundary: node,
            acceptedVia: node
        });
        // additionally check for CSS importers, since a PostCSS plugin like
        // Tailwind JIT may register any file as a dependency to a CSS file.
        for (const importer of node.importers) {
            if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
                propagateUpdate(importer, boundaries, currentChain.concat(importer));
            }
        }
        return false;
    }
    if (!node.importers.size) {
        return true;
    }
    // #3716, #3913
    // For a non-CSS file, if all of its importers are CSS files (registered via
    // PostCSS plugins) it should be considered a dead end and force full reload.
    if (!isCSSRequest(node.url) &&
        [...node.importers].every((i) => isCSSRequest(i.url))) {
        return true;
    }
    for (const importer of node.importers) {
        const subChain = currentChain.concat(importer);
        if (importer.acceptedHmrDeps.has(node)) {
            boundaries.add({
                boundary: importer,
                acceptedVia: node
            });
            continue;
        }
        if (currentChain.includes(importer)) {
            // circular deps is considered dead end
            return true;
        }
        if (propagateUpdate(importer, boundaries, subChain)) {
            return true;
        }
    }
    return false;
}
function invalidate(mod, timestamp, seen) {
    if (seen.has(mod)) {
        return;
    }
    seen.add(mod);
    mod.lastHMRTimestamp = timestamp;
    mod.transformResult = null;
    mod.ssrModule = null;
    mod.ssrTransformResult = null;
    mod.importers.forEach((importer) => {
        if (!importer.acceptedHmrDeps.has(mod)) {
            invalidate(importer, timestamp, seen);
        }
    });
}
function handlePrunedModules(mods, { ws }) {
    // update the disposed modules' hmr timestamp
    // since if it's re-imported, it should re-apply side effects
    // and without the timestamp the browser will not re-import it!
    const t = Date.now();
    mods.forEach((mod) => {
        mod.lastHMRTimestamp = t;
        debugHmr(`[dispose] ${chalk__default.dim(mod.file)}`);
    });
    ws.send({
        type: 'prune',
        paths: [...mods].map((m) => m.url)
    });
}
/**
 * Lex import.meta.hot.accept() for accepted deps.
 * Since hot.accept() can only accept string literals or array of string
 * literals, we don't really need a heavy @babel/parse call on the entire source.
 *
 * @returns selfAccepts
 */
function lexAcceptedHmrDeps(code, start, urls) {
    let state = 0 /* inCall */;
    // the state can only be 2 levels deep so no need for a stack
    let prevState = 0 /* inCall */;
    let currentDep = '';
    function addDep(index) {
        urls.add({
            url: currentDep,
            start: index - currentDep.length - 1,
            end: index + 1
        });
        currentDep = '';
    }
    for (let i = start; i < code.length; i++) {
        const char = code.charAt(i);
        switch (state) {
            case 0 /* inCall */:
            case 4 /* inArray */:
                if (char === `'`) {
                    prevState = state;
                    state = 1 /* inSingleQuoteString */;
                }
                else if (char === `"`) {
                    prevState = state;
                    state = 2 /* inDoubleQuoteString */;
                }
                else if (char === '`') {
                    prevState = state;
                    state = 3 /* inTemplateString */;
                }
                else if (/\s/.test(char)) {
                    continue;
                }
                else {
                    if (state === 0 /* inCall */) {
                        if (char === `[`) {
                            state = 4 /* inArray */;
                        }
                        else {
                            // reaching here means the first arg is neither a string literal
                            // nor an Array literal (direct callback) or there is no arg
                            // in both case this indicates a self-accepting module
                            return true; // done
                        }
                    }
                    else if (state === 4 /* inArray */) {
                        if (char === `]`) {
                            return false; // done
                        }
                        else if (char === ',') {
                            continue;
                        }
                        else {
                            error(i);
                        }
                    }
                }
                break;
            case 1 /* inSingleQuoteString */:
                if (char === `'`) {
                    addDep(i);
                    if (prevState === 0 /* inCall */) {
                        // accept('foo', ...)
                        return false;
                    }
                    else {
                        state = prevState;
                    }
                }
                else {
                    currentDep += char;
                }
                break;
            case 2 /* inDoubleQuoteString */:
                if (char === `"`) {
                    addDep(i);
                    if (prevState === 0 /* inCall */) {
                        // accept('foo', ...)
                        return false;
                    }
                    else {
                        state = prevState;
                    }
                }
                else {
                    currentDep += char;
                }
                break;
            case 3 /* inTemplateString */:
                if (char === '`') {
                    addDep(i);
                    if (prevState === 0 /* inCall */) {
                        // accept('foo', ...)
                        return false;
                    }
                    else {
                        state = prevState;
                    }
                }
                else if (char === '$' && code.charAt(i + 1) === '{') {
                    error(i);
                }
                else {
                    currentDep += char;
                }
                break;
            default:
                throw new Error('unknown import.meta.hot lexer state');
        }
    }
    return false;
}
function error(pos) {
    const err = new Error(`import.meta.accept() can only accept string literals or an ` +
        `Array of string literals.`);
    err.pos = pos;
    throw err;
}
// vitejs/vite#610 when hot-reloading Vue files, we read immediately on file
// change event and sometimes this can be too early and get an empty buffer.
// Poll until the file's modified time has changed before reading again.
async function readModifiedFile(file) {
    const content = fs__default.readFileSync(file, 'utf-8');
    if (!content) {
        const mtime = fs__default.statSync(file).mtimeMs;
        await new Promise((r) => {
            let n = 0;
            const poll = async () => {
                n++;
                const newMtime = fs__default.statSync(file).mtimeMs;
                if (newMtime !== mtime || n > 10) {
                    r(0);
                }
                else {
                    setTimeout(poll, 10);
                }
            };
            setTimeout(poll, 10);
        });
        return fs__default.readFileSync(file, 'utf-8');
    }
    else {
        return content;
    }
}
async function restartServer(server) {
    // @ts-ignore
    global.__vite_start_time = Date.now();
    const { port } = server.config.server;
    await server.close();
    let newServer = null;
    try {
        newServer = await createServer(server.config.inlineConfig);
    }
    catch (err) {
        server.config.logger.error(err.message, {
            timestamp: true
        });
        return;
    }
    for (const key in newServer) {
        if (key !== 'app') {
            // @ts-ignore
            server[key] = newServer[key];
        }
    }
    if (!server.config.server.middlewareMode) {
        await server.listen(port, true);
    }
    else {
        server.config.logger.info('server restarted.', { timestamp: true });
    }
}

/**
 * The following is modified based on source found in
 * https://github.com/facebook/create-react-app
 *
 * MIT Licensed
 * Copyright (c) 2015-present, Facebook, Inc.
 * https://github.com/facebook/create-react-app/blob/master/LICENSE
 *
 */
// https://github.com/sindresorhus/open#app
const OSX_CHROME = 'google chrome';
/**
 * Reads the BROWSER environment variable and decides what to do with it.
 * Returns true if it opened a browser or ran a node.js script, otherwise false.
 */
function openBrowser(url, opt, logger) {
    // The browser executable to open.
    // See https://github.com/sindresorhus/open#app for documentation.
    const browser = typeof opt === 'string' ? opt : process.env.BROWSER || '';
    if (browser.toLowerCase().endsWith('.js')) {
        return executeNodeScript(browser, url, logger);
    }
    else if (browser.toLowerCase() !== 'none') {
        return startBrowserProcess(browser, url);
    }
    return false;
}
function executeNodeScript(scriptPath, url, logger) {
    const extraArgs = process.argv.slice(2);
    const child = execa__default('node', [scriptPath, ...extraArgs, url], {
        stdio: 'inherit'
    });
    child.on('close', (code) => {
        if (code !== 0) {
            logger.error(chalk__default.red(`\nThe script specified as BROWSER environment variable failed.\n\n${chalk__default.cyan(scriptPath)} exited with code ${code}.`), { error: null });
        }
    });
    return true;
}
function startBrowserProcess(browser, url) {
    // If we're on OS X, the user hasn't specifically
    // requested a different browser, we can try opening
    // Chrome with AppleScript. This lets us reuse an
    // existing tab when possible instead of creating a new one.
    const shouldTryOpenChromeWithAppleScript = process.platform === 'darwin' && (browser === '' || browser === OSX_CHROME);
    if (shouldTryOpenChromeWithAppleScript) {
        try {
            // Try our best to reuse existing tab
            // on OS X Google Chrome with AppleScript
            child_process.execSync('ps cax | grep "Google Chrome"');
            child_process.execSync('osascript openChrome.applescript "' + encodeURI(url) + '"', {
                cwd: path__default.dirname(require.resolve('vite/bin/openChrome.applescript')),
                stdio: 'ignore'
            });
            return true;
        }
        catch (err) {
            // Ignore errors
        }
    }
    // Another special case: on OS X, check if BROWSER has been set to "open".
    // In this case, instead of passing the string `open` to `open` function (which won't work),
    // just ignore it (thus ensuring the intended behavior, i.e. opening the system browser):
    // https://github.com/facebook/create-react-app/pull/1690#issuecomment-283518768
    if (process.platform === 'darwin' && browser === 'open') {
        browser = undefined;
    }
    // Fallback to open
    // (It will always open new tab)
    try {
        const options = browser ? { app: { name: browser } } : {};
        open__default(url, options).catch(() => { }); // Prevent `unhandledRejection` error.
        return true;
    }
    catch (err) {
        return false;
    }
}

const externalTypes = [
    'css',
    // supported pre-processor types
    'less',
    'sass',
    'scss',
    'styl',
    'stylus',
    'pcss',
    'postcss',
    // known SFC types
    'vue',
    'svelte',
    'marko',
    // JSX/TSX may be configured to be compiled differently from how esbuild
    // handles it by default, so exclude them as well
    'jsx',
    'tsx',
    ...KNOWN_ASSET_TYPES
];
function esbuildDepPlugin(qualified, exportsData, config, ssr) {
    // default resolver which prefers ESM
    const _resolve = config.createResolver({ asSrc: false });
    // cjs resolver that prefers Node
    const _resolveRequire = config.createResolver({
        asSrc: false,
        isRequire: true
    });
    const resolve = (id, importer, kind, resolveDir) => {
        let _importer;
        // explicit resolveDir - this is passed only during yarn pnp resolve for
        // entries
        if (resolveDir) {
            _importer = normalizePath(path__default.join(resolveDir, '*'));
        }
        else {
            // map importer ids to file paths for correct resolution
            _importer = importer in qualified ? qualified[importer] : importer;
        }
        const resolver = kind.startsWith('require') ? _resolveRequire : _resolve;
        return resolver(id, _importer, undefined, ssr);
    };
    return {
        name: 'vite:dep-pre-bundle',
        setup(build) {
            // externalize assets and commonly known non-js file types
            build.onResolve({
                filter: new RegExp(`\\.(` + externalTypes.join('|') + `)(\\?.*)?$`)
            }, async ({ path: id, importer, kind }) => {
                const resolved = await resolve(id, importer, kind);
                if (resolved) {
                    return {
                        path: resolved,
                        external: true
                    };
                }
            });
            function resolveEntry(id) {
                const flatId = flattenId(id);
                if (flatId in qualified) {
                    return {
                        path: flatId,
                        namespace: 'dep'
                    };
                }
            }
            build.onResolve({ filter: /^[\w@][^:]/ }, async ({ path: id, importer, kind }) => {
                // ensure esbuild uses our resolved entries
                let entry;
                // if this is an entry, return entry namespace resolve result
                if (!importer) {
                    if ((entry = resolveEntry(id)))
                        return entry;
                    // check if this is aliased to an entry - also return entry namespace
                    const aliased = await _resolve(id, undefined, true);
                    if (aliased && (entry = resolveEntry(aliased))) {
                        return entry;
                    }
                }
                // use vite's own resolver
                const resolved = await resolve(id, importer, kind);
                if (resolved) {
                    if (resolved.startsWith(browserExternalId)) {
                        return {
                            path: id,
                            namespace: 'browser-external'
                        };
                    }
                    if (isExternalUrl(resolved) || (ssr && isBuiltin(id))) {
                        return {
                            path: resolved,
                            external: true
                        };
                    }
                    return {
                        path: path__default.resolve(resolved)
                    };
                }
            });
            // For entry files, we'll read it ourselves and construct a proxy module
            // to retain the entry's raw id instead of file path so that esbuild
            // outputs desired output file structure.
            // It is necessary to do the re-exporting to separate the virtual proxy
            // module from the actual module since the actual module may get
            // referenced via relative imports - if we don't separate the proxy and
            // the actual module, esbuild will create duplicated copies of the same
            // module!
            const root = path__default.resolve(config.root);
            build.onLoad({ filter: /.*/, namespace: 'dep' }, ({ path: id }) => {
                const entryFile = qualified[id];
                let relativePath = normalizePath(path__default.relative(root, entryFile));
                if (!relativePath.startsWith('./') &&
                    !relativePath.startsWith('../') &&
                    relativePath !== '.') {
                    relativePath = `./${relativePath}`;
                }
                let contents = '';
                const data = exportsData[id];
                const [imports, exports] = data;
                if (!imports.length && !exports.length) {
                    // cjs
                    contents += `export default require("${relativePath}");`;
                }
                else {
                    if (exports.includes('default')) {
                        contents += `import d from "${relativePath}";export default d;`;
                    }
                    if (data.hasReExports ||
                        exports.length > 1 ||
                        exports[0] !== 'default') {
                        contents += `\nexport * from "${relativePath}"`;
                    }
                }
                let ext = path__default.extname(entryFile).slice(1);
                if (ext === 'mjs')
                    ext = 'js';
                return {
                    loader: ext,
                    contents,
                    resolveDir: root
                };
            });
            build.onLoad({ filter: /.*/, namespace: 'browser-external' }, ({ path: id }) => {
                return {
                    contents: `export default new Proxy({}, {
  get() {
    throw new Error('Module "${id}" has been externalized for ` +
                        `browser compatibility and cannot be accessed in client code.')
  }
})`
                };
            });
            // yarn 2 pnp compat
            if (isRunningWithYarnPnp) {
                build.onResolve({ filter: /.*/ }, async ({ path, importer, kind, resolveDir }) => ({
                    // pass along resolveDir for entries
                    path: await resolve(path, importer, kind, resolveDir)
                }));
                build.onLoad({ filter: /.*/ }, async (args) => ({
                    contents: await require('fs').promises.readFile(args.path),
                    loader: 'default'
                }));
            }
        }
    };
}

const debug$2 = createDebugger('vite:deps');
async function optimizeDeps(config, force = config.server.force, asCommand = false, newDeps, // missing imports encountered after server has started
ssr) {
    var _a, _b, _c, _d;
    config = {
        ...config,
        command: 'build'
    };
    const { root, logger, cacheDir } = config;
    const log = asCommand ? logger.info : debug$2;
    if (!cacheDir) {
        log(`No cache directory. Skipping.`);
        return null;
    }
    const dataPath = path__default.join(cacheDir, '_metadata.json');
    const mainHash = getDepHash(root, config);
    const data = {
        hash: mainHash,
        browserHash: mainHash,
        optimized: {}
    };
    if (!force) {
        let prevData;
        try {
            prevData = JSON.parse(fs__default.readFileSync(dataPath, 'utf-8'));
        }
        catch (e) { }
        // hash is consistent, no need to re-bundle
        if (prevData && prevData.hash === data.hash) {
            log('Hash is consistent. Skipping. Use --force to override.');
            return prevData;
        }
    }
    if (fs__default.existsSync(cacheDir)) {
        emptyDir(cacheDir);
    }
    else {
        fs__default.mkdirSync(cacheDir, { recursive: true });
    }
    // a hint for Node.js
    // all files in the cache directory should be recognized as ES modules
    writeFile(path__default.resolve(cacheDir, 'package.json'), JSON.stringify({ type: 'module' }));
    let deps, missing;
    if (!newDeps) {
        ({ deps, missing } = await scanImports(config));
    }
    else {
        deps = newDeps;
        missing = {};
    }
    // update browser hash
    data.browserHash = crypto.createHash('sha256')
        .update(data.hash + JSON.stringify(deps))
        .digest('hex')
        .substr(0, 8);
    const missingIds = Object.keys(missing);
    if (missingIds.length) {
        throw new Error(`The following dependencies are imported but could not be resolved:\n\n  ${missingIds
            .map((id) => `${chalk__default.cyan(id)} ${chalk__default.white.dim(`(imported by ${missing[id]})`)}`)
            .join(`\n  `)}\n\nAre they installed?`);
    }
    const include = (_a = config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.include;
    if (include) {
        const resolve = config.createResolver({ asSrc: false });
        for (const id of include) {
            // normalize 'foo   >bar` as 'foo > bar' to prevent same id being added
            // and for pretty printing
            const normalizedId = normalizeId(id);
            if (!deps[normalizedId]) {
                const entry = await resolve(id);
                if (entry) {
                    deps[normalizedId] = entry;
                }
                else {
                    throw new Error(`Failed to resolve force included dependency: ${chalk__default.cyan(id)}`);
                }
            }
        }
    }
    const qualifiedIds = Object.keys(deps);
    if (!qualifiedIds.length) {
        writeFile(dataPath, JSON.stringify(data, null, 2));
        log(`No dependencies to bundle. Skipping.\n\n\n`);
        return data;
    }
    const total = qualifiedIds.length;
    const maxListed = 5;
    const listed = Math.min(total, maxListed);
    const extra = Math.max(0, total - maxListed);
    const depsString = chalk__default.yellow(qualifiedIds.slice(0, listed).join(`\n  `) +
        (extra > 0 ? `\n  (...and ${extra} more)` : ``));
    if (!asCommand) {
        if (!newDeps) {
            // This is auto run on server start - let the user know that we are
            // pre-optimizing deps
            logger.info(chalk__default.greenBright(`Pre-bundling dependencies:\n  ${depsString}`));
            logger.info(`(this will be run only when your dependencies or config have changed)`);
        }
    }
    else {
        logger.info(chalk__default.greenBright(`Optimizing dependencies:\n  ${depsString}`));
    }
    // esbuild generates nested directory output with lowest common ancestor base
    // this is unpredictable and makes it difficult to analyze entry / output
    // mapping. So what we do here is:
    // 1. flatten all ids to eliminate slash
    // 2. in the plugin, read the entry ourselves as virtual files to retain the
    //    path.
    const flatIdDeps = {};
    const idToExports = {};
    const flatIdToExports = {};
    const { plugins = [], ...esbuildOptions } = (_c = (_b = config.optimizeDeps) === null || _b === void 0 ? void 0 : _b.esbuildOptions) !== null && _c !== void 0 ? _c : {};
    await esModuleLexer.init;
    for (const id in deps) {
        const flatId = flattenId(id);
        const filePath = (flatIdDeps[flatId] = deps[id]);
        const entryContent = fs__default.readFileSync(filePath, 'utf-8');
        let exportsData;
        try {
            exportsData = esModuleLexer.parse(entryContent);
        }
        catch {
            debug$2(`Unable to parse dependency: ${id}. Trying again with a JSX transform.`);
            const transformed = await transformWithEsbuild(entryContent, filePath, {
                loader: 'jsx'
            });
            // Ensure that optimization won't fail by defaulting '.js' to the JSX parser.
            // This is useful for packages such as Gatsby.
            esbuildOptions.loader = {
                '.js': 'jsx',
                ...esbuildOptions.loader
            };
            exportsData = esModuleLexer.parse(transformed.code);
        }
        for (const { ss, se } of exportsData[0]) {
            const exp = entryContent.slice(ss, se);
            if (/export\s+\*\s+from/.test(exp)) {
                exportsData.hasReExports = true;
            }
        }
        idToExports[id] = exportsData;
        flatIdToExports[flatId] = exportsData;
    }
    const define = {
        'process.env.NODE_ENV': JSON.stringify(config.mode)
    };
    for (const key in config.define) {
        const value = config.define[key];
        define[key] = typeof value === 'string' ? value : JSON.stringify(value);
    }
    const start = Date.now();
    const result = await esbuild.build({
        absWorkingDir: process.cwd(),
        entryPoints: Object.keys(flatIdDeps),
        bundle: true,
        format: 'esm',
        external: (_d = config.optimizeDeps) === null || _d === void 0 ? void 0 : _d.exclude,
        logLevel: 'error',
        splitting: true,
        sourcemap: true,
        outdir: cacheDir,
        treeShaking: 'ignore-annotations',
        metafile: true,
        define,
        plugins: [
            ...plugins,
            esbuildDepPlugin(flatIdDeps, flatIdToExports, config, ssr)
        ],
        ...esbuildOptions
    });
    const meta = result.metafile;
    // the paths in `meta.outputs` are relative to `process.cwd()`
    const cacheDirOutputPath = path__default.relative(process.cwd(), cacheDir);
    for (const id in deps) {
        const entry = deps[id];
        data.optimized[id] = {
            file: normalizePath(path__default.resolve(cacheDir, flattenId(id) + '.js')),
            src: entry,
            needsInterop: needsInterop(id, idToExports[id], meta.outputs, cacheDirOutputPath)
        };
    }
    writeFile(dataPath, JSON.stringify(data, null, 2));
    debug$2(`deps bundled in ${Date.now() - start}ms`);
    return data;
}
// https://github.com/vitejs/vite/issues/1724#issuecomment-767619642
// a list of modules that pretends to be ESM but still uses `require`.
// this causes esbuild to wrap them as CJS even when its entry appears to be ESM.
const KNOWN_INTEROP_IDS = new Set(['moment']);
function needsInterop(id, exportsData, outputs, cacheDirOutputPath) {
    if (KNOWN_INTEROP_IDS.has(id)) {
        return true;
    }
    const [imports, exports] = exportsData;
    // entry has no ESM syntax - likely CJS or UMD
    if (!exports.length && !imports.length) {
        return true;
    }
    // if a peer dependency used require() on a ESM dependency, esbuild turns the
    // ESM dependency's entry chunk into a single default export... detect
    // such cases by checking exports mismatch, and force interop.
    const flatId = flattenId(id) + '.js';
    let generatedExports;
    for (const output in outputs) {
        if (normalizePath(output) ===
            normalizePath(path__default.join(cacheDirOutputPath, flatId))) {
            generatedExports = outputs[output].exports;
            break;
        }
    }
    if (!generatedExports ||
        (isSingleDefaultExport(generatedExports) && !isSingleDefaultExport(exports))) {
        return true;
    }
    return false;
}
function isSingleDefaultExport(exports) {
    return exports.length === 1 && exports[0] === 'default';
}
const lockfileFormats = ['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'];
function getDepHash(root, config) {
    var _a, _b;
    let content = lookupFile(root, lockfileFormats) || '';
    // also take config into account
    // only a subset of config options that can affect dep optimization
    content += JSON.stringify({
        mode: config.mode,
        root: config.root,
        resolve: config.resolve,
        assetsInclude: config.assetsInclude,
        plugins: config.plugins.map((p) => p.name),
        optimizeDeps: {
            include: (_a = config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.include,
            exclude: (_b = config.optimizeDeps) === null || _b === void 0 ? void 0 : _b.exclude
        }
    }, (_, value) => {
        if (typeof value === 'function' || value instanceof RegExp) {
            return value.toString();
        }
        return value;
    });
    return crypto.createHash('sha256').update(content).digest('hex').substr(0, 8);
}

var index$1 = {
    __proto__: null,
    optimizeDeps: optimizeDeps
};

let offset;
try {
    new Function('throw new Error(1)')();
}
catch (e) {
    // in Node 12, stack traces account for the function wrapper.
    // in Node 13 and later, the function wrapper adds two lines,
    // which must be subtracted to generate a valid mapping
    const match = /:(\d+):\d+\)$/.exec(e.stack.split('\n')[1]);
    offset = match ? +match[1] - 1 : 0;
}
function ssrRewriteStacktrace(stack, moduleGraph) {
    return stack
        .split('\n')
        .map((line) => {
        return line.replace(/^ {4}at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?)\)?/, (input, varName, url, line, column) => {
            var _a;
            if (!url)
                return input;
            const mod = moduleGraph.urlToModuleMap.get(url);
            const rawSourceMap = (_a = mod === null || mod === void 0 ? void 0 : mod.ssrTransformResult) === null || _a === void 0 ? void 0 : _a.map;
            if (!rawSourceMap) {
                return input;
            }
            const consumer = new sourceMap.SourceMapConsumer(rawSourceMap);
            const pos = consumer.originalPositionFor({
                line: Number(line) - offset,
                column: Number(column),
                bias: sourceMap.SourceMapConsumer.LEAST_UPPER_BOUND
            });
            if (!pos.source) {
                return input;
            }
            const source = `${pos.source}:${pos.line || 0}:${pos.column || 0}`;
            if (!varName || varName === 'eval') {
                return `    at ${source}`;
            }
            else {
                return `    at ${varName} (${source})`;
            }
        });
    })
        .join('\n');
}
function rebindErrorStacktrace(e, stacktrace) {
    const { configurable, writable } = Object.getOwnPropertyDescriptor(e, 'stack');
    if (configurable) {
        Object.defineProperty(e, 'stack', {
            value: stacktrace,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else if (writable) {
        e.stack = stacktrace;
    }
}

const pendingModules = new Map();
const pendingImports = new Map();
async function ssrLoadModule(url, server, context = { global }, urlStack = []) {
    url = unwrapId(url);
    // when we instantiate multiple dependency modules in parallel, they may
    // point to shared modules. We need to avoid duplicate instantiation attempts
    // by register every module as pending synchronously so that all subsequent
    // request to that module are simply waiting on the same promise.
    const pending = pendingModules.get(url);
    if (pending) {
        return pending;
    }
    const modulePromise = instantiateModule(url, server, context, urlStack);
    pendingModules.set(url, modulePromise);
    modulePromise
        .catch(() => {
        pendingImports.delete(url);
    })
        .finally(() => {
        pendingModules.delete(url);
    });
    return modulePromise;
}
async function instantiateModule(url, server, context = { global }, urlStack = []) {
    const { moduleGraph } = server;
    const mod = await moduleGraph.ensureEntryFromUrl(url);
    if (mod.ssrModule) {
        return mod.ssrModule;
    }
    const result = mod.ssrTransformResult ||
        (await transformRequest(url, server, { ssr: true }));
    if (!result) {
        // TODO more info? is this even necessary?
        throw new Error(`failed to load module for ssr: ${url}`);
    }
    const ssrModule = {
        [Symbol.toStringTag]: 'Module'
    };
    Object.defineProperty(ssrModule, '__esModule', { value: true });
    // Tolerate circular imports by ensuring the module can be
    // referenced before it's been instantiated.
    mod.ssrModule = ssrModule;
    const ssrImportMeta = { url };
    urlStack = urlStack.concat(url);
    const isCircular = (url) => urlStack.includes(url);
    // Since dynamic imports can happen in parallel, we need to
    // account for multiple pending deps and duplicate imports.
    const pendingDeps = [];
    const ssrImport = async (dep) => {
        var _a, _b;
        if (dep[0] !== '.' && dep[0] !== '/') {
            return nodeRequire(dep, mod.file, server.config.root, !!server.config.resolve.preserveSymlinks);
        }
        dep = unwrapId(dep);
        if (!isCircular(dep) && !((_a = pendingImports.get(dep)) === null || _a === void 0 ? void 0 : _a.some(isCircular))) {
            pendingDeps.push(dep);
            if (pendingDeps.length === 1) {
                pendingImports.set(url, pendingDeps);
            }
            await ssrLoadModule(dep, server, context, urlStack);
            if (pendingDeps.length === 1) {
                pendingImports.delete(url);
            }
            else {
                pendingDeps.splice(pendingDeps.indexOf(dep), 1);
            }
        }
        return (_b = moduleGraph.urlToModuleMap.get(dep)) === null || _b === void 0 ? void 0 : _b.ssrModule;
    };
    const ssrDynamicImport = (dep) => {
        // #3087 dynamic import vars is ignored at rewrite import path,
        // so here need process relative path
        if (dep[0] === '.') {
            dep = path__default.posix.resolve(path__default.dirname(url), dep);
        }
        return ssrImport(dep);
    };
    function ssrExportAll(sourceModule) {
        for (const key in sourceModule) {
            if (key !== 'default') {
                Object.defineProperty(ssrModule, key, {
                    enumerable: true,
                    configurable: true,
                    get() {
                        return sourceModule[key];
                    }
                });
            }
        }
    }
    try {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const AsyncFunction = async function () { }.constructor;
        const initModule = new AsyncFunction(`global`, ssrModuleExportsKey, ssrImportMetaKey, ssrImportKey, ssrDynamicImportKey, ssrExportAllKey, result.code + `\n//# sourceURL=${mod.url}`);
        await initModule(context.global, ssrModule, ssrImportMeta, ssrImport, ssrDynamicImport, ssrExportAll);
    }
    catch (e) {
        const stacktrace = ssrRewriteStacktrace(e.stack, moduleGraph);
        rebindErrorStacktrace(e, stacktrace);
        server.config.logger.error(`Error when evaluating SSR module ${url}:\n${stacktrace}`, {
            timestamp: true,
            clear: server.config.clearScreen,
            error: e
        });
        throw e;
    }
    return Object.freeze(ssrModule);
}
function nodeRequire(id, importer, root, preserveSymlinks) {
    const mod = require(resolve(id, importer, root, preserveSymlinks));
    const defaultExport = mod.__esModule ? mod.default : mod;
    // rollup-style default import interop for cjs
    return new Proxy(mod, {
        get(mod, prop) {
            if (prop === 'default')
                return defaultExport;
            return mod[prop];
        }
    });
}
const resolveCache = new Map();
function resolve(id, importer, root, preserveSymlinks) {
    const key = id + importer + root;
    const cached = resolveCache.get(key);
    if (cached) {
        return cached;
    }
    const resolveDir = importer && fs__default.existsSync(cleanUrl(importer))
        ? path__default.dirname(importer)
        : root;
    const resolved = resolveFrom(id, resolveDir, preserveSymlinks, true);
    resolveCache.set(key, resolved);
    return resolved;
}

/**
 * The amount to wait for requests to register newly found dependencies before triggering
 * a re-bundle + page reload
 */
const debounceMs = 100;
function createMissingImporterRegisterFn(server) {
    const { logger } = server.config;
    let knownOptimized = server._optimizeDepsMetadata.optimized;
    let currentMissing = {};
    let handle;
    let pendingResolve = null;
    async function rerun(ssr) {
        const newDeps = currentMissing;
        currentMissing = {};
        logger.info(chalk__default.yellow(`new dependencies found: ${Object.keys(newDeps).join(', ')}, updating...`), {
            timestamp: true
        });
        for (const id in knownOptimized) {
            newDeps[id] = knownOptimized[id].src;
        }
        try {
            // Nullify previous metadata so that the resolver won't
            // resolve to optimized files during the optimizer re-run
            server._isRunningOptimizer = true;
            server._optimizeDepsMetadata = null;
            const newData = (server._optimizeDepsMetadata = await optimizeDeps(server.config, true, false, newDeps, ssr));
            knownOptimized = newData.optimized;
            // update ssr externals
            server._ssrExternals = resolveSSRExternal(server.config, Object.keys(knownOptimized));
            logger.info(chalk__default.greenBright(`✨ dependencies updated, reloading page...`), { timestamp: true });
        }
        catch (e) {
            logger.error(chalk__default.red(`error while updating dependencies:\n${e.stack}`), { timestamp: true, error: e });
        }
        finally {
            server._isRunningOptimizer = false;
            pendingResolve && pendingResolve();
            server._pendingReload = pendingResolve = null;
        }
        // Cached transform results have stale imports (resolved to
        // old locations) so they need to be invalidated before the page is
        // reloaded.
        server.moduleGraph.invalidateAll();
        server.ws.send({
            type: 'full-reload',
            path: '*'
        });
    }
    return function registerMissingImport(id, resolved, ssr) {
        if (!knownOptimized[id]) {
            currentMissing[id] = resolved;
            if (handle)
                clearTimeout(handle);
            handle = setTimeout(() => rerun(ssr), debounceMs);
            server._pendingReload = new Promise((r) => {
                pendingResolve = r;
            });
        }
    };
}

// https://github.com/vitejs/vite/issues/2820#issuecomment-812495079
const ROOT_FILES = [
    // '.git',
    // https://pnpm.js.org/workspaces/
    'pnpm-workspace.yaml'
    // https://rushjs.io/pages/advanced/config_files/
    // 'rush.json',
    // https://nx.dev/latest/react/getting-started/nx-setup
    // 'workspace.json',
    // 'nx.json'
];
// npm: https://docs.npmjs.com/cli/v7/using-npm/workspaces#installing-workspaces
// yarn: https://classic.yarnpkg.com/en/docs/workspaces/#toc-how-to-use-it
function hasWorkspacePackageJSON(root) {
    const path$1 = path.join(root, 'package.json');
    try {
        fs__default.accessSync(path$1, fs__default.constants.R_OK);
    }
    catch {
        return false;
    }
    const content = JSON.parse(fs__default.readFileSync(path$1, 'utf-8')) || {};
    return !!content.workspaces;
}
function hasRootFile(root) {
    return ROOT_FILES.some((file) => fs__default.existsSync(path.join(root, file)));
}
function hasPackageJSON(root) {
    const path$1 = path.join(root, 'package.json');
    return fs__default.existsSync(path$1);
}
/**
 * Search up for the nearest `package.json`
 */
function searchForPackageRoot(current, root = current) {
    if (hasPackageJSON(current))
        return current;
    const dir = path.dirname(current);
    // reach the fs root
    if (!dir || dir === current)
        return root;
    return searchForPackageRoot(dir, root);
}
/**
 * Search up for the nearest workspace root
 */
function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
    if (hasRootFile(current))
        return current;
    if (hasWorkspacePackageJSON(current))
        return current;
    const dir = path.dirname(current);
    // reach the fs root
    if (!dir || dir === current)
        return root;
    return searchForWorkspaceRoot(dir, root);
}

async function createServer(inlineConfig = {}) {
    const config = await resolveConfig(inlineConfig, 'serve', 'development');
    const root = config.root;
    const serverConfig = config.server;
    const httpsOptions = await resolveHttpsConfig(config);
    let { middlewareMode } = serverConfig;
    if (middlewareMode === true) {
        middlewareMode = 'ssr';
    }
    const middlewares = connect__default();
    const httpServer = middlewareMode
        ? null
        : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
    const ws = createWebSocketServer(httpServer, config, httpsOptions);
    const { ignored = [], ...watchOptions } = serverConfig.watch || {};
    const watcher = chokidar__default.watch(path__default.resolve(root), {
        ignored: [
            '**/node_modules/**',
            '**/.git/**',
            ...(Array.isArray(ignored) ? ignored : [ignored])
        ],
        ignoreInitial: true,
        ignorePermissionErrors: true,
        disableGlobbing: true,
        ...watchOptions
    });
    const plugins = config.plugins;
    const container = await createPluginContainer(config, watcher);
    const moduleGraph = new ModuleGraph(container);
    const closeHttpServer = createServerCloseFn(httpServer);
    // eslint-disable-next-line prefer-const
    let exitProcess;
    const server = {
        config,
        middlewares,
        get app() {
            config.logger.warn(`ViteDevServer.app is deprecated. Use ViteDevServer.middlewares instead.`);
            return middlewares;
        },
        httpServer,
        watcher,
        pluginContainer: container,
        ws,
        moduleGraph,
        transformWithEsbuild,
        transformRequest(url, options) {
            return transformRequest(url, server, options);
        },
        transformIndexHtml: null,
        ssrLoadModule(url) {
            if (!server._ssrExternals) {
                server._ssrExternals = resolveSSRExternal(config, server._optimizeDepsMetadata
                    ? Object.keys(server._optimizeDepsMetadata.optimized)
                    : []);
            }
            return ssrLoadModule(url, server);
        },
        ssrFixStacktrace(e) {
            if (e.stack) {
                const stacktrace = ssrRewriteStacktrace(e.stack, moduleGraph);
                rebindErrorStacktrace(e, stacktrace);
            }
        },
        listen(port, isRestart) {
            return startServer(server, port, isRestart);
        },
        async close() {
            process.off('SIGTERM', exitProcess);
            if (!middlewareMode && process.env.CI !== 'true') {
                process.stdin.off('end', exitProcess);
            }
            await Promise.all([
                watcher.close(),
                ws.close(),
                container.close(),
                closeHttpServer()
            ]);
        },
        _optimizeDepsMetadata: null,
        _ssrExternals: null,
        _globImporters: {},
        _isRunningOptimizer: false,
        _registerMissingImport: null,
        _pendingReload: null
    };
    server.transformIndexHtml = createDevHtmlTransformFn(server);
    exitProcess = async () => {
        try {
            await server.close();
        }
        finally {
            process.exit(0);
        }
    };
    process.once('SIGTERM', exitProcess);
    if (!middlewareMode && process.env.CI !== 'true') {
        process.stdin.on('end', exitProcess);
    }
    watcher.on('change', async (file) => {
        file = normalizePath(file);
        // invalidate module graph cache on file change
        moduleGraph.onFileChange(file);
        if (serverConfig.hmr !== false) {
            try {
                await handleHMRUpdate(file, server);
            }
            catch (err) {
                ws.send({
                    type: 'error',
                    err: prepareError(err)
                });
            }
        }
    });
    watcher.on('add', (file) => {
        handleFileAddUnlink(normalizePath(file), server);
    });
    watcher.on('unlink', (file) => {
        handleFileAddUnlink(normalizePath(file), server, true);
    });
    if (!middlewareMode && httpServer) {
        httpServer.once('listening', () => {
            // update actual port since this may be different from initial value
            serverConfig.port = httpServer.address().port;
        });
    }
    // apply server configuration hooks from plugins
    const postHooks = [];
    for (const plugin of plugins) {
        if (plugin.configureServer) {
            postHooks.push(await plugin.configureServer(server));
        }
    }
    // Internal middlewares ------------------------------------------------------
    // request timer
    if (process.env.DEBUG) {
        middlewares.use(timeMiddleware(root));
    }
    // cors (enabled by default)
    const { cors } = serverConfig;
    if (cors !== false) {
        middlewares.use(corsMiddleware__default(typeof cors === 'boolean' ? {} : cors));
    }
    // proxy
    const { proxy } = serverConfig;
    if (proxy) {
        middlewares.use(proxyMiddleware(httpServer, config));
    }
    // base
    if (config.base !== '/') {
        middlewares.use(baseMiddleware(server));
    }
    // open in editor support
    middlewares.use('/__open-in-editor', launchEditorMiddleware__default());
    // hmr reconnect ping
    // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
    middlewares.use('/__vite_ping', function viteHMRPingMiddleware(_, res) {
        res.end('pong');
    });
    // serve static files under /public
    // this applies before the transform middleware so that these files are served
    // as-is without transforms.
    if (config.publicDir) {
        middlewares.use(servePublicMiddleware(config.publicDir));
    }
    // main transform middleware
    middlewares.use(transformMiddleware(server));
    // serve static files
    middlewares.use(serveRawFsMiddleware(server));
    middlewares.use(serveStaticMiddleware(root, config));
    // spa fallback
    if (!middlewareMode || middlewareMode === 'html') {
        middlewares.use(spaFallbackMiddleware(root));
    }
    // run post config hooks
    // This is applied before the html middleware so that user middleware can
    // serve custom content instead of index.html.
    postHooks.forEach((fn) => fn && fn());
    if (!middlewareMode || middlewareMode === 'html') {
        // transform index.html
        middlewares.use(indexHtmlMiddleware(server));
        // handle 404s
        // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
        middlewares.use(function vite404Middleware(_, res) {
            res.statusCode = 404;
            res.end();
        });
    }
    // error handler
    middlewares.use(errorMiddleware(server, !!middlewareMode));
    const runOptimize = async () => {
        if (config.cacheDir) {
            server._isRunningOptimizer = true;
            try {
                server._optimizeDepsMetadata = await optimizeDeps(config);
            }
            finally {
                server._isRunningOptimizer = false;
            }
            server._registerMissingImport = createMissingImporterRegisterFn(server);
        }
    };
    if (!middlewareMode && httpServer) {
        let isOptimized = false;
        // overwrite listen to run optimizer before server start
        const listen = httpServer.listen.bind(httpServer);
        httpServer.listen = (async (port, ...args) => {
            if (!isOptimized) {
                try {
                    await container.buildStart({});
                    await runOptimize();
                    isOptimized = true;
                }
                catch (e) {
                    httpServer.emit('error', e);
                    return;
                }
            }
            return listen(port, ...args);
        });
    }
    else {
        await container.buildStart({});
        await runOptimize();
    }
    return server;
}
async function startServer(server, inlinePort, isRestart = false) {
    const httpServer = server.httpServer;
    if (!httpServer) {
        throw new Error('Cannot call server.listen in middleware mode.');
    }
    const options = server.config.server;
    const port = inlinePort || options.port || 3000;
    const hostname = resolveHostname(options.host);
    const protocol = options.https ? 'https' : 'http';
    const info = server.config.logger.info;
    const base = server.config.base;
    const serverPort = await httpServerStart(httpServer, {
        port,
        strictPort: options.strictPort,
        host: hostname.host,
        logger: server.config.logger
    });
    info(chalk__default.cyan(`\n  vite v${require('vite/package.json').version}`) +
        chalk__default.green(` dev server running at:\n`), {
        clear: !server.config.logger.hasWarned
    });
    printServerUrls(hostname, protocol, serverPort, base, info);
    // @ts-ignore
    if (global.__vite_start_time) {
        info(chalk__default.cyan(
        // @ts-ignore
        `\n  ready in ${Date.now() - global.__vite_start_time}ms.\n`));
    }
    // @ts-ignore
    const profileSession = global.__vite_profile_session;
    if (profileSession) {
        profileSession.post('Profiler.stop', (err, { profile }) => {
            // Write profile to disk, upload, etc.
            if (!err) {
                const outPath = path__default.resolve('./vite-profile.cpuprofile');
                fs__default.writeFileSync(outPath, JSON.stringify(profile));
                info(chalk__default.yellow(`  CPU profile written to ${chalk__default.white.dim(outPath)}\n`));
            }
            else {
                throw err;
            }
        });
    }
    if (options.open && !isRestart) {
        const path = typeof options.open === 'string' ? options.open : base;
        openBrowser(`${protocol}://${hostname.name}:${serverPort}${path}`, true, server.config.logger);
    }
    return server;
}
function createServerCloseFn(server) {
    if (!server) {
        return () => { };
    }
    let hasListened = false;
    const openSockets = new Set();
    server.on('connection', (socket) => {
        openSockets.add(socket);
        socket.on('close', () => {
            openSockets.delete(socket);
        });
    });
    server.once('listening', () => {
        hasListened = true;
    });
    return () => new Promise((resolve, reject) => {
        openSockets.forEach((s) => s.destroy());
        if (hasListened) {
            server.close((err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        }
        else {
            resolve();
        }
    });
}
function resolvedAllowDir(root, dir) {
    return ensureLeadingSlash(normalizePath(path__default.resolve(root, dir)));
}
function resolveServerOptions(root, raw) {
    var _a, _b;
    const server = raw || {};
    let allowDirs = (_a = server.fs) === null || _a === void 0 ? void 0 : _a.allow;
    if (!allowDirs) {
        allowDirs = [searchForWorkspaceRoot(root)];
    }
    allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i));
    // only push client dir when vite itself is outside-of-root
    const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR);
    if (!allowDirs.some((i) => resolvedClientDir.startsWith(i))) {
        allowDirs.push(resolvedClientDir);
    }
    server.fs = {
        // TODO: make strict by default
        strict: (_b = server.fs) === null || _b === void 0 ? void 0 : _b.strict,
        allow: allowDirs
    };
    return server;
}

var index = {
    __proto__: null,
    createServer: createServer,
    resolveServerOptions: resolveServerOptions
};

/**
 * https://github.com/rollup/plugins/blob/master/packages/json/src/index.js
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/rollup/plugins/blob/master/LICENSE
 */
// Custom json filter for vite
const jsonExtRE = /\.json($|\?)(?!commonjs-proxy)/;
function jsonPlugin(options = {}, isBuild) {
    return {
        name: 'vite:json',
        transform(json, id) {
            if (!jsonExtRE.test(id))
                return null;
            if (SPECIAL_QUERY_RE.test(id))
                return null;
            try {
                if (options.stringify) {
                    if (isBuild) {
                        return {
                            // during build, parse then double-stringify to remove all
                            // unnecessary whitespaces to reduce bundle size.
                            code: `export default JSON.parse(${JSON.stringify(JSON.stringify(JSON.parse(json)))})`,
                            map: { mappings: '' }
                        };
                    }
                    else {
                        return `export default JSON.parse(${JSON.stringify(json)})`;
                    }
                }
                const parsed = JSON.parse(json);
                return {
                    code: pluginutils.dataToEsm(parsed, {
                        preferConst: true,
                        namedExports: options.namedExports
                    }),
                    map: { mappings: '' }
                };
            }
            catch (e) {
                const errorMessageList = /[\d]+/.exec(e.message);
                const position = errorMessageList && parseInt(errorMessageList[0], 10);
                const msg = position
                    ? `, invalid JSON syntax found at line ${position}`
                    : `.`;
                this.error(`Failed to parse JSON file` + msg, e.idx);
            }
        }
    };
}

const isDebug = !!process.env.DEBUG;
const debug$1 = createDebugger('vite:import-analysis');
const clientDir = normalizePath(CLIENT_DIR);
const skipRE = /\.(map|json)$/;
const canSkip = (id) => skipRE.test(id) || isDirectCSSRequest(id);
function isExplicitImportRequired(url) {
    return !isJSRequest(cleanUrl(url)) && !isCSSRequest(url);
}
function markExplicitImport(url) {
    if (isExplicitImportRequired(url)) {
        return injectQuery(url, 'import');
    }
    return url;
}
/**
 * Server-only plugin that lexes, resolves, rewrites and analyzes url imports.
 *
 * - Imports are resolved to ensure they exist on disk
 *
 * - Lexes HMR accept calls and updates import relationships in the module graph
 *
 * - Bare module imports are resolved (by @rollup-plugin/node-resolve) to
 * absolute file paths, e.g.
 *
 *     ```js
 *     import 'foo'
 *     ```
 *     is rewritten to
 *     ```js
 *     import '/@fs//project/node_modules/foo/dist/foo.js'
 *     ```
 *
 * - CSS imports are appended with `.js` since both the js module and the actual
 * css (referenced via <link>) may go through the transform pipeline:
 *
 *     ```js
 *     import './style.css'
 *     ```
 *     is rewritten to
 *     ```js
 *     import './style.css.js'
 *     ```
 */
function importAnalysisPlugin(config) {
    const { root, base } = config;
    const clientPublicPath = path__default.posix.join(base, CLIENT_PUBLIC_PATH);
    let server;
    return {
        name: 'vite:import-analysis',
        configureServer(_server) {
            server = _server;
        },
        async transform(source, importer, ssr) {
            const prettyImporter = prettifyUrl(importer, root);
            if (canSkip(importer)) {
                isDebug && debug$1(chalk__default.dim(`[skipped] ${prettyImporter}`));
                return null;
            }
            const start = Date.now();
            await esModuleLexer.init;
            let imports = [];
            // strip UTF-8 BOM
            if (source.charCodeAt(0) === 0xfeff) {
                source = source.slice(1);
            }
            try {
                imports = esModuleLexer.parse(source)[0];
            }
            catch (e) {
                const isVue = importer.endsWith('.vue');
                const maybeJSX = !isVue && isJSRequest(importer);
                const msg = isVue
                    ? `Install @vitejs/plugin-vue to handle .vue files.`
                    : maybeJSX
                        ? `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.`
                        : `You may need to install appropriate plugins to handle the ${path__default.extname(importer)} file format.`;
                this.error(`Failed to parse source for import analysis because the content ` +
                    `contains invalid JS syntax. ` +
                    msg, e.idx);
            }
            if (!imports.length) {
                isDebug &&
                    debug$1(`${timeFrom(start)} ${chalk__default.dim(`[no imports] ${prettyImporter}`)}`);
                return source;
            }
            let hasHMR = false;
            let isSelfAccepting = false;
            let hasEnv = false;
            let needQueryInjectHelper = false;
            let s;
            const str = () => s || (s = new MagicString__default(source));
            // vite-only server context
            const { moduleGraph } = server;
            // since we are already in the transform phase of the importer, it must
            // have been loaded so its entry is guaranteed in the module graph.
            const importerModule = moduleGraph.getModuleById(importer);
            const importedUrls = new Set();
            const acceptedUrls = new Set();
            const toAbsoluteUrl = (url) => path__default.posix.resolve(path__default.posix.dirname(importerModule.url), url);
            const normalizeUrl = async (url, pos) => {
                if (base !== '/' && url.startsWith(base)) {
                    url = url.replace(base, '/');
                }
                const resolved = await this.resolve(url, importer);
                if (!resolved) {
                    this.error(`Failed to resolve import "${url}" from "${path__default.relative(process.cwd(), importer)}". Does the file exist?`, pos);
                }
                const isRelative = url.startsWith('.');
                const isSelfImport = !isRelative && cleanUrl(url) === cleanUrl(importer);
                // normalize all imports into resolved URLs
                // e.g. `import 'foo'` -> `import '/@fs/.../node_modules/foo/index.js`
                if (resolved.id.startsWith(root + '/')) {
                    // in root: infer short absolute path from root
                    url = resolved.id.slice(root.length);
                }
                else if (fs__default.existsSync(cleanUrl(resolved.id))) {
                    // exists but out of root: rewrite to absolute /@fs/ paths
                    url = path__default.posix.join(FS_PREFIX + resolved.id);
                }
                else {
                    url = resolved.id;
                }
                if (isExternalUrl(url)) {
                    return [url, url];
                }
                // if the resolved id is not a valid browser import specifier,
                // prefix it to make it valid. We will strip this before feeding it
                // back into the transform pipeline
                if (!url.startsWith('.') && !url.startsWith('/')) {
                    url =
                        VALID_ID_PREFIX + resolved.id.replace('\0', NULL_BYTE_PLACEHOLDER);
                }
                // make the URL browser-valid if not SSR
                if (!ssr) {
                    // mark non-js/css imports with `?import`
                    url = markExplicitImport(url);
                    // for relative js/css imports, or self-module virtual imports
                    // (e.g. vue blocks), inherit importer's version query
                    // do not do this for unknown type imports, otherwise the appended
                    // query can break 3rd party plugin's extension checks.
                    if ((isRelative || isSelfImport) && !/[\?&]import=?\b/.test(url)) {
                        const versionMatch = importer.match(DEP_VERSION_RE);
                        if (versionMatch) {
                            url = injectQuery(url, versionMatch[1]);
                        }
                    }
                    // check if the dep has been hmr updated. If yes, we need to attach
                    // its last updated timestamp to force the browser to fetch the most
                    // up-to-date version of this module.
                    try {
                        const depModule = await moduleGraph.ensureEntryFromUrl(url);
                        if (depModule.lastHMRTimestamp > 0) {
                            url = injectQuery(url, `t=${depModule.lastHMRTimestamp}`);
                        }
                    }
                    catch (e) {
                        // it's possible that the dep fails to resolve (non-existent import)
                        // attach location to the missing import
                        e.pos = pos;
                        throw e;
                    }
                    // prepend base (dev base is guaranteed to have ending slash)
                    url = base + url.replace(/^\//, '');
                }
                return [url, resolved.id];
            };
            for (let index = 0; index < imports.length; index++) {
                const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex, 
                // #2083 User may use escape path,
                // so use imports[index].n to get the unescaped string
                // @ts-ignore
                n: specifier } = imports[index];
                const rawUrl = source.slice(start, end);
                // check import.meta usage
                if (rawUrl === 'import.meta') {
                    const prop = source.slice(end, end + 4);
                    if (prop === '.hot') {
                        hasHMR = true;
                        if (source.slice(end + 4, end + 11) === '.accept') {
                            // further analyze accepted modules
                            if (lexAcceptedHmrDeps(source, source.indexOf('(', end + 11) + 1, acceptedUrls)) {
                                isSelfAccepting = true;
                            }
                        }
                    }
                    else if (prop === '.env') {
                        hasEnv = true;
                    }
                    else if (prop === '.glo' && source[end + 4] === 'b') {
                        // transform import.meta.glob()
                        // e.g. `import.meta.glob('glob:./dir/*.js')`
                        const { imports, importsString, exp, endIndex, base, pattern } = await transformImportGlob(source, start, importer, index, root, normalizeUrl);
                        str().prepend(importsString);
                        str().overwrite(expStart, endIndex, exp);
                        imports.forEach((url) => importedUrls.add(url.replace(base, '/')));
                        if (!(importerModule.file in server._globImporters)) {
                            server._globImporters[importerModule.file] = {
                                module: importerModule,
                                importGlobs: []
                            };
                        }
                        server._globImporters[importerModule.file].importGlobs.push({
                            base,
                            pattern
                        });
                    }
                    continue;
                }
                const isDynamicImport = dynamicIndex >= 0;
                // static import or valid string in dynamic import
                // If resolvable, let's resolve it
                if (specifier) {
                    // skip external / data uri
                    if (isExternalUrl(specifier) || isDataUrl(specifier)) {
                        continue;
                    }
                    // skip ssr external
                    if (ssr) {
                        if (server._ssrExternals &&
                            shouldExternalizeForSSR(specifier, server._ssrExternals)) {
                            continue;
                        }
                        if (isBuiltin(specifier)) {
                            continue;
                        }
                    }
                    // skip client
                    if (specifier === clientPublicPath) {
                        continue;
                    }
                    // warn imports to non-asset /public files
                    if (specifier.startsWith('/') &&
                        !config.assetsInclude(cleanUrl(specifier)) &&
                        !specifier.endsWith('.json') &&
                        checkPublicFile(specifier, config)) {
                        throw new Error(`Cannot import non-asset file ${specifier} which is inside /public.` +
                            `JS/CSS files inside /public are copied as-is on build and ` +
                            `can only be referenced via <script src> or <link href> in html.`);
                    }
                    // normalize
                    const [normalizedUrl, resolvedId] = await normalizeUrl(specifier, start);
                    let url = normalizedUrl;
                    // record as safe modules
                    server === null || server === void 0 ? void 0 : server.moduleGraph.safeModulesPath.add(cleanUrl(url).slice(4 /* '/@fs'.length */));
                    // rewrite
                    if (url !== specifier) {
                        // for optimized cjs deps, support named imports by rewriting named
                        // imports to const assignments.
                        if (resolvedId.endsWith(`&es-interop`)) {
                            url = url.slice(0, -11);
                            if (isDynamicImport) {
                                // rewrite `import('package')` to expose the default directly
                                str().overwrite(dynamicIndex, end + 1, `import('${url}').then(m => m.default && m.default.__esModule ? m.default : ({ ...m.default, default: m.default }))`);
                            }
                            else {
                                const exp = source.slice(expStart, expEnd);
                                const rewritten = transformCjsImport(exp, url, rawUrl, index);
                                if (rewritten) {
                                    str().overwrite(expStart, expEnd, rewritten);
                                }
                                else {
                                    // #1439 export * from '...'
                                    str().overwrite(start, end, url);
                                }
                            }
                        }
                        else {
                            str().overwrite(start, end, isDynamicImport ? `'${url}'` : url);
                        }
                    }
                    // record for HMR import chain analysis
                    // make sure to normalize away base
                    importedUrls.add(url.replace(base, '/'));
                }
                else if (!importer.startsWith(clientDir) && !ssr) {
                    // check @vite-ignore which suppresses dynamic import warning
                    const hasViteIgnore = /\/\*\s*@vite-ignore\s*\*\//.test(rawUrl);
                    const url = rawUrl
                        .replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '')
                        .trim();
                    if (!hasViteIgnore && !isSupportedDynamicImport(url)) {
                        this.warn(`\n` +
                            chalk__default.cyan(importerModule.file) +
                            `\n` +
                            generateCodeFrame(source, start) +
                            `\nThe above dynamic import cannot be analyzed by vite.\n` +
                            `See ${chalk__default.blue(`https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`)} ` +
                            `for supported dynamic import formats. ` +
                            `If this is intended to be left as-is, you can use the ` +
                            `/* @vite-ignore */ comment inside the import() call to suppress this warning.\n`);
                    }
                    if (!/^('.*'|".*"|`.*`)$/.test(url) ||
                        isExplicitImportRequired(url.slice(1, -1))) {
                        needQueryInjectHelper = true;
                        str().overwrite(start, end, `__vite__injectQuery(${url}, 'import')`);
                    }
                }
            }
            if (hasEnv) {
                // inject import.meta.env
                let env = `import.meta.env = ${JSON.stringify({
                    ...config.env,
                    SSR: !!ssr
                })};`;
                // account for user env defines
                for (const key in config.define) {
                    if (key.startsWith(`import.meta.env.`)) {
                        const val = config.define[key];
                        env += `${key} = ${typeof val === 'string' ? val : JSON.stringify(val)};`;
                    }
                }
                str().prepend(env);
            }
            if (hasHMR && !ssr) {
                debugHmr(`${isSelfAccepting
                    ? `[self-accepts]`
                    : acceptedUrls.size
                        ? `[accepts-deps]`
                        : `[detected api usage]`} ${prettyImporter}`);
                // inject hot context
                str().prepend(`import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";` +
                    `import.meta.hot = __vite__createHotContext(${JSON.stringify(importerModule.url)});`);
            }
            if (needQueryInjectHelper) {
                str().prepend(`import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`);
            }
            // normalize and rewrite accepted urls
            const normalizedAcceptedUrls = new Set();
            for (const { url, start, end } of acceptedUrls) {
                const [normalized] = await moduleGraph.resolveUrl(toAbsoluteUrl(markExplicitImport(url)));
                normalizedAcceptedUrls.add(normalized);
                str().overwrite(start, end, JSON.stringify(normalized));
            }
            // update the module graph for HMR analysis.
            // node CSS imports does its own graph update in the css plugin so we
            // only handle js graph updates here.
            if (!isCSSRequest(importer)) {
                // attached by pluginContainer.addWatchFile
                const pluginImports = this._addedImports;
                if (pluginImports) {
                    (await Promise.all([...pluginImports].map((id) => normalizeUrl(id, 0)))).forEach(([url]) => importedUrls.add(url));
                }
                const prunedImports = await moduleGraph.updateModuleInfo(importerModule, importedUrls, normalizedAcceptedUrls, isSelfAccepting);
                if (hasHMR && prunedImports) {
                    handlePrunedModules(prunedImports, server);
                }
            }
            isDebug &&
                debug$1(`${timeFrom(start)} ${chalk__default.dim(`[${importedUrls.size} imports rewritten] ${prettyImporter}`)}`);
            if (s) {
                return s.toString();
            }
            else {
                return source;
            }
        }
    };
}
/**
 * https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations
 * This is probably less accurate but is much cheaper than a full AST parse.
 */
function isSupportedDynamicImport(url) {
    url = url.trim().slice(1, -1);
    // must be relative
    if (!url.startsWith('./') && !url.startsWith('../')) {
        return false;
    }
    // must have extension
    if (!path__default.extname(url)) {
        return false;
    }
    // must be more specific if importing from same dir
    if (url.startsWith('./${') && url.indexOf('/') === url.lastIndexOf('/')) {
        return false;
    }
    return true;
}
/**
 * Detect import statements to a known optimized CJS dependency and provide
 * ES named imports interop. We do this by rewriting named imports to a variable
 * assignment to the corresponding property on the `module.exports` of the cjs
 * module. Note this doesn't support dynamic re-assignments from within the cjs
 * module.
 *
 * Note that es-module-lexer treats `export * from '...'` as an import as well,
 * so, we may encounter ExportAllDeclaration here, in which case `undefined`
 * will be returned.
 *
 * Credits \@csr632 via #837
 */
function transformCjsImport(importExp, url, rawUrl, importIndex) {
    const node = acorn.parse(importExp, {
        ecmaVersion: 2020,
        sourceType: 'module'
    }).body[0];
    if (node.type === 'ImportDeclaration') {
        if (!node.specifiers.length) {
            return `import "${url}"`;
        }
        const importNames = [];
        for (const spec of node.specifiers) {
            if (spec.type === 'ImportSpecifier' &&
                spec.imported.type === 'Identifier') {
                const importedName = spec.imported.name;
                const localName = spec.local.name;
                importNames.push({ importedName, localName });
            }
            else if (spec.type === 'ImportDefaultSpecifier') {
                importNames.push({
                    importedName: 'default',
                    localName: spec.local.name
                });
            }
            else if (spec.type === 'ImportNamespaceSpecifier') {
                importNames.push({ importedName: '*', localName: spec.local.name });
            }
        }
        // If there is multiple import for same id in one file,
        // importIndex will prevent the cjsModuleName to be duplicate
        const cjsModuleName = pluginutils.makeLegalIdentifier(`__vite__cjsImport${importIndex}_${rawUrl}`);
        const lines = [`import ${cjsModuleName} from "${url}"`];
        importNames.forEach(({ importedName, localName }) => {
            if (importedName === '*') {
                lines.push(`const ${localName} = ${cjsModuleName}`);
            }
            else if (importedName === 'default') {
                lines.push(`const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`);
            }
            else {
                lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
            }
        });
        return lines.join('; ');
    }
}

// ids in transform are normalized to unix style
const normalizedClientEntry = normalizePath(CLIENT_ENTRY);
const normalizedEnvEntry = normalizePath(ENV_ENTRY);
/**
 * some values used by the client needs to be dynamically injected by the server
 * @server-only
 */
function clientInjectionsPlugin(config) {
    return {
        name: 'vite:client-inject',
        transform(code, id) {
            if (id === normalizedClientEntry || id === normalizedEnvEntry) {
                let options = config.server.hmr;
                options = options && typeof options !== 'boolean' ? options : {};
                const host = options.host || null;
                const protocol = options.protocol || null;
                const timeout = options.timeout || 30000;
                const overlay = options.overlay !== false;
                let port;
                if (isObject(config.server.hmr)) {
                    port = config.server.hmr.clientPort || config.server.hmr.port;
                }
                if (config.server.middlewareMode) {
                    port = String(port || 24678);
                }
                else {
                    port = String(port || options.port || config.server.port);
                }
                let hmrBase = config.base;
                if (options.path) {
                    hmrBase = path__default.posix.join(hmrBase, options.path);
                }
                if (hmrBase !== '/') {
                    port = path__default.posix.normalize(`${port}${hmrBase}`);
                }
                return code
                    .replace(`__MODE__`, JSON.stringify(config.mode))
                    .replace(`__BASE__`, JSON.stringify(config.base))
                    .replace(`__DEFINES__`, serializeDefine(config.define || {}))
                    .replace(`__HMR_PROTOCOL__`, JSON.stringify(protocol))
                    .replace(`__HMR_HOSTNAME__`, JSON.stringify(host))
                    .replace(`__HMR_PORT__`, JSON.stringify(port))
                    .replace(`__HMR_TIMEOUT__`, JSON.stringify(timeout))
                    .replace(`__HMR_ENABLE_OVERLAY__`, JSON.stringify(overlay));
            }
            else if (code.includes('process.env.NODE_ENV')) {
                // replace process.env.NODE_ENV
                return code.replace(/\bprocess\.env\.NODE_ENV\b/g, JSON.stringify(config.mode));
            }
        }
    };
}
function serializeDefine(define) {
    let res = `{`;
    for (const key in define) {
        const val = define[key];
        res += `${JSON.stringify(key)}: ${typeof val === 'string' ? `(${val})` : JSON.stringify(val)}, `;
    }
    return res + `}`;
}

const wasmHelperId = '/__vite-wasm-helper';
const wasmHelper = async (opts = {}, url) => {
    let result;
    if (url.startsWith('data:')) {
        // @ts-ignore
        const binaryString = atob(url.replace(/^data:.*?base64,/, ''));
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        // @ts-ignore
        result = await WebAssembly.instantiate(bytes, opts);
    }
    else {
        // https://github.com/mdn/webassembly-examples/issues/5
        // WebAssembly.instantiateStreaming requires the server to provide the
        // correct MIME type for .wasm files, which unfortunately doesn't work for
        // a lot of static file servers, so we just work around it by getting the
        // raw buffer.
        // @ts-ignore
        const response = await fetch(url);
        const contentType = response.headers.get('Content-Type') || '';
        if (
        // @ts-ignore
        'instantiateStreaming' in WebAssembly &&
            contentType.startsWith('application/wasm')) {
            // @ts-ignore
            result = await WebAssembly.instantiateStreaming(response, opts);
        }
        else {
            const buffer = await response.arrayBuffer();
            // @ts-ignore
            result = await WebAssembly.instantiate(buffer, opts);
        }
    }
    return result.instance.exports;
};
const wasmHelperCode = wasmHelper.toString();
const wasmPlugin = (config) => {
    return {
        name: 'vite:wasm',
        resolveId(id) {
            if (id === wasmHelperId) {
                return id;
            }
        },
        async load(id) {
            if (id === wasmHelperId) {
                return `export default ${wasmHelperCode}`;
            }
            if (!id.endsWith('.wasm')) {
                return;
            }
            const url = await fileToUrl(id, config, this);
            return `
import initWasm from "${wasmHelperId}"
export default opts => initWasm(opts, ${JSON.stringify(url)})
`;
        }
    };
};

function parseWorkerRequest(id) {
    const { search } = url.parse(id);
    if (!search) {
        return null;
    }
    return Object.fromEntries(new url.URLSearchParams(search.slice(1)));
}
const WorkerFileId = 'worker_file';
function webWorkerPlugin(config) {
    const isBuild = config.command === 'build';
    return {
        name: 'vite:worker',
        load(id) {
            var _a;
            if (isBuild) {
                const parsedQuery = parseWorkerRequest(id);
                if (parsedQuery &&
                    ((_a = parsedQuery.worker) !== null && _a !== void 0 ? _a : parsedQuery.sharedworker) != null) {
                    return '';
                }
            }
        },
        async transform(_, id) {
            var _a;
            const query = parseWorkerRequest(id);
            if (query && query[WorkerFileId] != null) {
                return {
                    code: `import '${ENV_PUBLIC_PATH}'\n` + _
                };
            }
            if (query == null ||
                (query && ((_a = query.worker) !== null && _a !== void 0 ? _a : query.sharedworker) == null)) {
                return;
            }
            let url;
            if (isBuild) {
                // bundle the file as entry to support imports
                const rollup = require('rollup');
                const bundle = await rollup.rollup({
                    input: cleanUrl(id),
                    plugins: await resolvePlugins({ ...config }, [], [], []),
                    onwarn(warning, warn) {
                        onRollupWarning(warning, warn, config);
                    }
                });
                let code;
                try {
                    const { output } = await bundle.generate({
                        format: 'iife',
                        sourcemap: config.build.sourcemap
                    });
                    code = output[0].code;
                }
                finally {
                    await bundle.close();
                }
                const content = Buffer.from(code);
                if (query.inline != null) {
                    // inline as blob data url
                    return `const encodedJs = "${content.toString('base64')}";
            const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper() {
              const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
              try {
                return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs, {type: "module"});
              } finally {
                objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
              }
            }`;
                }
                else {
                    const basename = path__default.parse(cleanUrl(id)).name;
                    const contentHash = getAssetHash(content);
                    const fileName = path__default.posix.join(config.build.assetsDir, `${basename}.${contentHash}.js`);
                    url = `__VITE_ASSET__${this.emitFile({
                        fileName,
                        type: 'asset',
                        source: code
                    })}__`;
                }
            }
            else {
                url = await fileToUrl(cleanUrl(id), config, this);
                url = injectQuery(url, WorkerFileId);
            }
            const workerConstructor = query.sharedworker != null ? 'SharedWorker' : 'Worker';
            const workerOptions = { type: 'module' };
            return `export default function WorkerWrapper() {
        return new ${workerConstructor}(${JSON.stringify(url)}, ${JSON.stringify(workerOptions, null, 2)})
      }`;
        }
    };
}

/**
 * A plugin to avoid an aliased AND optimized dep from being aliased in src
 */
function preAliasPlugin() {
    let server;
    return {
        name: 'vite:pre-alias',
        configureServer(_server) {
            server = _server;
        },
        resolveId(id, importer, _, ssr) {
            if (!ssr && bareImportRE.test(id)) {
                return tryOptimizedResolve(id, server, importer);
            }
        }
    };
}

function definePlugin(config) {
    const isBuild = config.command === 'build';
    const userDefine = {};
    for (const key in config.define) {
        const val = config.define[key];
        userDefine[key] = typeof val === 'string' ? val : JSON.stringify(val);
    }
    // during dev, import.meta properties are handled by importAnalysis plugin
    const importMetaKeys = {};
    if (isBuild) {
        const env = {
            ...config.env,
            SSR: !!config.build.ssr
        };
        for (const key in env) {
            importMetaKeys[`import.meta.env.${key}`] = JSON.stringify(env[key]);
        }
        Object.assign(importMetaKeys, {
            'import.meta.env.': `({}).`,
            'import.meta.env': JSON.stringify(config.env),
            'import.meta.hot': `false`
        });
    }
    const replacements = {
        'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode),
        'global.process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode),
        'globalThis.process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode),
        ...userDefine,
        ...importMetaKeys,
        'process.env.': `({}).`,
        'global.process.env.': `({}).`,
        'globalThis.process.env.': `({}).`
    };
    const pattern = new RegExp(
    // Do not allow preceding '.', but do allow preceding '...' for spread operations
    '(?<!(?<!\\.\\.)\\.)\\b(' +
        Object.keys(replacements)
            .map((str) => {
            return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
        })
            .join('|') +
        ')\\b', 'g');
    return {
        name: 'vite:define',
        transform(code, id, ssr) {
            if (!ssr && !isBuild) {
                // for dev we inject actual global defines in the vite client to
                // avoid the transform cost.
                return;
            }
            if (
            // exclude css and static assets for performance
            isCSSRequest(id) ||
                config.assetsInclude(id)) {
                return;
            }
            if (ssr && !isBuild) {
                // ssr + dev, simple replace
                return code.replace(pattern, (_, match) => {
                    return '' + replacements[match];
                });
            }
            const s = new MagicString__default(code);
            let hasReplaced = false;
            let match;
            while ((match = pattern.exec(code))) {
                hasReplaced = true;
                const start = match.index;
                const end = start + match[0].length;
                const replacement = '' + replacements[match[1]];
                s.overwrite(start, end, replacement);
            }
            if (!hasReplaced) {
                return null;
            }
            const result = { code: s.toString() };
            if (config.build.sourcemap) {
                result.map = s.generateMap({ hires: true });
            }
            return result;
        }
    };
}

async function resolvePlugins(config, prePlugins, normalPlugins, postPlugins) {
    const isBuild = config.command === 'build';
    const buildPlugins = isBuild
        ? (await Promise.resolve().then(function () { return build$1; })).resolveBuildPlugins(config)
        : { pre: [], post: [] };
    return [
        isBuild ? null : preAliasPlugin(),
        aliasPlugin__default({ entries: config.resolve.alias }),
        ...prePlugins,
        config.build.polyfillModulePreload
            ? modulePreloadPolyfillPlugin(config)
            : null,
        resolvePlugin({
            ...config.resolve,
            root: config.root,
            isProduction: config.isProduction,
            isBuild,
            ssrConfig: config.ssr,
            asSrc: true
        }),
        htmlInlineScriptProxyPlugin(),
        cssPlugin(config),
        config.esbuild !== false ? esbuildPlugin(config.esbuild) : null,
        jsonPlugin({
            namedExports: true,
            ...config.json
        }, isBuild),
        wasmPlugin(config),
        webWorkerPlugin(config),
        assetPlugin(config),
        ...normalPlugins,
        definePlugin(config),
        cssPostPlugin(config),
        ...buildPlugins.pre,
        ...postPlugins,
        ...buildPlugins.post,
        // internal server-only plugins are always applied after everything else
        ...(isBuild
            ? []
            : [clientInjectionsPlugin(config), importAnalysisPlugin(config)])
    ].filter(Boolean);
}

const debug = createDebugger('vite:config');
/**
 * Type helper to make it easier to use vite.config.ts
 * accepts a direct {@link UserConfig} object, or a function that returns it.
 * The function receives a {@link ConfigEnv} object that exposes two properties:
 * `command` (either `'build'` or `'serve'`), and `mode`.
 */
function defineConfig(config) {
    return config;
}
async function resolveConfig(inlineConfig, command, defaultMode = 'development') {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let config = inlineConfig;
    let configFileDependencies = [];
    let mode = inlineConfig.mode || defaultMode;
    // some dependencies e.g. @vue/compiler-* relies on NODE_ENV for getting
    // production-specific behavior, so set it here even though we haven't
    // resolve the final mode yet
    if (mode === 'production') {
        process.env.NODE_ENV = 'production';
    }
    const configEnv = {
        mode,
        command
    };
    let { configFile } = config;
    if (configFile !== false) {
        const loadResult = await loadConfigFromFile(configEnv, configFile, config.root, config.logLevel);
        if (loadResult) {
            config = mergeConfig(loadResult.config, config);
            configFile = loadResult.path;
            configFileDependencies = loadResult.dependencies;
        }
    }
    // Define logger
    const logger = createLogger(config.logLevel, {
        allowClearScreen: config.clearScreen,
        customLogger: config.customLogger
    });
    // user config may provide an alternative mode. But --mode has a higher prority
    mode = inlineConfig.mode || config.mode || mode;
    configEnv.mode = mode;
    // resolve plugins
    const rawUserPlugins = (config.plugins || []).flat().filter((p) => {
        if (!p) {
            return false;
        }
        else if (!p.apply) {
            return true;
        }
        else if (typeof p.apply === 'function') {
            return p.apply({ ...config, mode }, configEnv);
        }
        else {
            return p.apply === command;
        }
    });
    const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawUserPlugins);
    // run config hooks
    const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
    for (const p of userPlugins) {
        if (p.config) {
            const res = await p.config(config, configEnv);
            if (res) {
                config = mergeConfig(config, res);
            }
        }
    }
    // resolve root
    const resolvedRoot = normalizePath(config.root ? path__default.resolve(config.root) : process.cwd());
    const clientAlias = [
        { find: /^[\/]?@vite\/env/, replacement: () => ENV_ENTRY },
        { find: /^[\/]?@vite\/client/, replacement: () => CLIENT_ENTRY }
    ];
    // resolve alias with internal client alias
    const resolvedAlias = mergeAlias(
    // @ts-ignore because @rollup/plugin-alias' type doesn't allow function
    // replacement, but its implementation does work with function values.
    clientAlias, ((_a = config.resolve) === null || _a === void 0 ? void 0 : _a.alias) || config.alias || []);
    const resolveOptions = {
        dedupe: config.dedupe,
        ...config.resolve,
        alias: resolvedAlias
    };
    // load .env files
    const envDir = config.envDir
        ? normalizePath(path__default.resolve(resolvedRoot, config.envDir))
        : resolvedRoot;
    const userEnv = inlineConfig.envFile !== false &&
        loadEnv(mode, envDir, resolveEnvPrefix(config));
    // Note it is possible for user to have a custom mode, e.g. `staging` where
    // production-like behavior is expected. This is indicated by NODE_ENV=production
    // loaded from `.staging.env` and set by us as VITE_USER_NODE_ENV
    const isProduction = (process.env.VITE_USER_NODE_ENV || mode) === 'production';
    if (isProduction) {
        // in case default mode was not production and is overwritten
        process.env.NODE_ENV = 'production';
    }
    // resolve public base url
    const BASE_URL = resolveBaseUrl(config.base, command === 'build', logger);
    const resolvedBuildOptions = resolveBuildOptions(config.build);
    // resolve cache directory
    const pkgPath = lookupFile(resolvedRoot, [`package.json`], true /* pathOnly */);
    const cacheDir = config.cacheDir
        ? path__default.resolve(resolvedRoot, config.cacheDir)
        : pkgPath && path__default.join(path__default.dirname(pkgPath), `node_modules/.vite`);
    const assetsFilter = config.assetsInclude
        ? pluginutils.createFilter(config.assetsInclude)
        : () => false;
    // create an internal resolver to be used in special scenarios, e.g.
    // optimizer & handling css @imports
    const createResolver = (options) => {
        let aliasContainer;
        let resolverContainer;
        return async (id, importer, aliasOnly, ssr) => {
            var _a;
            let container;
            if (aliasOnly) {
                container =
                    aliasContainer ||
                        (aliasContainer = await createPluginContainer({
                            ...resolved,
                            plugins: [aliasPlugin__default({ entries: resolved.resolve.alias })]
                        }));
            }
            else {
                container =
                    resolverContainer ||
                        (resolverContainer = await createPluginContainer({
                            ...resolved,
                            plugins: [
                                aliasPlugin__default({ entries: resolved.resolve.alias }),
                                resolvePlugin({
                                    ...resolved.resolve,
                                    root: resolvedRoot,
                                    isProduction,
                                    isBuild: command === 'build',
                                    ssrConfig: resolved.ssr,
                                    asSrc: true,
                                    preferRelative: false,
                                    tryIndex: true,
                                    ...options
                                })
                            ]
                        }));
            }
            return (_a = (await container.resolveId(id, importer, undefined, ssr))) === null || _a === void 0 ? void 0 : _a.id;
        };
    };
    const { publicDir } = config;
    const resolvedPublicDir = publicDir !== false && publicDir !== ''
        ? path__default.resolve(resolvedRoot, typeof publicDir === 'string' ? publicDir : 'public')
        : '';
    const resolved = {
        ...config,
        configFile: configFile ? normalizePath(configFile) : undefined,
        configFileDependencies,
        inlineConfig,
        root: resolvedRoot,
        base: BASE_URL,
        resolve: resolveOptions,
        publicDir: resolvedPublicDir,
        cacheDir,
        command,
        mode,
        isProduction,
        plugins: userPlugins,
        server: resolveServerOptions(resolvedRoot, config.server),
        build: resolvedBuildOptions,
        env: {
            ...userEnv,
            BASE_URL,
            MODE: mode,
            DEV: !isProduction,
            PROD: isProduction
        },
        assetsInclude(file) {
            return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
        },
        logger,
        createResolver,
        optimizeDeps: {
            ...config.optimizeDeps,
            esbuildOptions: {
                keepNames: (_b = config.optimizeDeps) === null || _b === void 0 ? void 0 : _b.keepNames,
                preserveSymlinks: (_c = config.resolve) === null || _c === void 0 ? void 0 : _c.preserveSymlinks,
                ...(_d = config.optimizeDeps) === null || _d === void 0 ? void 0 : _d.esbuildOptions
            }
        }
    };
    resolved.plugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins);
    // call configResolved hooks
    await Promise.all(userPlugins.map((p) => { var _a; return (_a = p.configResolved) === null || _a === void 0 ? void 0 : _a.call(p, resolved); }));
    if (process.env.DEBUG) {
        debug(`using resolved config: %O`, {
            ...resolved,
            plugins: resolved.plugins.map((p) => p.name)
        });
    }
    // TODO Deprecation warnings - remove when out of beta
    const logDeprecationWarning = (deprecatedOption, hint, error) => {
        logger.warn(chalk__default.yellow.bold(`(!) "${deprecatedOption}" option is deprecated. ${hint}${error ? `\n${error.stack}` : ''}`));
    };
    if ((_e = config.build) === null || _e === void 0 ? void 0 : _e.base) {
        logDeprecationWarning('build.base', '"base" is now a root-level config option.');
        config.base = config.build.base;
    }
    Object.defineProperty(resolvedBuildOptions, 'base', {
        enumerable: false,
        get() {
            logDeprecationWarning('build.base', '"base" is now a root-level config option.', new Error());
            return resolved.base;
        }
    });
    if (config.alias) {
        logDeprecationWarning('alias', 'Use "resolve.alias" instead.');
    }
    Object.defineProperty(resolved, 'alias', {
        enumerable: false,
        get() {
            logDeprecationWarning('alias', 'Use "resolve.alias" instead.', new Error());
            return resolved.resolve.alias;
        }
    });
    if (config.dedupe) {
        logDeprecationWarning('dedupe', 'Use "resolve.dedupe" instead.');
    }
    Object.defineProperty(resolved, 'dedupe', {
        enumerable: false,
        get() {
            logDeprecationWarning('dedupe', 'Use "resolve.dedupe" instead.', new Error());
            return resolved.resolve.dedupe;
        }
    });
    if ((_f = config.optimizeDeps) === null || _f === void 0 ? void 0 : _f.keepNames) {
        logDeprecationWarning('optimizeDeps.keepNames', 'Use "optimizeDeps.esbuildOptions.keepNames" instead.');
    }
    Object.defineProperty(resolved.optimizeDeps, 'keepNames', {
        enumerable: false,
        get() {
            var _a;
            logDeprecationWarning('optimizeDeps.keepNames', 'Use "optimizeDeps.esbuildOptions.keepNames" instead.', new Error());
            return (_a = resolved.optimizeDeps.esbuildOptions) === null || _a === void 0 ? void 0 : _a.keepNames;
        }
    });
    if ((_g = config.build) === null || _g === void 0 ? void 0 : _g.polyfillDynamicImport) {
        logDeprecationWarning('build.polyfillDynamicImport', '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.');
    }
    Object.defineProperty(resolvedBuildOptions, 'polyfillDynamicImport', {
        enumerable: false,
        get() {
            logDeprecationWarning('build.polyfillDynamicImport', '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.', new Error());
            return false;
        }
    });
    if ((_h = config.build) === null || _h === void 0 ? void 0 : _h.cleanCssOptions) {
        logDeprecationWarning('build.cleanCssOptions', 'Vite now uses esbuild for CSS minification.');
    }
    return resolved;
}
/**
 * Resolve base. Note that some users use Vite to build for non-web targets like
 * electron or expects to deploy
 */
function resolveBaseUrl(base = '/', isBuild, logger) {
    // #1669 special treatment for empty for same dir relative base
    if (base === '' || base === './') {
        return isBuild ? base : '/';
    }
    if (base.startsWith('.')) {
        logger.warn(chalk__default.yellow.bold(`(!) invalid "base" option: ${base}. The value can only be an absolute ` +
            `URL, ./, or an empty string.`));
        base = '/';
    }
    // external URL
    if (isExternalUrl(base)) {
        if (!isBuild) {
            // get base from full url during dev
            const parsed = url.parse(base);
            base = parsed.pathname || '/';
        }
    }
    else {
        // ensure leading slash
        if (!base.startsWith('/')) {
            logger.warn(chalk__default.yellow.bold(`(!) "base" option should start with a slash.`));
            base = '/' + base;
        }
    }
    // ensure ending slash
    if (!base.endsWith('/')) {
        logger.warn(chalk__default.yellow.bold(`(!) "base" option should end with a slash.`));
        base += '/';
    }
    return base;
}
function mergeConfigRecursively(a, b, rootPath) {
    const merged = { ...a };
    for (const key in b) {
        const value = b[key];
        if (value == null) {
            continue;
        }
        const existing = merged[key];
        if (Array.isArray(existing) && Array.isArray(value)) {
            merged[key] = [...existing, ...value];
            continue;
        }
        if (isObject(existing) && isObject(value)) {
            merged[key] = mergeConfigRecursively(existing, value, rootPath ? `${rootPath}.${key}` : key);
            continue;
        }
        // fields that require special handling
        if (existing != null) {
            if (key === 'alias' && (rootPath === 'resolve' || rootPath === '')) {
                merged[key] = mergeAlias(existing, value);
                continue;
            }
            else if (key === 'assetsInclude' && rootPath === '') {
                merged[key] = [].concat(existing, value);
                continue;
            }
            else if (key === 'noExternal' && existing === true) {
                continue;
            }
        }
        merged[key] = value;
    }
    return merged;
}
function mergeConfig(a, b, isRoot = true) {
    return mergeConfigRecursively(a, b, isRoot ? '' : '.');
}
function mergeAlias(a = [], b = []) {
    return [...normalizeAlias(a), ...normalizeAlias(b)];
}
function normalizeAlias(o) {
    return Array.isArray(o)
        ? o.map(normalizeSingleAlias)
        : Object.keys(o).map((find) => normalizeSingleAlias({
            find,
            replacement: o[find]
        }));
}
// https://github.com/vitejs/vite/issues/1363
// work around https://github.com/rollup/plugins/issues/759
function normalizeSingleAlias({ find, replacement }) {
    if (typeof find === 'string' &&
        find.endsWith('/') &&
        replacement.endsWith('/')) {
        find = find.slice(0, find.length - 1);
        replacement = replacement.slice(0, replacement.length - 1);
    }
    return { find, replacement };
}
function sortUserPlugins(plugins) {
    const prePlugins = [];
    const postPlugins = [];
    const normalPlugins = [];
    if (plugins) {
        plugins.flat().forEach((p) => {
            if (p.enforce === 'pre')
                prePlugins.push(p);
            else if (p.enforce === 'post')
                postPlugins.push(p);
            else
                normalPlugins.push(p);
        });
    }
    return [prePlugins, normalPlugins, postPlugins];
}
async function loadConfigFromFile(configEnv, configFile, configRoot = process.cwd(), logLevel) {
    const start = Date.now();
    let resolvedPath;
    let isTS = false;
    let isMjs = false;
    let dependencies = [];
    // check package.json for type: "module" and set `isMjs` to true
    try {
        const pkg = lookupFile(configRoot, ['package.json']);
        if (pkg && JSON.parse(pkg).type === 'module') {
            isMjs = true;
        }
    }
    catch (e) { }
    if (configFile) {
        // explicit config path is always resolved from cwd
        resolvedPath = path__default.resolve(configFile);
        isTS = configFile.endsWith('.ts');
    }
    else {
        // implicit config file loaded from inline root (if present)
        // otherwise from cwd
        const jsconfigFile = path__default.resolve(configRoot, 'vite.config.js');
        if (fs__default.existsSync(jsconfigFile)) {
            resolvedPath = jsconfigFile;
        }
        if (!resolvedPath) {
            const mjsconfigFile = path__default.resolve(configRoot, 'vite.config.mjs');
            if (fs__default.existsSync(mjsconfigFile)) {
                resolvedPath = mjsconfigFile;
                isMjs = true;
            }
        }
        if (!resolvedPath) {
            const tsconfigFile = path__default.resolve(configRoot, 'vite.config.ts');
            if (fs__default.existsSync(tsconfigFile)) {
                resolvedPath = tsconfigFile;
                isTS = true;
            }
        }
    }
    if (!resolvedPath) {
        debug('no config file found.');
        return null;
    }
    try {
        let userConfig;
        if (isMjs) {
            const fileUrl = require('url').pathToFileURL(resolvedPath);
            if (isTS) {
                // before we can register loaders without requiring users to run node
                // with --experimental-loader themselves, we have to do a hack here:
                // bundle the config file w/ ts transforms first, write it to disk,
                // load it with native Node ESM, then delete the file.
                const bundled = await bundleConfigFile(resolvedPath, true);
                dependencies = bundled.dependencies;
                fs__default.writeFileSync(resolvedPath + '.js', bundled.code);
                userConfig = (await eval(`import(fileUrl + '.js?t=${Date.now()}')`))
                    .default;
                fs__default.unlinkSync(resolvedPath + '.js');
                debug(`TS + native esm config loaded in ${Date.now() - start}ms`, fileUrl);
            }
            else {
                // using eval to avoid this from being compiled away by TS/Rollup
                // append a query so that we force reload fresh config in case of
                // server restart
                userConfig = (await eval(`import(fileUrl + '?t=${Date.now()}')`))
                    .default;
                debug(`native esm config loaded in ${Date.now() - start}ms`, fileUrl);
            }
        }
        if (!userConfig && !isTS && !isMjs) {
            // 1. try to directly require the module (assuming commonjs)
            try {
                // clear cache in case of server restart
                delete require.cache[require.resolve(resolvedPath)];
                userConfig = require(resolvedPath);
                debug(`cjs config loaded in ${Date.now() - start}ms`);
            }
            catch (e) {
                const ignored = new RegExp([
                    `Cannot use import statement`,
                    `Must use import to load ES Module`,
                    // #1635, #2050 some Node 12.x versions don't have esm detection
                    // so it throws normal syntax errors when encountering esm syntax
                    `Unexpected token`,
                    `Unexpected identifier`
                ].join('|'));
                if (!ignored.test(e.message)) {
                    throw e;
                }
            }
        }
        if (!userConfig) {
            // 2. if we reach here, the file is ts or using es import syntax, or
            // the user has type: "module" in their package.json (#917)
            // transpile es import syntax to require syntax using rollup.
            // lazy require rollup (it's actually in dependencies)
            const bundled = await bundleConfigFile(resolvedPath);
            dependencies = bundled.dependencies;
            userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code);
            debug(`bundled config file loaded in ${Date.now() - start}ms`);
        }
        const config = await (typeof userConfig === 'function'
            ? userConfig(configEnv)
            : userConfig);
        if (!isObject(config)) {
            throw new Error(`config must export or return an object.`);
        }
        return {
            path: normalizePath(resolvedPath),
            config,
            dependencies
        };
    }
    catch (e) {
        createLogger(logLevel).error(chalk__default.red(`failed to load config from ${resolvedPath}`), { error: e });
        throw e;
    }
}
async function bundleConfigFile(fileName, mjs = false) {
    const result = await esbuild.build({
        absWorkingDir: process.cwd(),
        entryPoints: [fileName],
        outfile: 'out.js',
        write: false,
        platform: 'node',
        bundle: true,
        format: mjs ? 'esm' : 'cjs',
        sourcemap: 'inline',
        metafile: true,
        plugins: [
            {
                name: 'externalize-deps',
                setup(build) {
                    build.onResolve({ filter: /.*/ }, (args) => {
                        const id = args.path;
                        if (id[0] !== '.' && !path__default.isAbsolute(id)) {
                            return {
                                external: true
                            };
                        }
                    });
                }
            },
            {
                name: 'replace-import-meta',
                setup(build) {
                    build.onLoad({ filter: /\.[jt]s$/ }, async (args) => {
                        const contents = await fs__default.promises.readFile(args.path, 'utf8');
                        return {
                            loader: args.path.endsWith('.ts') ? 'ts' : 'js',
                            contents: contents
                                .replace(/\bimport\.meta\.url\b/g, JSON.stringify(`file://${args.path}`))
                                .replace(/\b__dirname\b/g, JSON.stringify(path__default.dirname(args.path)))
                                .replace(/\b__filename\b/g, JSON.stringify(args.path))
                        };
                    });
                }
            }
        ]
    });
    const { text } = result.outputFiles[0];
    return {
        code: text,
        dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
    };
}
async function loadConfigFromBundledFile(fileName, bundledCode) {
    const extension = path__default.extname(fileName);
    const defaultLoader = require.extensions[extension];
    require.extensions[extension] = (module, filename) => {
        if (filename === fileName) {
            module._compile(bundledCode, filename);
        }
        else {
            defaultLoader(module, filename);
        }
    };
    // clear cache in case of server restart
    delete require.cache[require.resolve(fileName)];
    const raw = require(fileName);
    const config = raw.__esModule ? raw.default : raw;
    require.extensions[extension] = defaultLoader;
    return config;
}
function loadEnv(mode, envDir, prefixes = 'VITE_') {
    if (mode === 'local') {
        throw new Error(`"local" cannot be used as a mode name because it conflicts with ` +
            `the .local postfix for .env files.`);
    }
    prefixes = arraify(prefixes);
    const env = {};
    const envFiles = [
        /** mode local file */ `.env.${mode}.local`,
        /** mode file */ `.env.${mode}`,
        /** local file */ `.env.local`,
        /** default file */ `.env`
    ];
    // check if there are actual env variables starting with VITE_*
    // these are typically provided inline and should be prioritized
    for (const key in process.env) {
        if (prefixes.some((prefix) => key.startsWith(prefix)) &&
            env[key] === undefined) {
            env[key] = process.env[key];
        }
    }
    for (const file of envFiles) {
        const path = lookupFile(envDir, [file], true);
        if (path) {
            const parsed = dotenv__default.parse(fs__default.readFileSync(path), {
                debug: !!process.env.DEBUG || undefined
            });
            // let environment variables use each other
            dotenvExpand__default({
                parsed,
                // prevent process.env mutation
                ignoreProcessEnv: true
            });
            // only keys that start with prefix are exposed to client
            for (const [key, value] of Object.entries(parsed)) {
                if (prefixes.some((prefix) => key.startsWith(prefix)) &&
                    env[key] === undefined) {
                    env[key] = value;
                }
                else if (key === 'NODE_ENV') {
                    // NODE_ENV override in .env file
                    process.env.VITE_USER_NODE_ENV = value;
                }
            }
        }
    }
    return env;
}
function resolveEnvPrefix({ envPrefix = 'VITE_' }) {
    envPrefix = arraify(envPrefix);
    if (envPrefix.some((prefix) => prefix === '')) {
        throw new Error(`envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`);
    }
    return envPrefix;
}

exports.build = build;
exports.build$1 = build$1;
exports.createLogger = createLogger;
exports.createServer = createServer;
exports.defineConfig = defineConfig;
exports.httpServerStart = httpServerStart;
exports.index = index$1;
exports.index$1 = index;
exports.loadConfigFromFile = loadConfigFromFile;
exports.loadEnv = loadEnv;
exports.mergeConfig = mergeConfig;
exports.normalizePath = normalizePath;
exports.openBrowser = openBrowser;
exports.optimizeDeps = optimizeDeps;
exports.printServerUrls = printServerUrls;
exports.proxyMiddleware = proxyMiddleware;
exports.resolveConfig = resolveConfig;
exports.resolveEnvPrefix = resolveEnvPrefix;
exports.resolveHostname = resolveHostname;
exports.resolveHttpServer = resolveHttpServer;
exports.resolveHttpsConfig = resolveHttpsConfig;
exports.resolvePackageData = resolvePackageData;
exports.resolvePackageEntry = resolvePackageEntry;
exports.send = send;
exports.sortUserPlugins = sortUserPlugins;
exports.transformWithEsbuild = transformWithEsbuild;
//# sourceMappingURL=dep-1ee92c88.js.map
