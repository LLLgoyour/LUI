"use strict";
// Copyright 2020 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const compiler_1 = require("./embedded-compiler/compiler");
const packet_transformer_1 = require("./embedded-compiler/packet-transformer");
const message_transformer_1 = require("./embedded-protocol/message-transformer");
const dispatcher_1 = require("./embedded-protocol/dispatcher");
const utils_1 = require("./embedded-protocol/utils");
const embedded_sass_pb_1 = require("./vendor/embedded-protocol/embedded_sass_pb");
/**
 * Compiles a path and returns the resulting css. Throws a SassException if the
 * compilation failed.
 */
async function compile(options) {
    // TODO(awjin): Create logger, importer, function registries.
    const request = newCompileRequest({
        path: options.path,
        sourceMap: !!options.sourceMap,
    });
    const response = await compileRequest(request);
    if (options.sourceMap) {
        options.sourceMap(response.sourceMap);
    }
    return response.css;
}
exports.compile = compile;
/**
 * Compiles a string and returns the resulting css. Throws a SassException if
 * the compilation failed.
 */
async function compileString(options) {
    // TODO(awjin): Create logger, importer, function registries.
    const request = newCompileStringRequest({
        source: options.source,
        sourceMap: !!options.sourceMap,
        url: options.url instanceof url_1.URL ? options.url.toString() : options.url,
    });
    const response = await compileRequest(request);
    if (options.sourceMap) {
        options.sourceMap(response.sourceMap);
    }
    return response.css;
}
exports.compileString = compileString;
// Creates a request for compiling a file.
function newCompileRequest(options) {
    // TODO(awjin): Populate request with importer/function IDs.
    const request = new embedded_sass_pb_1.InboundMessage.CompileRequest();
    request.setPath(options.path);
    request.setSourceMap(options.sourceMap);
    return request;
}
// Creates a request for compiling a string.
function newCompileStringRequest(options) {
    // TODO(awjin): Populate request with importer/function IDs.
    const input = new embedded_sass_pb_1.InboundMessage.CompileRequest.StringInput();
    input.setSource(options.source);
    if (options.url)
        input.setUrl(options.url.toString());
    const request = new embedded_sass_pb_1.InboundMessage.CompileRequest();
    request.setString(input);
    request.setSourceMap(options.sourceMap);
    return request;
}
// Spins up a compiler, then sends it a compile request. Returns a promise that
// resolves with the CompileResult. Throws if there were any protocol or
// compilation errors. Shuts down the compiler after compilation.
async function compileRequest(request) {
    const embeddedCompiler = new compiler_1.EmbeddedCompiler();
    try {
        const packetTransformer = new packet_transformer_1.PacketTransformer(embeddedCompiler.stdout$, buffer => embeddedCompiler.writeStdin(buffer));
        const messageTransformer = new message_transformer_1.MessageTransformer(packetTransformer.outboundProtobufs$, packet => packetTransformer.writeInboundProtobuf(packet));
        // TODO(awjin): Pass import and function registries' handler functions to
        // dispatcher.
        const dispatcher = new dispatcher_1.Dispatcher(messageTransformer.outboundMessages$, message => messageTransformer.writeInboundMessage(message), {
            handleImportRequest: () => {
                throw Error('Custom importers not yet implemented.');
            },
            handleFileImportRequest: () => {
                throw Error('Custom file importers not yet implemented.');
            },
            handleCanonicalizeRequest: () => {
                throw Error('Canonicalize not yet implemented.');
            },
            handleFunctionCallRequest: () => {
                throw Error('Custom functions not yet implemented.');
            },
        });
        // TODO(awjin): Subscribe logger to dispatcher's log events.
        const response = await dispatcher.sendCompileRequest(request);
        if (response.getSuccess()) {
            const success = response.getSuccess();
            const sourceMap = success.getSourceMap();
            if (request.getSourceMap() && sourceMap === undefined) {
                throw Error('Compiler did not provide sourceMap.');
            }
            return {
                css: success.getCss(),
                sourceMap: sourceMap ? JSON.parse(sourceMap) : undefined,
            };
        }
        else if (response.getFailure()) {
            throw utils_1.deprotifyException(response.getFailure());
        }
        else {
            throw Error('Compiler sent empty CompileResponse.');
        }
    }
    finally {
        embeddedCompiler.close();
    }
}
//# sourceMappingURL=compile.js.map