"use strict";
// Copyright 2021 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
Object.defineProperty(exports, "__esModule", { value: true });
const p = require("path");
const url_1 = require("url");
const compile_1 = require("../compile");
const exception_1 = require("../exception/exception");
const utils_1 = require("../utils");
/**
 * Converts Sass to CSS.
 *
 * This attempts to match the Node Sass `render()` API as closely as possible
 * (see: https://github.com/sass/node-sass#usage).
 */
function render(options, callback) {
    const fileRequest = options;
    const stringRequest = options;
    if (!fileRequest.file && utils_1.isNullOrUndefined(stringRequest.data)) {
        callback(newRenderError(Error('Either options.data or options.file must be set.')));
        return;
    }
    let sourceMap;
    const getSourceMap = wasSourceMapRequested(options)
        ? (map) => (sourceMap = map)
        : undefined;
    const start = Date.now();
    const compileSass = stringRequest.data
        ? compile_1.compileString({
            source: stringRequest.data,
            sourceMap: getSourceMap,
            url: stringRequest.file ? url_1.pathToFileURL(stringRequest.file) : 'stdin',
        })
        : compile_1.compile({ path: fileRequest.file, sourceMap: getSourceMap });
    compileSass.then(css => callback(undefined, newRenderResult(options, start, css, sourceMap)), error => callback(newRenderError(error)));
}
exports.render = render;
// Determines whether a sourceMap was requested by the call to render().
function wasSourceMapRequested(options) {
    return (typeof options.sourceMap === 'string' ||
        (options.sourceMap === true && !!options.outFile));
}
// Transforms the compilation result into an object that mimics the Node Sass
// API format.
function newRenderResult(options, start, css, sourceMap) {
    var _a, _b;
    const end = Date.now();
    let sourceMapBytes;
    if (sourceMap) {
        sourceMap.sourceRoot = (_a = options.sourceMapRoot) !== null && _a !== void 0 ? _a : '';
        const sourceMapPath = typeof options.sourceMap === 'string'
            ? options.sourceMap
            : options.outFile + '.map';
        const sourceMapDir = p.dirname(sourceMapPath);
        if (options.outFile) {
            sourceMap.file = p.relative(sourceMapDir, options.outFile);
        }
        else if (options.file) {
            const extension = p.extname(options.file);
            sourceMap.file = `${options.file.substring(0, options.file.length - extension.length)}.css`;
        }
        else {
            sourceMap.file = 'stdin.css';
        }
        sourceMap.sources = sourceMap.sources.map(source => {
            if (source.startsWith('file://')) {
                return p.relative(sourceMapDir, url_1.fileURLToPath(source));
            }
            return source;
        });
        sourceMapBytes = Buffer.from(JSON.stringify(sourceMap));
        if (!options.omitSourceMapUrl) {
            let url;
            if (options.sourceMapEmbed) {
                url = `data:application/json;base64,${sourceMapBytes.toString('base64')}`;
            }
            else if (options.outFile) {
                url = p.relative(p.dirname(options.outFile), sourceMapPath);
            }
            else {
                url = sourceMapPath;
            }
            css += `\n\n/*# sourceMappingURL=${url} */`;
        }
    }
    return {
        css: Buffer.from(css),
        map: sourceMapBytes,
        stats: {
            entry: (_b = options.file) !== null && _b !== void 0 ? _b : 'data',
            start,
            end,
            duration: end - start,
        },
    };
}
// Decorates an Error with additional fields so that it behaves like a Node Sass
// error.
function newRenderError(error) {
    var _a, _b, _c;
    if (!(error instanceof exception_1.SassException)) {
        return Object.assign(error, {
            status: 3,
        });
    }
    let file = ((_a = error.span) === null || _a === void 0 ? void 0 : _a.url) || undefined;
    if (file && file !== 'stdin') {
        file = url_1.fileURLToPath(file);
    }
    return Object.assign(new Error(), {
        status: 1,
        message: error.toString().replace(/^Error: /, ''),
        formatted: error.toString(),
        toString: () => error.toString(),
        stack: error.stack,
        line: utils_1.isNullOrUndefined((_b = error.span) === null || _b === void 0 ? void 0 : _b.start.line)
            ? undefined
            : error.span.start.line + 1,
        column: utils_1.isNullOrUndefined((_c = error.span) === null || _c === void 0 ? void 0 : _c.start.column)
            ? undefined
            : error.span.start.column + 1,
        file,
    });
}
//# sourceMappingURL=render.js.map