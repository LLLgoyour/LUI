/// <reference types="node" />
import { Observable } from 'rxjs';
import { InboundMessage, OutboundMessage } from '../vendor/embedded-protocol/embedded_sass_pb';
export declare type InboundRequestType = InboundMessage.MessageCase.COMPILE_REQUEST;
export declare type InboundRequest = InboundMessage.CompileRequest;
export declare type InboundResponseType = InboundMessage.MessageCase.IMPORT_RESPONSE | InboundMessage.MessageCase.FILE_IMPORT_RESPONSE | InboundMessage.MessageCase.CANONICALIZE_RESPONSE | InboundMessage.MessageCase.FUNCTION_CALL_RESPONSE;
export declare type InboundResponse = InboundMessage.ImportResponse | InboundMessage.FileImportResponse | InboundMessage.CanonicalizeResponse | InboundMessage.FunctionCallResponse;
export declare type OutboundRequestType = OutboundMessage.MessageCase.IMPORT_REQUEST | OutboundMessage.MessageCase.FILE_IMPORT_REQUEST | OutboundMessage.MessageCase.CANONICALIZE_REQUEST | OutboundMessage.MessageCase.FUNCTION_CALL_REQUEST;
export declare type OutboundRequest = OutboundMessage.ImportRequest | OutboundMessage.FileImportRequest | OutboundMessage.CanonicalizeRequest | OutboundMessage.FunctionCallRequest;
export declare type OutboundResponseType = OutboundMessage.MessageCase.COMPILE_RESPONSE;
export declare type OutboundResponse = OutboundMessage.CompileResponse;
export declare type OutboundEventType = OutboundMessage.MessageCase.LOG_EVENT;
export declare type OutboundEvent = OutboundMessage.LogEvent;
export declare type InboundTypedMessage = {
    payload: InboundRequest | InboundResponse;
    type: InboundRequestType | InboundResponseType;
};
export declare type OutboundTypedMessage = {
    payload: OutboundRequest | OutboundResponse | OutboundEvent;
    type: OutboundRequestType | OutboundResponseType | OutboundEventType;
};
/**
 * Encodes InboundTypedMessages into protocol buffers and decodes protocol
 * buffers into OutboundTypedMessages. Any Embedded Protocol violations that can
 * be detected at the message level are encapsulated here and reported as
 * errors.
 *
 * This transformer communicates via In/OutboundTypedMessages instead of raw
 * In/OutboundMessages in order to expose more type information to consumers.
 * This makes the stream of messages from the transformer easier to interact
 * with.
 */
export declare class MessageTransformer {
    private readonly outboundProtobufs$;
    private readonly writeInboundProtobuf;
    private readonly outboundMessagesInternal$;
    /**
     * The OutboundTypedMessages, decoded from protocol buffers. If any errors are
     * detected while encoding/decoding, this Observable will error out.
     */
    readonly outboundMessages$: Observable<OutboundTypedMessage>;
    constructor(outboundProtobufs$: Observable<Buffer>, writeInboundProtobuf: (buffer: Buffer) => void);
    /**
     * Converts the inbound `message` to a protocol buffer.
     */
    writeInboundMessage(message: InboundTypedMessage): void;
}
