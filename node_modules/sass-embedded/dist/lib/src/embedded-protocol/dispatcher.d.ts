import { Observable } from 'rxjs';
import { InboundMessage, OutboundMessage } from '../vendor/embedded-protocol/embedded_sass_pb';
import { InboundTypedMessage, OutboundTypedMessage } from './message-transformer';
import { PromiseOr } from '../utils';
/**
 * Dispatches requests, responses, and events.
 *
 * Accepts callbacks for processing different types of outbound requests. When
 * an outbound request arrives, this runs the appropriate callback to process
 * it, and then sends the result inbound. A single callback must be provided for
 * each outbound request type. The callback does not need to set the response
 * ID; the dispatcher handles it.
 *
 * Consumers can send an inbound request. This returns a promise that will
 * either resolve with the corresponding outbound response, or error if any
 * Protocol Errors were encountered. The consumer does not need to set the
 * request ID; the dispatcher handles it.
 *
 * Outbound events are exposed as Observables.
 *
 * Errors are not otherwise exposed to the top-level. Instead, they are surfaced
 * as an Observable that consumers may choose to subscribe to. Subscribers must
 * perform proper error handling.
 */
export declare class Dispatcher {
    private readonly outboundMessages$;
    private readonly writeInboundMessage;
    private readonly outboundRequestHandlers;
    private readonly pendingInboundRequests;
    private readonly pendingOutboundRequests;
    private readonly messages$;
    private readonly errorInternal$;
    /**
     * If the dispatcher encounters an error, this errors out. Upon error, the
     * dispatcher rejects all promises awaiting an outbound response, and silently
     * closes all subscriptions to outbound events.
     */
    readonly error$: Observable<void>;
    /**
     * Outbound log events. If an error occurs, the dispatcher closes this
     * silently.
     */
    readonly logEvents$: Observable<OutboundMessage.LogEvent>;
    constructor(outboundMessages$: Observable<OutboundTypedMessage>, writeInboundMessage: (message: InboundTypedMessage) => void, outboundRequestHandlers: {
        handleImportRequest: (request: OutboundMessage.ImportRequest) => PromiseOr<InboundMessage.ImportResponse>;
        handleFileImportRequest: (request: OutboundMessage.FileImportRequest) => PromiseOr<InboundMessage.FileImportResponse>;
        handleCanonicalizeRequest: (request: OutboundMessage.CanonicalizeRequest) => PromiseOr<InboundMessage.CanonicalizeResponse>;
        handleFunctionCallRequest: (request: OutboundMessage.FunctionCallRequest) => PromiseOr<InboundMessage.FunctionCallResponse>;
    });
    /**
     * Sends a CompileRequest inbound. Returns a promise that will either resolve
     * with the corresponding outbound CompileResponse, or error if any Protocol
     * Errors were encountered.
     */
    sendCompileRequest(request: InboundMessage.CompileRequest): Promise<OutboundMessage.CompileResponse>;
    private throwAndClose;
    private handleOutboundMessage;
    private handleInboundRequest;
    private sendInboundMessage;
}
