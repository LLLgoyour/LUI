import { List } from 'immutable';
import { Value } from './value';
/** A SassScript number. */
export declare class SassNumber extends Value {
    private valueInternal;
    private numeratorUnitsInternal;
    private denominatorUnitsInternal;
    /** Creates a number, optionally with a single numerator unit. */
    constructor(value: number, unit?: string);
    /**
     * Creates a number with `numeratorUnits` and `denominatorUnits`.
     *
     * Upon construction, any compatible numerator and denominator units are
     * simplified away according to the conversion factor between them.
     */
    static withUnits(value: number, options?: {
        numeratorUnits?: string[] | List<string>;
        denominatorUnits?: string[] | List<string>;
    }): SassNumber;
    /** `this`'s value. */
    get value(): number;
    /** Whether `value` is an integer. */
    get isInt(): boolean;
    /**
     * If `value` is an integer according to `isInt`, returns `value` rounded to
     * that integer.
     *
     * Otherwise, returns null.
     */
    get asInt(): number | null;
    /** `this`'s numerator units. */
    get numeratorUnits(): List<string>;
    /** `this`'s denominator units. */
    get denominatorUnits(): List<string>;
    /** Whether `this` has any units. */
    get hasUnits(): boolean;
    assertNumber(): SassNumber;
    /**
     * If `value` is an integer according to `isInt`, returns it as an integer.
     *
     * Otherwise, throws an error.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    assertInt(name?: string): number;
    /**
     * If `value` is within `min` and `max`, returns `value`, or if it
     * `fuzzyEquals` `min` or `max`, returns `value` clamped to that value.
     *
     * Otherwise, throws an error.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    assertInRange(min: number, max: number, name?: string): number;
    /**
     * If `this` has no units, returns `this`.
     *
     * Otherwise, throws an error.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    assertNoUnits(name?: string): SassNumber;
    /**
     * If `this` has `unit` as its only unit (and as a numerator), returns `this`.
     *
     * Otherwise, throws an error.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    assertUnit(unit: string, name?: string): SassNumber;
    /** Whether `this` has `unit` as its only unit (and as a numerator). */
    hasUnit(unit: string): boolean;
    /** Whether `this` is compatible with `unit`. */
    compatibleWithUnit(unit: string): boolean;
    /**
     * Returns a copy of `this`, converted to the units represented by
     * `newNumerators` and `newDenominators`.
     *
     * Throws an error if `this`'s units are incompatible with `newNumerators` and
     * `newDenominators`. Also throws an error if `this` is unitless and either
     * `newNumerators` or `newDenominators` are not empty, or vice-versa.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    convert(newNumerators: string[] | List<string>, newDenominators: string[] | List<string>, name?: string): SassNumber;
    /**
     * Returns `value`, converted to the units represented by `newNumerators` and
     * `newDenominators`.
     *
     * Throws an error if `this`'s units are incompatible with `newNumerators` and
     * `newDenominators`. Also throws an error if `this` is unitless and either
     * `newNumerators` or `newDenominators` are not empty, or vice-versa.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    convertValue(newNumerators: string[] | List<string>, newDenominators: string[] | List<string>, name?: string): number;
    /**
     * Returns a copy of `this`, converted to the same units as `other`.
     *
     * Throws an error if `this`'s units are incompatible with `other`'s units, or
     * if either number is unitless but the other is not.
     *
     * If `this` came from a function argument, `name` is the argument name
     * and `otherName` is the argument name for `other` (both without the `$`).
     * They are used for error reporting.
     */
    convertToMatch(other: SassNumber, name?: string, otherName?: string): SassNumber;
    /**
     * Returns `value`, converted to the same units as `other`.
     *
     * Throws an error if `this`'s units are incompatible with `other`'s units, or
     * if either number is unitless but the other is not.
     *
     * If `this` came from a function argument, `name` is the argument name
     * and `otherName` is the argument name for `other` (both without the `$`).
     * They are used for error reporting.
     */
    convertValueToMatch(other: SassNumber, name?: string, otherName?: string): number;
    /**
     * Returns a copy of `this`, converted to the units represented by
     * `newNumerators` and `newDenominators`.
     *
     * Does *not* throw an error if this number is unitless and either
     * `newNumerators` or `newDenominators` are not empty, or vice-versa. Instead,
     * it treats all unitless numbers as convertible to and from all units
     * without changing the value.
     *
     * Throws an error if `this`'s units are incompatible with `newNumerators` and
     * `newDenominators`.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    coerce(newNumerators: string[] | List<string>, newDenominators: string[] | List<string>, name?: string): SassNumber;
    /**
     * Returns `value`, converted to the units represented by `newNumerators` and
     * `newDenominators`.
     *
     * Does *not* throw an error if this number is unitless and either
     * `newNumerators` or `newDenominators` are not empty, or vice-versa. Instead,
     * it treats all unitless numbers as convertible to and from all units
     * without changing the value.
     *
     * Throws an error if `this`'s units are incompatible with `newNumerators` and
     * `newDenominators`.
     *
     * If `this` came from a function argument, `name` is the argument name
     * (without the `$`) and is used for error reporting.
     */
    coerceValue(newNumerators: string[] | List<string>, newDenominators: string[] | List<string>, name?: string): number;
    /**
     * Returns a copy of `this`, converted to the same units as `other`.
     *
     * Does *not* throw an error if `this` is unitless and `other` is not, or
     * vice-versa. Instead, it treats all unitless numbers as convertible to and
     * from all units without changing the value.
     *
     * Throws an error if `this`'s units are incompatible with `other`'s units.
     *
     * If `this` came from a function argument, `name` is the argument name
     * and `otherName` is the argument name for `other` (both without the `$`).
     * They are used for error reporting.
     */
    coerceToMatch(other: SassNumber, name?: string, otherName?: string): SassNumber;
    /**
     * Returns `value`, converted to the same units as `other`.
     *
     * Does *not* throw an error if `this` is unitless and `other` is not, or
     * vice-versa. Instead, it treats all unitless numbers as convertible to and
     * from all units without changing the value.
     *
     * Throws an error if `this`'s units are incompatible with `other`'s units.
     *
     * If `this` came from a function argument, `name` is the argument name
     * and `otherName` is the argument name for `other` (both without the `$`).
     * They are used for error reporting.
     */
    coerceValueToMatch(other: SassNumber, name?: string, otherName?: string): number;
    equals(other: Value): boolean;
    hashCode(): number;
    toString(): string;
    private convertOrCoerce;
}
